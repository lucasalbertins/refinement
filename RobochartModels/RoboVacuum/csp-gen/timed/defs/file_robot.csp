
--
-- RoboChart generator version 3.0.0.202112100958
-- Automatically generated on 04-03-2022 10:59:36
--
-- Iterated compression status: true
-- Assertions compression status: true
--


module Module
	exports
	
	transparent diamond
	transparent sbisim
	transparent dbisim
	transparent chase
	
	-- declaring channels
	-- declaring robotic platform events
	channel acc_l: InOut.TripleAxis
	channel acc_r: InOut.TripleAxis
	channel ultrasonic: InOut.core_int
	channel battery_level: InOut.core_int
	channel charging: InOut
	
	channel output_left_motorCall: core_int
	channel output_right_motorCall: core_int
	channel vacuumCall: core_int
	channel brushCall: core_int
	
	-- declaring module termination channel
	channel terminate
	
	-- declaring robotic platform variables
	
	-- channel set with all visible events
	sem__events = {|
		acc_l,
		acc_r,
		ultrasonic,
		battery_level,
		charging
	,	output_left_motorCall,
		output_right_motorCall,
		vacuumCall,
		brushCall
	|}
	
	-- declaring controller
		module PathPlanningController
			shared_variable_events = {|
			|}
			
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
	
			-- declaring controller events
			channel acc_l: InOut.TripleAxis
			channel acc_r: InOut.TripleAxis
			channel ultrasonic: InOut.core_int
			channel battery_level: InOut.core_int
			channel charging: InOut
			
			
			
			-- declaring call and ret events for undefined operations
			channel output_right_motorCall: core_int
			channel vacuumCall: core_int
			channel brushCall: core_int
			channel output_left_motorCall: core_int
			
			-- declaring controller termination channel
			channel terminate
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	acc_l,
				acc_r,
				ultrasonic,
				battery_level,
				charging
			,	output_right_motorCall,
				vacuumCall,
				brushCall,
				output_left_motorCall
			|}
			
			-- set of visible memory events
			visibleMemoryEvents = {||}
	
			-- defined operations
		
			-- declaring machines
			module stm_ref0
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_Go_up|
				              NID_Go_right|
				              NID_Go_down|
				              NID_Go_right_again|
				              NID_Return|
				              NID_Dock|
				              NID_Sleep|
				              NID_Check_end|
				              NID_Check_battery|
				              NID_Resume
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_cycles, set_cycles, setL_cycles, setR_cycles: core_int
				channel get_u, set_u, setL_u, setR_u: core_int
				channel get_d, set_d, setL_d, setR_d: core_int
				channel get_b, set_b, setL_b, setR_b: core_int
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel move_forward__: NIDS.InOut
				channel move_forward: InOut
				channel turn__: NIDS.InOut.Direction
				channel turn: InOut.Direction
				channel stop__: NIDS.InOut
				channel stop: InOut
				channel ultrasonic__: NIDS.InOut.core_int
				channel ultrasonic: InOut.core_int
				channel battery_level__: NIDS.InOut.core_int
				channel battery_level: InOut.core_int
				channel charging__: NIDS.InOut
				channel charging: InOut
				channel clean__: NIDS.InOut.core_boolean
				channel clean: InOut.core_boolean
				channel displacement__: NIDS.InOut.core_int
				channel displacement: InOut.core_int
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				Go_up::enter,
				Go_right::enter,
				Go_down::enter,
				Go_right_again::enter,
				Return::enter,
				Dock::enter,
				Sleep::enter,
				Check_end::enter,
				Check_battery::enter,
				Resume::enter
				|}
				
				enteredSS = 	{|
				Go_up::entered,
				Go_right::entered,
				Go_down::entered,
				Go_right_again::entered,
				Return::entered,
				Dock::entered,
				Sleep::entered,
				Check_end::entered,
				Check_battery::entered,
				Resume::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	move_forward,
					turn,
					stop,
					ultrasonic,
					battery_level,
					charging,
					clean,
					displacement
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_Go_right : core_clock_type 
				channel get_CLID_Dock : core_clock_type 
				channel get_CLID_Go_down : core_clock_type 
				channel get_CLID_Go_up : core_clock_type 
				channel get_CLID_Check_end : core_clock_type 
				channel get_CLID_Resume : core_clock_type 
				channel get_CLID_Check_battery : core_clock_type 
				channel get_CLID_Go_right_again : core_clock_type 
				channel get_CLID_Sleep : core_clock_type 
				channel get_CLID_Return : core_clock_type 
				--channel increment__
				
				CLID_Go_right_clock_type(id__,
						          const_PathPlanningSM_cliff,
						          const_PathPlanningSM_nozzle,
						          const_PathPlanningSM_battery_low,
						          const_PathPlanningSM_sleep_time,
						          const_PathPlanningSM_acc_distance) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Dock_clock_type(id__,
						          const_PathPlanningSM_cliff,
						          const_PathPlanningSM_nozzle,
						          const_PathPlanningSM_battery_low,
						          const_PathPlanningSM_sleep_time,
						          const_PathPlanningSM_acc_distance) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Go_down_clock_type(id__,
						          const_PathPlanningSM_cliff,
						          const_PathPlanningSM_nozzle,
						          const_PathPlanningSM_battery_low,
						          const_PathPlanningSM_sleep_time,
						          const_PathPlanningSM_acc_distance) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Go_up_clock_type(id__,
						          const_PathPlanningSM_cliff,
						          const_PathPlanningSM_nozzle,
						          const_PathPlanningSM_battery_low,
						          const_PathPlanningSM_sleep_time,
						          const_PathPlanningSM_acc_distance) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Check_end_clock_type(id__,
						          const_PathPlanningSM_cliff,
						          const_PathPlanningSM_nozzle,
						          const_PathPlanningSM_battery_low,
						          const_PathPlanningSM_sleep_time,
						          const_PathPlanningSM_acc_distance) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Resume_clock_type(id__,
						          const_PathPlanningSM_cliff,
						          const_PathPlanningSM_nozzle,
						          const_PathPlanningSM_battery_low,
						          const_PathPlanningSM_sleep_time,
						          const_PathPlanningSM_acc_distance) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Check_battery_clock_type(id__,
						          const_PathPlanningSM_cliff,
						          const_PathPlanningSM_nozzle,
						          const_PathPlanningSM_battery_low,
						          const_PathPlanningSM_sleep_time,
						          const_PathPlanningSM_acc_distance) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Go_right_again_clock_type(id__,
						          const_PathPlanningSM_cliff,
						          const_PathPlanningSM_nozzle,
						          const_PathPlanningSM_battery_low,
						          const_PathPlanningSM_sleep_time,
						          const_PathPlanningSM_acc_distance) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Sleep_clock_type(id__,
						          const_PathPlanningSM_cliff,
						          const_PathPlanningSM_nozzle,
						          const_PathPlanningSM_battery_low,
						          const_PathPlanningSM_sleep_time,
						          const_PathPlanningSM_acc_distance) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Return_clock_type(id__,
						          const_PathPlanningSM_cliff,
						          const_PathPlanningSM_nozzle,
						          const_PathPlanningSM_battery_low,
						          const_PathPlanningSM_sleep_time,
						          const_PathPlanningSM_acc_distance) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) = D__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Go_up
					module Go_up
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(move_forward.out -> SKIP)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(move_forward.out -> SKIP)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Go_right
					module Go_right
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(turn.out!Direction_right -> SKIP));true&(share__choice(move_forward.out -> SKIP));true&(share__choice(displacement.out!0 -> SKIP)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(turn.out!Direction_right -> SKIP));true&(share__choice(move_forward.out -> SKIP));true&(share__choice(displacement.out!0 -> SKIP)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Go_down
					module Go_down
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(turn.out!Direction_right -> SKIP));true&(share__choice(move_forward.out -> SKIP)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(turn.out!Direction_right -> SKIP));true&(share__choice(move_forward.out -> SKIP)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Go_right_again
					module Go_right_again
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Return
					module Return
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(turn.out!Direction_left -> SKIP));true&(share__choice(turn.out!Direction_left -> SKIP));true&(share__choice(move_forward.out -> SKIP));true&(share__choice(clean.out!false -> SKIP)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(turn.out!Direction_left -> SKIP));true&(share__choice(turn.out!Direction_left -> SKIP));true&(share__choice(move_forward.out -> SKIP));true&(share__choice(clean.out!false -> SKIP)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Dock
					module Dock
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(turn.out!Direction_left -> SKIP));true&(share__choice(move_forward.out -> SKIP)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(turn.out!Direction_left -> SKIP));true&(share__choice(move_forward.out -> SKIP)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Sleep
					module Sleep
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(stop.out -> SKIP));SHARE_WAIT(const_PathPlanningSM_sleep_time) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(stop.out -> SKIP));SHARE_WAIT(const_PathPlanningSM_sleep_time) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Check_end
					module Check_end
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Check_battery
					module Check_battery
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Resume
					module Resume
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(turn.out!Direction_right -> SKIP));true&(share__choice(move_forward.out -> SKIP));true&(share__choice(displacement.out!0 -> SKIP)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; true&(share__choice(turn.out!Direction_left -> SKIP)) ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(turn.out!Direction_right -> SKIP));true&(share__choice(move_forward.out -> SKIP));true&(share__choice(displacement.out!0 -> SKIP)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; true&(share__choice(turn.out!Direction_left -> SKIP)) ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__,
										    const_PathPlanningSM_cliff,
										    const_PathPlanningSM_nozzle,
										    const_PathPlanningSM_battery_low,
										    const_PathPlanningSM_sleep_time,
										    const_PathPlanningSM_acc_distance) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_PathPlanningSM_cliff,
								    const_PathPlanningSM_nozzle,
								    const_PathPlanningSM_battery_low,
								    const_PathPlanningSM_sleep_time,
								    const_PathPlanningSM_acc_distance))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					STM_VS_O(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__,
										    const_PathPlanningSM_cliff,
										    const_PathPlanningSM_nozzle,
										    const_PathPlanningSM_battery_low,
										    const_PathPlanningSM_sleep_time,
										    const_PathPlanningSM_acc_distance) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_PathPlanningSM_cliff,
								    const_PathPlanningSM_nozzle,
								    const_PathPlanningSM_battery_low,
								    const_PathPlanningSM_sleep_time,
								    const_PathPlanningSM_acc_distance))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					-- Transitions
					Transitions(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = ((let
						Trans = share__choice(get_u?u -> get_cycles?cycles -> get_b?b -> get_d?d -> TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((share__choice(true & (share__choice(set_cycles!0 -> SKIP))) ; Resume::enter -> SKIP))))
							 [] dbisim((ultrasonic__!NID_Go_up.in?u:{u|u <- core_int, (u>=const_PathPlanningSM_cliff)} -> share__choice(set_u!u -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Go_right::enter -> SKIP)))
							 [] dbisim((displacement__!NID_Go_right.in?d:{d|d <- core_int, (d>=const_PathPlanningSM_nozzle)} -> share__choice(set_d!d -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Go_down::enter -> SKIP)))
							 [] dbisim((ultrasonic__!NID_Go_down.in?u:{u|u <- core_int, (u>=const_PathPlanningSM_cliff)} -> share__choice(set_u!u -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(turn.out!Direction_left -> SKIP));true&(share__choice(move_forward.out -> SKIP));true&(share__choice(displacement.out!0 -> SKIP)) ; Go_right_again::enter -> SKIP)))
							 [] dbisim((ultrasonic__!NID_Go_right_again.in?u:{u|u <- core_int, (u<const_PathPlanningSM_cliff)} -> share__choice(set_u!u -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Check_end::enter -> SKIP)))
							 [] dbisim((ultrasonic__!NID_Go_right_again.in?u:{u|u <- core_int, (u>=const_PathPlanningSM_cliff)} -> share__choice(set_u!u -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_cycles!0 -> SKIP))) ; Return::enter -> SKIP)))
							 [] dbisim((displacement__!NID_Check_end.in?d:{d|d <- core_int, (d<const_PathPlanningSM_nozzle)} -> share__choice(set_d!d -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Go_right_again::enter -> SKIP)))
							 [] dbisim((displacement__!NID_Check_end.in?d:{d|d <- core_int, (d>=const_PathPlanningSM_nozzle)} -> share__choice(set_d!d -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_cycles?cycles -> true & (share__choice(set_cycles!Plus(cycles, 1, core_int) -> SKIP)))) ; Check_battery::enter -> SKIP)))
							 [] dbisim((battery_level__!NID_Check_battery.in?b:{b|b <- core_int, (b>const_PathPlanningSM_battery_low)} -> share__choice(set_b!b -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(turn.out!Direction_left -> SKIP)) ; Go_up::enter -> SKIP)))
							 [] dbisim((battery_level__!NID_Check_battery.in?b:{b|b <- core_int, (b<=const_PathPlanningSM_battery_low)} -> share__choice(set_b!b -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Return::enter -> SKIP)))
							 [] dbisim((ultrasonic__!NID_Return.in?u:{u|u <- core_int, (u>=const_PathPlanningSM_cliff)} -> share__choice(set_u!u -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Dock::enter -> SKIP)))
							 [] dbisim((true)&(charging__!NID_Dock.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Sleep::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_Sleep -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(turn.out!Direction_left -> SKIP));true&(share__choice(turn.out!Direction_left -> SKIP));true&(share__choice(move_forward.out -> SKIP)) ; Resume::enter -> SKIP)))
							 [] dbisim((displacement__!NID_Resume.in?d:{d|d <- core_int, (d>=Mult(Mult(cycles, 2, core_int), const_PathPlanningSM_nozzle, core_int))} -> share__choice(set_d!d -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(clean.out!true -> SKIP)) ; Go_up::enter -> SKIP)))
							 [] dbisim((ultrasonic__!NID_Go_right.in?u:{u|u <- core_int, (u>=const_PathPlanningSM_cliff)} -> share__choice(set_u!u -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Go_down::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
						)
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Go_up::enter,
								Go_right::enter,
								Go_down::enter,
								Go_right_again::enter,
								Return::enter,
								Dock::enter,
								Sleep::enter,
								Check_end::enter,
								Check_battery::enter,
								Resume::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,ultrasonic__.NID_Go_up.in,displacement__.NID_Go_right.in,ultrasonic__.NID_Go_down.in,ultrasonic__.NID_Go_right_again.in,ultrasonic__.NID_Go_right_again.in,displacement__.NID_Check_end.in,displacement__.NID_Check_end.in,battery_level__.NID_Check_battery.in,battery_level__.NID_Check_battery.in,ultrasonic__.NID_Return.in,charging__.NID_Dock.in,internal__.NID_Sleep,displacement__.NID_Resume.in,ultrasonic__.NID_Go_right.in|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__,
									   		    const_PathPlanningSM_cliff,
									   		    const_PathPlanningSM_nozzle,
									   		    const_PathPlanningSM_battery_low,
									   		    const_PathPlanningSM_sleep_time,
									   		    const_PathPlanningSM_acc_distance)
									   [| { share__, terminate } |] (
									   Go_up::D__(id__,
									   		    const_PathPlanningSM_cliff,
									   		    const_PathPlanningSM_nozzle,
									   		    const_PathPlanningSM_battery_low,
									   		    const_PathPlanningSM_sleep_time,
									   		    const_PathPlanningSM_acc_distance)
									   [| { share__, terminate } |] (
									   Go_right::D__(id__,
									   		    const_PathPlanningSM_cliff,
									   		    const_PathPlanningSM_nozzle,
									   		    const_PathPlanningSM_battery_low,
									   		    const_PathPlanningSM_sleep_time,
									   		    const_PathPlanningSM_acc_distance)
									   [| { share__, terminate } |] (
									   Go_down::D__(id__,
									   		    const_PathPlanningSM_cliff,
									   		    const_PathPlanningSM_nozzle,
									   		    const_PathPlanningSM_battery_low,
									   		    const_PathPlanningSM_sleep_time,
									   		    const_PathPlanningSM_acc_distance)
									   [| { share__, terminate } |] (
									   Go_right_again::D__(id__,
									   		    const_PathPlanningSM_cliff,
									   		    const_PathPlanningSM_nozzle,
									   		    const_PathPlanningSM_battery_low,
									   		    const_PathPlanningSM_sleep_time,
									   		    const_PathPlanningSM_acc_distance)
									   [| { share__, terminate } |] (
									   Return::D__(id__,
									   		    const_PathPlanningSM_cliff,
									   		    const_PathPlanningSM_nozzle,
									   		    const_PathPlanningSM_battery_low,
									   		    const_PathPlanningSM_sleep_time,
									   		    const_PathPlanningSM_acc_distance)
									   [| { share__, terminate } |] (
									   Dock::D__(id__,
									   		    const_PathPlanningSM_cliff,
									   		    const_PathPlanningSM_nozzle,
									   		    const_PathPlanningSM_battery_low,
									   		    const_PathPlanningSM_sleep_time,
									   		    const_PathPlanningSM_acc_distance)
									   [| { share__, terminate } |] (
									   Sleep::D__(id__,
									   		    const_PathPlanningSM_cliff,
									   		    const_PathPlanningSM_nozzle,
									   		    const_PathPlanningSM_battery_low,
									   		    const_PathPlanningSM_sleep_time,
									   		    const_PathPlanningSM_acc_distance)
									   [| { share__, terminate } |] (
									   Check_end::D__(id__,
									   		    const_PathPlanningSM_cliff,
									   		    const_PathPlanningSM_nozzle,
									   		    const_PathPlanningSM_battery_low,
									   		    const_PathPlanningSM_sleep_time,
									   		    const_PathPlanningSM_acc_distance)
									   [| { share__, terminate } |] (
									   Check_battery::D__(id__,
									   		    const_PathPlanningSM_cliff,
									   		    const_PathPlanningSM_nozzle,
									   		    const_PathPlanningSM_battery_low,
									   		    const_PathPlanningSM_sleep_time,
									   		    const_PathPlanningSM_acc_distance)
									   [| { share__, terminate } |] (
									   Resume::D__(id__,
									   		    const_PathPlanningSM_cliff,
									   		    const_PathPlanningSM_nozzle,
									   		    const_PathPlanningSM_battery_low,
									   		    const_PathPlanningSM_sleep_time,
									   		    const_PathPlanningSM_acc_distance)
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									 )
									 [[Go_up::interrupt <- x__ | x__ <- {|interrupt,ultrasonic__.NID_Go_up.in|}]]
									 [[Go_right::interrupt <- x__ | x__ <- {|interrupt,displacement__.NID_Go_right.in,ultrasonic__.NID_Go_right.in|}]]
									 [[Go_down::interrupt <- x__ | x__ <- {|interrupt,ultrasonic__.NID_Go_down.in|}]]
									 [[Go_right_again::interrupt <- x__ | x__ <- {|interrupt,ultrasonic__.NID_Go_right_again.in,ultrasonic__.NID_Go_right_again.in|}]]
									 [[Return::interrupt <- x__ | x__ <- {|interrupt,ultrasonic__.NID_Return.in|}]]
									 [[Dock::interrupt <- x__ | x__ <- {|interrupt,charging__.NID_Dock.in|}]]
									 [[Sleep::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Sleep|}]]
									 [[Check_end::interrupt <- x__ | x__ <- {|interrupt,displacement__.NID_Check_end.in,displacement__.NID_Check_end.in|}]]
									 [[Check_battery::interrupt <- x__ | x__ <- {|interrupt,battery_level__.NID_Check_battery.in,battery_level__.NID_Check_battery.in|}]]
									 [[Resume::interrupt <- x__ | x__ <- {|interrupt,displacement__.NID_Resume.in|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_u,setR_b,setR_d |} ]] 
									  [[set_u <- setL_u,set_cycles <- setL_cycles,set_b <- setL_b,set_d <- setL_d]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_u
									 			,setL_cycles
									 			,setL_b
									 			,setL_d
									 			,setR_u
									 			 			,setR_b
									 			 			,setR_d
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_PathPlanningSM_cliff,
									 		    const_PathPlanningSM_nozzle,
									 		    const_PathPlanningSM_battery_low,
									 		    const_PathPlanningSM_sleep_time,
									 		    const_PathPlanningSM_acc_distance))
									  [[ share__ <- x__ | x__ <- {| share__,setL_u,setL_cycles,setL_b,setL_d |} ]]
									  [[set_u <- setR_u,set_b <- setR_b,set_d <- setR_d]]
									 )
									)[[setL_u <- set_u,setL_cycles <- set_cycles,setL_b <- set_b,setL_d <- set_d]]
									 [[setR_u <- set_u,setR_b <- set_b,setR_d <- set_d]]
									)
								)
								 \ hideSet)
								[[
									move_forward__.x____ <- move_forward,
									turn__.x____ <- turn,
									stop__.x____ <- stop,
									ultrasonic__.x____ <- ultrasonic,
									battery_level__.x____ <- battery_level,
									charging__.x____ <- charging,
									clean__.x____ <- clean,
									displacement__.x____ <- displacement
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_PathPlanningSM_cliff,
							 		          const_PathPlanningSM_nozzle,
							 		          const_PathPlanningSM_battery_low,
							 		          const_PathPlanningSM_sleep_time,
							 		          const_PathPlanningSM_acc_distance)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
						dbisim((let
							stateClockSync = {|get_CLID_Go_right,Go_right::entered,get_CLID_Dock,Dock::entered,get_CLID_Go_down,Go_down::entered,get_CLID_Go_up,Go_up::entered,get_CLID_Check_end,Check_end::entered,get_CLID_Resume,Resume::entered,get_CLID_Check_battery,Check_battery::entered,get_CLID_Go_right_again,Go_right_again::entered,get_CLID_Sleep,Sleep::entered,get_CLID_Return,Return::entered|}
						 within
							(MachineBody(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
						dbisim((let
							stateClockSync = {|get_CLID_Go_right,Go_right::entered,get_CLID_Dock,Dock::entered,get_CLID_Go_down,Go_down::entered,get_CLID_Go_up,Go_up::entered,get_CLID_Check_end,Check_end::entered,get_CLID_Resume,Resume::entered,get_CLID_Check_battery,Check_battery::entered,get_CLID_Go_right_again,Go_right_again::entered,get_CLID_Sleep,Sleep::entered,get_CLID_Return,Return::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															dbisim(
																sbisim(
																	dbisim(
																		sbisim(
																			dbisim(
																				sbisim(
																					dbisim(
																						sbisim(
																							dbisim(
																								sbisim(
																									dbisim(
																										sbisim(
																											MachineBody(id__,
																													    const_PathPlanningSM_cliff,
																													    const_PathPlanningSM_nozzle,
																													    const_PathPlanningSM_battery_low,
																													    const_PathPlanningSM_sleep_time,
																													    const_PathPlanningSM_acc_distance)
																											[| {|get_CLID_Return,Return::entered,terminate|} |]
																											dbisim(Clock_CLID_Return(id__,0,
																													          const_PathPlanningSM_cliff,
																													          const_PathPlanningSM_nozzle,
																													          const_PathPlanningSM_battery_low,
																													          const_PathPlanningSM_sleep_time,
																													          const_PathPlanningSM_acc_distance))
																										)\{|get_CLID_Return|}
																									)
																									[| {|get_CLID_Sleep,Sleep::entered,terminate|} |]
																									dbisim(Clock_CLID_Sleep(id__,0,
																											          const_PathPlanningSM_cliff,
																											          const_PathPlanningSM_nozzle,
																											          const_PathPlanningSM_battery_low,
																											          const_PathPlanningSM_sleep_time,
																											          const_PathPlanningSM_acc_distance))
																								)\{|get_CLID_Sleep|}
																							)
																							[| {|get_CLID_Go_right_again,Go_right_again::entered,terminate|} |]
																							dbisim(Clock_CLID_Go_right_again(id__,0,
																									          const_PathPlanningSM_cliff,
																									          const_PathPlanningSM_nozzle,
																									          const_PathPlanningSM_battery_low,
																									          const_PathPlanningSM_sleep_time,
																									          const_PathPlanningSM_acc_distance))
																						)\{|get_CLID_Go_right_again|}
																					)
																					[| {|get_CLID_Check_battery,Check_battery::entered,terminate|} |]
																					dbisim(Clock_CLID_Check_battery(id__,0,
																							          const_PathPlanningSM_cliff,
																							          const_PathPlanningSM_nozzle,
																							          const_PathPlanningSM_battery_low,
																							          const_PathPlanningSM_sleep_time,
																							          const_PathPlanningSM_acc_distance))
																				)\{|get_CLID_Check_battery|}
																			)
																			[| {|get_CLID_Resume,Resume::entered,terminate|} |]
																			dbisim(Clock_CLID_Resume(id__,0,
																					          const_PathPlanningSM_cliff,
																					          const_PathPlanningSM_nozzle,
																					          const_PathPlanningSM_battery_low,
																					          const_PathPlanningSM_sleep_time,
																					          const_PathPlanningSM_acc_distance))
																		)\{|get_CLID_Resume|}
																	)
																	[| {|get_CLID_Check_end,Check_end::entered,terminate|} |]
																	dbisim(Clock_CLID_Check_end(id__,0,
																			          const_PathPlanningSM_cliff,
																			          const_PathPlanningSM_nozzle,
																			          const_PathPlanningSM_battery_low,
																			          const_PathPlanningSM_sleep_time,
																			          const_PathPlanningSM_acc_distance))
																)\{|get_CLID_Check_end|}
															)
															[| {|get_CLID_Go_up,Go_up::entered,terminate|} |]
															dbisim(Clock_CLID_Go_up(id__,0,
																	          const_PathPlanningSM_cliff,
																	          const_PathPlanningSM_nozzle,
																	          const_PathPlanningSM_battery_low,
																	          const_PathPlanningSM_sleep_time,
																	          const_PathPlanningSM_acc_distance))
														)\{|get_CLID_Go_up|}
													)
													[| {|get_CLID_Go_down,Go_down::entered,terminate|} |]
													dbisim(Clock_CLID_Go_down(id__,0,
															          const_PathPlanningSM_cliff,
															          const_PathPlanningSM_nozzle,
															          const_PathPlanningSM_battery_low,
															          const_PathPlanningSM_sleep_time,
															          const_PathPlanningSM_acc_distance))
												)\{|get_CLID_Go_down|}
											)
											[| {|get_CLID_Dock,Dock::entered,terminate|} |]
											dbisim(Clock_CLID_Dock(id__,0,
													          const_PathPlanningSM_cliff,
													          const_PathPlanningSM_nozzle,
													          const_PathPlanningSM_battery_low,
													          const_PathPlanningSM_sleep_time,
													          const_PathPlanningSM_acc_distance))
										)\{|get_CLID_Dock|}
									)
									[| {|get_CLID_Go_right,Go_right::entered,terminate|} |]
									dbisim(Clock_CLID_Go_right(id__,0,
											          const_PathPlanningSM_cliff,
											          const_PathPlanningSM_nozzle,
											          const_PathPlanningSM_battery_low,
											          const_PathPlanningSM_sleep_time,
											          const_PathPlanningSM_acc_distance))
								)\{|get_CLID_Go_right|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
						((let
							getsetLocalChannels = {|get_cycles,set_cycles,
							get_u,set_u,
							get_d,set_d,
							get_b,set_b|}
							clockSync = {||}
						within
							(Behaviour(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_PathPlanningSM_cliff,
							 		    const_PathPlanningSM_nozzle,
							 		    const_PathPlanningSM_battery_low,
							 		    const_PathPlanningSM_sleep_time,
							 		    const_PathPlanningSM_acc_distance) [| {terminate} |] Clocks(id__,
							 		          const_PathPlanningSM_cliff,
							 		          const_PathPlanningSM_nozzle,
							 		          const_PathPlanningSM_battery_low,
							 		          const_PathPlanningSM_sleep_time,
							 		          const_PathPlanningSM_acc_distance))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														IteratedBehaviour(id__,
																    const_PathPlanningSM_cliff,
																    const_PathPlanningSM_nozzle,
																    const_PathPlanningSM_battery_low,
																    const_PathPlanningSM_sleep_time,
																    const_PathPlanningSM_acc_distance)
														[| {|get_b,set_b,terminate|} |]
														Memory_b(0)
													)\{|get_b,set_b|}
												)
												[| {|get_d,set_d,terminate|} |]
												Memory_d(0)
											)\{|get_d,set_d|}
										)
										[| {|get_u,set_u,terminate|} |]
										Memory_u(0)
									)\{|get_u,set_u|}
								)
								[| {|get_cycles,set_cycles,terminate|} |]
								Memory_cycles(0)
							)\{|get_cycles,set_cycles|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Go_up::enter,
								Go_right::enter,
								Go_down::enter,
								Go_right_again::enter,
								Return::enter,
								Dock::enter,
								Sleep::enter,
								Check_end::enter,
								Check_battery::enter,
								Resume::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,ultrasonic__.NID_Go_up.in,displacement__.NID_Go_right.in,ultrasonic__.NID_Go_down.in,ultrasonic__.NID_Go_right_again.in,ultrasonic__.NID_Go_right_again.in,displacement__.NID_Check_end.in,displacement__.NID_Check_end.in,battery_level__.NID_Check_battery.in,battery_level__.NID_Check_battery.in,ultrasonic__.NID_Return.in,charging__.NID_Dock.in,internal__.NID_Sleep,displacement__.NID_Resume.in,ultrasonic__.NID_Go_right.in|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__,
									   		    const_PathPlanningSM_cliff,
									   		    const_PathPlanningSM_nozzle,
									   		    const_PathPlanningSM_battery_low,
									   		    const_PathPlanningSM_sleep_time,
									   		    const_PathPlanningSM_acc_distance)
									   [| { share__, terminate } |] (
									   Go_up::VS_O__(id__,
									   		    const_PathPlanningSM_cliff,
									   		    const_PathPlanningSM_nozzle,
									   		    const_PathPlanningSM_battery_low,
									   		    const_PathPlanningSM_sleep_time,
									   		    const_PathPlanningSM_acc_distance)
									   [| { share__, terminate } |] (
									   Go_right::VS_O__(id__,
									   		    const_PathPlanningSM_cliff,
									   		    const_PathPlanningSM_nozzle,
									   		    const_PathPlanningSM_battery_low,
									   		    const_PathPlanningSM_sleep_time,
									   		    const_PathPlanningSM_acc_distance)
									   [| { share__, terminate } |] (
									   Go_down::VS_O__(id__,
									   		    const_PathPlanningSM_cliff,
									   		    const_PathPlanningSM_nozzle,
									   		    const_PathPlanningSM_battery_low,
									   		    const_PathPlanningSM_sleep_time,
									   		    const_PathPlanningSM_acc_distance)
									   [| { share__, terminate } |] (
									   Go_right_again::VS_O__(id__,
									   		    const_PathPlanningSM_cliff,
									   		    const_PathPlanningSM_nozzle,
									   		    const_PathPlanningSM_battery_low,
									   		    const_PathPlanningSM_sleep_time,
									   		    const_PathPlanningSM_acc_distance)
									   [| { share__, terminate } |] (
									   Return::VS_O__(id__,
									   		    const_PathPlanningSM_cliff,
									   		    const_PathPlanningSM_nozzle,
									   		    const_PathPlanningSM_battery_low,
									   		    const_PathPlanningSM_sleep_time,
									   		    const_PathPlanningSM_acc_distance)
									   [| { share__, terminate } |] (
									   Dock::VS_O__(id__,
									   		    const_PathPlanningSM_cliff,
									   		    const_PathPlanningSM_nozzle,
									   		    const_PathPlanningSM_battery_low,
									   		    const_PathPlanningSM_sleep_time,
									   		    const_PathPlanningSM_acc_distance)
									   [| { share__, terminate } |] (
									   Sleep::VS_O__(id__,
									   		    const_PathPlanningSM_cliff,
									   		    const_PathPlanningSM_nozzle,
									   		    const_PathPlanningSM_battery_low,
									   		    const_PathPlanningSM_sleep_time,
									   		    const_PathPlanningSM_acc_distance)
									   [| { share__, terminate } |] (
									   Check_end::VS_O__(id__,
									   		    const_PathPlanningSM_cliff,
									   		    const_PathPlanningSM_nozzle,
									   		    const_PathPlanningSM_battery_low,
									   		    const_PathPlanningSM_sleep_time,
									   		    const_PathPlanningSM_acc_distance)
									   [| { share__, terminate } |] (
									   Check_battery::VS_O__(id__,
									   		    const_PathPlanningSM_cliff,
									   		    const_PathPlanningSM_nozzle,
									   		    const_PathPlanningSM_battery_low,
									   		    const_PathPlanningSM_sleep_time,
									   		    const_PathPlanningSM_acc_distance)
									   [| { share__, terminate } |] (
									   Resume::VS_O__(id__,
									   		    const_PathPlanningSM_cliff,
									   		    const_PathPlanningSM_nozzle,
									   		    const_PathPlanningSM_battery_low,
									   		    const_PathPlanningSM_sleep_time,
									   		    const_PathPlanningSM_acc_distance)
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									   )
									 )
									 [[Go_up::interrupt <- x__ | x__ <- {|interrupt,ultrasonic__.NID_Go_up.in|}]]
									 [[Go_right::interrupt <- x__ | x__ <- {|interrupt,displacement__.NID_Go_right.in,ultrasonic__.NID_Go_right.in|}]]
									 [[Go_down::interrupt <- x__ | x__ <- {|interrupt,ultrasonic__.NID_Go_down.in|}]]
									 [[Go_right_again::interrupt <- x__ | x__ <- {|interrupt,ultrasonic__.NID_Go_right_again.in,ultrasonic__.NID_Go_right_again.in|}]]
									 [[Return::interrupt <- x__ | x__ <- {|interrupt,ultrasonic__.NID_Return.in|}]]
									 [[Dock::interrupt <- x__ | x__ <- {|interrupt,charging__.NID_Dock.in|}]]
									 [[Sleep::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Sleep|}]]
									 [[Check_end::interrupt <- x__ | x__ <- {|interrupt,displacement__.NID_Check_end.in,displacement__.NID_Check_end.in|}]]
									 [[Check_battery::interrupt <- x__ | x__ <- {|interrupt,battery_level__.NID_Check_battery.in,battery_level__.NID_Check_battery.in|}]]
									 [[Resume::interrupt <- x__ | x__ <- {|interrupt,displacement__.NID_Resume.in|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_u,setR_b,setR_d |} ]] 
									  [[set_u <- setL_u,set_cycles <- setL_cycles,set_b <- setL_b,set_d <- setL_d]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_u
									 			,setL_cycles
									 			,setL_b
									 			,setL_d
									 			,setR_u
									 			 			,setR_b
									 			 			,setR_d
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_PathPlanningSM_cliff,
									 		    const_PathPlanningSM_nozzle,
									 		    const_PathPlanningSM_battery_low,
									 		    const_PathPlanningSM_sleep_time,
									 		    const_PathPlanningSM_acc_distance))
									  [[ share__ <- x__ | x__ <- {| share__,setL_u,setL_cycles,setL_b,setL_d |} ]]
									  [[set_u <- setR_u,set_b <- setR_b,set_d <- setR_d]]
									 )
									)[[setL_u <- set_u,setL_cycles <- set_cycles,setL_b <- set_b,setL_d <- set_d]]
									 [[setR_u <- set_u,setR_b <- set_b,setR_d <- set_d]]
									)
								)
								 \ hideSet)
								[[
									move_forward__.x____ <- move_forward,
									turn__.x____ <- turn,
									stop__.x____ <- stop,
									ultrasonic__.x____ <- ultrasonic,
									battery_level__.x____ <- battery_level,
									charging__.x____ <- charging,
									clean__.x____ <- clean,
									displacement__.x____ <- displacement
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_PathPlanningSM_cliff,
							 		          const_PathPlanningSM_nozzle,
							 		          const_PathPlanningSM_battery_low,
							 		          const_PathPlanningSM_sleep_time,
							 		          const_PathPlanningSM_acc_distance)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
						dbisim((let
							stateClockSync = {|get_CLID_Go_right,Go_right::entered,get_CLID_Dock,Dock::entered,get_CLID_Go_down,Go_down::entered,get_CLID_Go_up,Go_up::entered,get_CLID_Check_end,Check_end::entered,get_CLID_Resume,Resume::entered,get_CLID_Check_battery,Check_battery::entered,get_CLID_Go_right_again,Go_right_again::entered,get_CLID_Sleep,Sleep::entered,get_CLID_Return,Return::entered|}
						 within
							(MachineBody_VS_O(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
						dbisim((let
							stateClockSync = {|get_CLID_Go_right,Go_right::entered,get_CLID_Dock,Dock::entered,get_CLID_Go_down,Go_down::entered,get_CLID_Go_up,Go_up::entered,get_CLID_Check_end,Check_end::entered,get_CLID_Resume,Resume::entered,get_CLID_Check_battery,Check_battery::entered,get_CLID_Go_right_again,Go_right_again::entered,get_CLID_Sleep,Sleep::entered,get_CLID_Return,Return::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															dbisim(
																sbisim(
																	dbisim(
																		sbisim(
																			dbisim(
																				sbisim(
																					dbisim(
																						sbisim(
																							dbisim(
																								sbisim(
																									dbisim(
																										sbisim(
																											MachineBody_VS_O(id__,
																													    const_PathPlanningSM_cliff,
																													    const_PathPlanningSM_nozzle,
																													    const_PathPlanningSM_battery_low,
																													    const_PathPlanningSM_sleep_time,
																													    const_PathPlanningSM_acc_distance)
																											[| {|get_CLID_Return,Return::entered,terminate|} |]
																											dbisim(Clock_CLID_Return(id__,0,
																													          const_PathPlanningSM_cliff,
																													          const_PathPlanningSM_nozzle,
																													          const_PathPlanningSM_battery_low,
																													          const_PathPlanningSM_sleep_time,
																													          const_PathPlanningSM_acc_distance))
																										)\{|get_CLID_Return|}
																									)
																									[| {|get_CLID_Sleep,Sleep::entered,terminate|} |]
																									dbisim(Clock_CLID_Sleep(id__,0,
																											          const_PathPlanningSM_cliff,
																											          const_PathPlanningSM_nozzle,
																											          const_PathPlanningSM_battery_low,
																											          const_PathPlanningSM_sleep_time,
																											          const_PathPlanningSM_acc_distance))
																								)\{|get_CLID_Sleep|}
																							)
																							[| {|get_CLID_Go_right_again,Go_right_again::entered,terminate|} |]
																							dbisim(Clock_CLID_Go_right_again(id__,0,
																									          const_PathPlanningSM_cliff,
																									          const_PathPlanningSM_nozzle,
																									          const_PathPlanningSM_battery_low,
																									          const_PathPlanningSM_sleep_time,
																									          const_PathPlanningSM_acc_distance))
																						)\{|get_CLID_Go_right_again|}
																					)
																					[| {|get_CLID_Check_battery,Check_battery::entered,terminate|} |]
																					dbisim(Clock_CLID_Check_battery(id__,0,
																							          const_PathPlanningSM_cliff,
																							          const_PathPlanningSM_nozzle,
																							          const_PathPlanningSM_battery_low,
																							          const_PathPlanningSM_sleep_time,
																							          const_PathPlanningSM_acc_distance))
																				)\{|get_CLID_Check_battery|}
																			)
																			[| {|get_CLID_Resume,Resume::entered,terminate|} |]
																			dbisim(Clock_CLID_Resume(id__,0,
																					          const_PathPlanningSM_cliff,
																					          const_PathPlanningSM_nozzle,
																					          const_PathPlanningSM_battery_low,
																					          const_PathPlanningSM_sleep_time,
																					          const_PathPlanningSM_acc_distance))
																		)\{|get_CLID_Resume|}
																	)
																	[| {|get_CLID_Check_end,Check_end::entered,terminate|} |]
																	dbisim(Clock_CLID_Check_end(id__,0,
																			          const_PathPlanningSM_cliff,
																			          const_PathPlanningSM_nozzle,
																			          const_PathPlanningSM_battery_low,
																			          const_PathPlanningSM_sleep_time,
																			          const_PathPlanningSM_acc_distance))
																)\{|get_CLID_Check_end|}
															)
															[| {|get_CLID_Go_up,Go_up::entered,terminate|} |]
															dbisim(Clock_CLID_Go_up(id__,0,
																	          const_PathPlanningSM_cliff,
																	          const_PathPlanningSM_nozzle,
																	          const_PathPlanningSM_battery_low,
																	          const_PathPlanningSM_sleep_time,
																	          const_PathPlanningSM_acc_distance))
														)\{|get_CLID_Go_up|}
													)
													[| {|get_CLID_Go_down,Go_down::entered,terminate|} |]
													dbisim(Clock_CLID_Go_down(id__,0,
															          const_PathPlanningSM_cliff,
															          const_PathPlanningSM_nozzle,
															          const_PathPlanningSM_battery_low,
															          const_PathPlanningSM_sleep_time,
															          const_PathPlanningSM_acc_distance))
												)\{|get_CLID_Go_down|}
											)
											[| {|get_CLID_Dock,Dock::entered,terminate|} |]
											dbisim(Clock_CLID_Dock(id__,0,
													          const_PathPlanningSM_cliff,
													          const_PathPlanningSM_nozzle,
													          const_PathPlanningSM_battery_low,
													          const_PathPlanningSM_sleep_time,
													          const_PathPlanningSM_acc_distance))
										)\{|get_CLID_Dock|}
									)
									[| {|get_CLID_Go_right,Go_right::entered,terminate|} |]
									dbisim(Clock_CLID_Go_right(id__,0,
											          const_PathPlanningSM_cliff,
											          const_PathPlanningSM_nozzle,
											          const_PathPlanningSM_battery_low,
											          const_PathPlanningSM_sleep_time,
											          const_PathPlanningSM_acc_distance))
								)\{|get_CLID_Go_right|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
						dbisim((let
							getsetLocalChannels = {|get_cycles,set_cycles,
							get_u,set_u,
							get_d,set_d,
							get_b,set_b|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_PathPlanningSM_cliff,
							 		    const_PathPlanningSM_nozzle,
							 		    const_PathPlanningSM_battery_low,
							 		    const_PathPlanningSM_sleep_time,
							 		    const_PathPlanningSM_acc_distance) [| {terminate} |] Clocks(id__,
							 		          const_PathPlanningSM_cliff,
							 		          const_PathPlanningSM_nozzle,
							 		          const_PathPlanningSM_battery_low,
							 		          const_PathPlanningSM_sleep_time,
							 		          const_PathPlanningSM_acc_distance))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														IteratedBehaviour_VS_O(id__,
																    const_PathPlanningSM_cliff,
																    const_PathPlanningSM_nozzle,
																    const_PathPlanningSM_battery_low,
																    const_PathPlanningSM_sleep_time,
																    const_PathPlanningSM_acc_distance)
														[| {|get_b,set_b,terminate|} |]
														Memory_b(0)
													)\{|get_b,set_b|}
												)
												[| {|get_d,set_d,terminate|} |]
												Memory_d(0)
											)\{|get_d,set_d|}
										)
										[| {|get_u,set_u,terminate|} |]
										Memory_u(0)
									)\{|get_u,set_u|}
								)
								[| {|get_cycles,set_cycles,terminate|} |]
								Memory_cycles(0)
							)\{|get_cycles,set_cycles|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_cycles(cycles) =
						get_cycles!cycles -> Memory_cycles(cycles)
						[]
						set_cycles?x__ -> Memory_cycles(x__)
						[]
						terminate -> SKIP
					Memory_u(u) =
						get_u!u -> Memory_u(u)
						[]
						set_u?x__ -> Memory_u(x__)
						[]
						terminate -> SKIP
					Memory_d(d) =
						get_d!d -> Memory_d(d)
						[]
						set_d?x__ -> Memory_d(x__)
						[]
						terminate -> SKIP
					Memory_b(b) =
						get_b!b -> Memory_b(b)
						[]
						set_b?x__ -> Memory_b(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = Memory_cycles(0)
					[| { terminate } |] (
					Memory_u(0)
					[| { terminate } |] (
					Memory_d(0)
					[| { terminate } |] (
					Memory_b(0)
					)
					)
					)
					
					getsetLocalChannels = {|get_cycles,set_cycles,get_u,set_u,get_d,set_d,get_b,set_b|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = STM_VS_O(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) \ localClockResets
					D__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = timed_priority(STM(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) \ union(internal_events,localClockResets))
					O__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = dbisim(D__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance))
					VS__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = FVS__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance)
					VS_O__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = dbisim(FVS__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance))
					HEXT__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = O__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) [|shared_variable_events|] SKIP
					FVS_C__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = dbisim(timed_priority(STM(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) \ internal_events))
					HUP__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = timed_priority(O__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__,
							          const_PathPlanningSM_cliff,
							          const_PathPlanningSM_nozzle,
							          const_PathPlanningSM_battery_low,
							          const_PathPlanningSM_sleep_time,
							          const_PathPlanningSM_acc_distance) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_Go_right(id__,x__,
							          const_PathPlanningSM_cliff,
							          const_PathPlanningSM_nozzle,
							          const_PathPlanningSM_battery_low,
							          const_PathPlanningSM_sleep_time,
							          const_PathPlanningSM_acc_distance) = 
						TimeOut_1(
							Go_right::entered -> Clock_CLID_Go_right(id__,0,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)
							[]
							get_CLID_Go_right!x__ -> Clock_CLID_Go_right(id__,x__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)
							[]
							terminate -> SKIP,Clock_CLID_Go_right(id__,clock_type_plus(x__,1,CLID_Go_right_clock_type(id__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)),
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance))
					Clock_CLID_Dock(id__,x__,
							          const_PathPlanningSM_cliff,
							          const_PathPlanningSM_nozzle,
							          const_PathPlanningSM_battery_low,
							          const_PathPlanningSM_sleep_time,
							          const_PathPlanningSM_acc_distance) = 
						TimeOut_1(
							Dock::entered -> Clock_CLID_Dock(id__,0,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)
							[]
							get_CLID_Dock!x__ -> Clock_CLID_Dock(id__,x__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)
							[]
							terminate -> SKIP,Clock_CLID_Dock(id__,clock_type_plus(x__,1,CLID_Dock_clock_type(id__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)),
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance))
					Clock_CLID_Go_down(id__,x__,
							          const_PathPlanningSM_cliff,
							          const_PathPlanningSM_nozzle,
							          const_PathPlanningSM_battery_low,
							          const_PathPlanningSM_sleep_time,
							          const_PathPlanningSM_acc_distance) = 
						TimeOut_1(
							Go_down::entered -> Clock_CLID_Go_down(id__,0,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)
							[]
							get_CLID_Go_down!x__ -> Clock_CLID_Go_down(id__,x__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)
							[]
							terminate -> SKIP,Clock_CLID_Go_down(id__,clock_type_plus(x__,1,CLID_Go_down_clock_type(id__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)),
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance))
					Clock_CLID_Go_up(id__,x__,
							          const_PathPlanningSM_cliff,
							          const_PathPlanningSM_nozzle,
							          const_PathPlanningSM_battery_low,
							          const_PathPlanningSM_sleep_time,
							          const_PathPlanningSM_acc_distance) = 
						TimeOut_1(
							Go_up::entered -> Clock_CLID_Go_up(id__,0,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)
							[]
							get_CLID_Go_up!x__ -> Clock_CLID_Go_up(id__,x__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)
							[]
							terminate -> SKIP,Clock_CLID_Go_up(id__,clock_type_plus(x__,1,CLID_Go_up_clock_type(id__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)),
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance))
					Clock_CLID_Check_end(id__,x__,
							          const_PathPlanningSM_cliff,
							          const_PathPlanningSM_nozzle,
							          const_PathPlanningSM_battery_low,
							          const_PathPlanningSM_sleep_time,
							          const_PathPlanningSM_acc_distance) = 
						TimeOut_1(
							Check_end::entered -> Clock_CLID_Check_end(id__,0,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)
							[]
							get_CLID_Check_end!x__ -> Clock_CLID_Check_end(id__,x__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)
							[]
							terminate -> SKIP,Clock_CLID_Check_end(id__,clock_type_plus(x__,1,CLID_Check_end_clock_type(id__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)),
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance))
					Clock_CLID_Resume(id__,x__,
							          const_PathPlanningSM_cliff,
							          const_PathPlanningSM_nozzle,
							          const_PathPlanningSM_battery_low,
							          const_PathPlanningSM_sleep_time,
							          const_PathPlanningSM_acc_distance) = 
						TimeOut_1(
							Resume::entered -> Clock_CLID_Resume(id__,0,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)
							[]
							get_CLID_Resume!x__ -> Clock_CLID_Resume(id__,x__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)
							[]
							terminate -> SKIP,Clock_CLID_Resume(id__,clock_type_plus(x__,1,CLID_Resume_clock_type(id__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)),
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance))
					Clock_CLID_Check_battery(id__,x__,
							          const_PathPlanningSM_cliff,
							          const_PathPlanningSM_nozzle,
							          const_PathPlanningSM_battery_low,
							          const_PathPlanningSM_sleep_time,
							          const_PathPlanningSM_acc_distance) = 
						TimeOut_1(
							Check_battery::entered -> Clock_CLID_Check_battery(id__,0,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)
							[]
							get_CLID_Check_battery!x__ -> Clock_CLID_Check_battery(id__,x__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)
							[]
							terminate -> SKIP,Clock_CLID_Check_battery(id__,clock_type_plus(x__,1,CLID_Check_battery_clock_type(id__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)),
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance))
					Clock_CLID_Go_right_again(id__,x__,
							          const_PathPlanningSM_cliff,
							          const_PathPlanningSM_nozzle,
							          const_PathPlanningSM_battery_low,
							          const_PathPlanningSM_sleep_time,
							          const_PathPlanningSM_acc_distance) = 
						TimeOut_1(
							Go_right_again::entered -> Clock_CLID_Go_right_again(id__,0,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)
							[]
							get_CLID_Go_right_again!x__ -> Clock_CLID_Go_right_again(id__,x__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)
							[]
							terminate -> SKIP,Clock_CLID_Go_right_again(id__,clock_type_plus(x__,1,CLID_Go_right_again_clock_type(id__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)),
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance))
					Clock_CLID_Sleep(id__,x__,
							          const_PathPlanningSM_cliff,
							          const_PathPlanningSM_nozzle,
							          const_PathPlanningSM_battery_low,
							          const_PathPlanningSM_sleep_time,
							          const_PathPlanningSM_acc_distance) = 
						TimeOut_1(
							Sleep::entered -> Clock_CLID_Sleep(id__,0,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)
							[]
							get_CLID_Sleep!x__ -> Clock_CLID_Sleep(id__,x__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)
							[]
							terminate -> SKIP,Clock_CLID_Sleep(id__,clock_type_plus(x__,1,CLID_Sleep_clock_type(id__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)),
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance))
					Clock_CLID_Return(id__,x__,
							          const_PathPlanningSM_cliff,
							          const_PathPlanningSM_nozzle,
							          const_PathPlanningSM_battery_low,
							          const_PathPlanningSM_sleep_time,
							          const_PathPlanningSM_acc_distance) = 
						TimeOut_1(
							Return::entered -> Clock_CLID_Return(id__,0,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)
							[]
							get_CLID_Return!x__ -> Clock_CLID_Return(id__,x__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)
							[]
							terminate -> SKIP,Clock_CLID_Return(id__,clock_type_plus(x__,1,CLID_Return_clock_type(id__,
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance)),
									          const_PathPlanningSM_cliff,
									          const_PathPlanningSM_nozzle,
									          const_PathPlanningSM_battery_low,
									          const_PathPlanningSM_sleep_time,
									          const_PathPlanningSM_acc_distance))
					
					StateClocks(id__,
							          const_PathPlanningSM_cliff,
							          const_PathPlanningSM_nozzle,
							          const_PathPlanningSM_battery_low,
							          const_PathPlanningSM_sleep_time,
							          const_PathPlanningSM_acc_distance) = dbisim(Clock_CLID_Go_right(id__,0,
							          const_PathPlanningSM_cliff,
							          const_PathPlanningSM_nozzle,
							          const_PathPlanningSM_battery_low,
							          const_PathPlanningSM_sleep_time,
							          const_PathPlanningSM_acc_distance))
					[| { terminate } |] (
					dbisim(Clock_CLID_Dock(id__,0,
							          const_PathPlanningSM_cliff,
							          const_PathPlanningSM_nozzle,
							          const_PathPlanningSM_battery_low,
							          const_PathPlanningSM_sleep_time,
							          const_PathPlanningSM_acc_distance))
					[| { terminate } |] (
					dbisim(Clock_CLID_Go_down(id__,0,
							          const_PathPlanningSM_cliff,
							          const_PathPlanningSM_nozzle,
							          const_PathPlanningSM_battery_low,
							          const_PathPlanningSM_sleep_time,
							          const_PathPlanningSM_acc_distance))
					[| { terminate } |] (
					dbisim(Clock_CLID_Go_up(id__,0,
							          const_PathPlanningSM_cliff,
							          const_PathPlanningSM_nozzle,
							          const_PathPlanningSM_battery_low,
							          const_PathPlanningSM_sleep_time,
							          const_PathPlanningSM_acc_distance))
					[| { terminate } |] (
					dbisim(Clock_CLID_Check_end(id__,0,
							          const_PathPlanningSM_cliff,
							          const_PathPlanningSM_nozzle,
							          const_PathPlanningSM_battery_low,
							          const_PathPlanningSM_sleep_time,
							          const_PathPlanningSM_acc_distance))
					[| { terminate } |] (
					dbisim(Clock_CLID_Resume(id__,0,
							          const_PathPlanningSM_cliff,
							          const_PathPlanningSM_nozzle,
							          const_PathPlanningSM_battery_low,
							          const_PathPlanningSM_sleep_time,
							          const_PathPlanningSM_acc_distance))
					[| { terminate } |] (
					dbisim(Clock_CLID_Check_battery(id__,0,
							          const_PathPlanningSM_cliff,
							          const_PathPlanningSM_nozzle,
							          const_PathPlanningSM_battery_low,
							          const_PathPlanningSM_sleep_time,
							          const_PathPlanningSM_acc_distance))
					[| { terminate } |] (
					dbisim(Clock_CLID_Go_right_again(id__,0,
							          const_PathPlanningSM_cliff,
							          const_PathPlanningSM_nozzle,
							          const_PathPlanningSM_battery_low,
							          const_PathPlanningSM_sleep_time,
							          const_PathPlanningSM_acc_distance))
					[| { terminate } |] (
					dbisim(Clock_CLID_Sleep(id__,0,
							          const_PathPlanningSM_cliff,
							          const_PathPlanningSM_nozzle,
							          const_PathPlanningSM_battery_low,
							          const_PathPlanningSM_sleep_time,
							          const_PathPlanningSM_acc_distance))
					[| { terminate } |] (
					dbisim(Clock_CLID_Return(id__,0,
							          const_PathPlanningSM_cliff,
							          const_PathPlanningSM_nozzle,
							          const_PathPlanningSM_battery_low,
							          const_PathPlanningSM_sleep_time,
							          const_PathPlanningSM_acc_distance))
					)
					)
					)
					)
					)
					)
					)
					)
					)
					
					stateClockSync = {|get_CLID_Go_right,Go_right::entered,get_CLID_Dock,Dock::entered,get_CLID_Go_down,Go_down::entered,get_CLID_Go_up,Go_up::entered,get_CLID_Check_end,Check_end::entered,get_CLID_Resume,Resume::entered,get_CLID_Check_battery,Check_battery::entered,get_CLID_Go_right_again,Go_right_again::entered,get_CLID_Sleep,Sleep::entered,get_CLID_Return,Return::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			module stm_ref1
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_wait_input|
				              NID_update_speed
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_acceleration, set_acceleration, setL_acceleration, setR_acceleration: TripleAxis
				channel get_speed, set_speed, setL_speed, setR_speed: TripleAxis
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel acc__: NIDS.InOut.TripleAxis
				channel acc: InOut.TripleAxis
				channel sp__: NIDS.InOut.TripleAxis
				channel sp: InOut.TripleAxis
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				wait_input::enter,
				update_speed::enter
				|}
				
				enteredSS = 	{|
				wait_input::entered,
				update_speed::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	acc,
					sp
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_wait_input : core_clock_type 
				channel get_CLID_update_speed : core_clock_type 
				--channel increment__
				
				CLID_wait_input_clock_type(id__,
						          const_SpeedSM_t) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_update_speed_clock_type(id__,
						          const_SpeedSM_t) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_SpeedSM_t) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
									    const_SpeedSM_t) = D__(id__,
									    const_SpeedSM_t)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: wait_input
					module wait_input
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_SpeedSM_t) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_SpeedSM_t) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_SpeedSM_t) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: update_speed
					module update_speed
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_SpeedSM_t) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_speed?speed -> share__choice(get_acceleration?acceleration -> true & (share__choice(set_speed!update_TripleAxis_X(speed,Plus(TripleAxis_X(speed), Mult(TripleAxis_X(acceleration), const_SpeedSM_t, core_int), core_int)) -> SKIP)))));share__choice(share__choice(get_speed?speed -> share__choice(get_acceleration?acceleration -> true & (share__choice(set_speed!update_TripleAxis_Y(speed,Plus(TripleAxis_Y(speed), Mult(TripleAxis_Y(acceleration), const_SpeedSM_t, core_int), core_int)) -> SKIP)))));share__choice(share__choice(get_speed?speed -> share__choice(get_acceleration?acceleration -> true & (share__choice(set_speed!update_TripleAxis_Z(speed,Plus(TripleAxis_Z(speed), Mult(TripleAxis_Z(acceleration), const_SpeedSM_t, core_int), core_int)) -> SKIP))))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_SpeedSM_t) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_speed?speed -> share__choice(get_acceleration?acceleration -> true & (share__choice(set_speed!update_TripleAxis_X(speed,Plus(TripleAxis_X(speed), Mult(TripleAxis_X(acceleration), const_SpeedSM_t, core_int), core_int)) -> SKIP)))));share__choice(share__choice(get_speed?speed -> share__choice(get_acceleration?acceleration -> true & (share__choice(set_speed!update_TripleAxis_Y(speed,Plus(TripleAxis_Y(speed), Mult(TripleAxis_Y(acceleration), const_SpeedSM_t, core_int), core_int)) -> SKIP)))));share__choice(share__choice(get_speed?speed -> share__choice(get_acceleration?acceleration -> true & (share__choice(set_speed!update_TripleAxis_Z(speed,Plus(TripleAxis_Z(speed), Mult(TripleAxis_Z(acceleration), const_SpeedSM_t, core_int), core_int)) -> SKIP))))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_SpeedSM_t) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
							    const_SpeedSM_t) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__,
										    const_SpeedSM_t) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_SpeedSM_t))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					STM_VS_O(id__,
							    const_SpeedSM_t) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__,
										    const_SpeedSM_t) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_SpeedSM_t))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					-- Transitions
					Transitions(id__,
							    const_SpeedSM_t) = ((let
						Trans = TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(acc__!NID_wait_input.in?acceleration:{acceleration|acceleration <- TripleAxis, true} -> share__choice(set_acceleration!acceleration -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; update_speed::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((share__choice(share__choice(get_speed?speed -> true & (share__choice(set_speed!update_TripleAxis_X(speed,0) -> SKIP))));share__choice(share__choice(get_speed?speed -> true & (share__choice(set_speed!update_TripleAxis_Y(speed,0) -> SKIP))));share__choice(share__choice(get_speed?speed -> true & (share__choice(set_speed!update_TripleAxis_Z(speed,0) -> SKIP)))) ; wait_input::enter -> SKIP))))
							 [] dbisim((true)&(internal__!NID_update_speed -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_speed?speed -> true&(share__choice(sp.out!speed -> SKIP)));SHARE_WAIT(const_SpeedSM_t) ; wait_input::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
							    const_SpeedSM_t) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								wait_input::enter,
								update_speed::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|acc__.NID_wait_input.in,internal__.NID_i0,internal__.NID_update_speed|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__,
									   		    const_SpeedSM_t)
									   [| { share__, terminate } |] (
									   wait_input::D__(id__,
									   		    const_SpeedSM_t)
									   [| { share__, terminate } |] (
									   update_speed::D__(id__,
									   		    const_SpeedSM_t)
									   )
									   )
									 )
									 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,acc__.NID_wait_input.in|}]]
									 [[update_speed::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_update_speed|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_acceleration |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setR_acceleration
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_SpeedSM_t))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									  [[set_acceleration <- setR_acceleration]]
									 )
									)
									 [[setR_acceleration <- set_acceleration]]
									)
								)
								 \ hideSet)
								[[
									acc__.x____ <- acc,
									sp__.x____ <- sp
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_SpeedSM_t)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
							    const_SpeedSM_t) = 
						dbisim((let
							stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_update_speed,update_speed::entered|}
						 within
							(MachineBody(id__,
									    const_SpeedSM_t) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_SpeedSM_t)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__,
							    const_SpeedSM_t) = 
						dbisim((let
							stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_update_speed,update_speed::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											MachineBody(id__,
													    const_SpeedSM_t)
											[| {|get_CLID_update_speed,update_speed::entered,terminate|} |]
											dbisim(Clock_CLID_update_speed(id__,0,
													          const_SpeedSM_t))
										)\{|get_CLID_update_speed|}
									)
									[| {|get_CLID_wait_input,wait_input::entered,terminate|} |]
									dbisim(Clock_CLID_wait_input(id__,0,
											          const_SpeedSM_t))
								)\{|get_CLID_wait_input|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__,
							    const_SpeedSM_t) = 
						((let
							getsetLocalChannels = {|get_acceleration,set_acceleration,
							get_speed,set_speed|}
							clockSync = {||}
						within
							(Behaviour(id__,
									    const_SpeedSM_t) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_SpeedSM_t) [| {terminate} |] Clocks(id__,
							 		          const_SpeedSM_t))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__,
							    const_SpeedSM_t) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										IteratedBehaviour(id__,
												    const_SpeedSM_t)
										[| {|get_speed,set_speed,terminate|} |]
										Memory_speed((0,0,0))
									)\{|get_speed,set_speed|}
								)
								[| {|get_acceleration,set_acceleration,terminate|} |]
								Memory_acceleration((0,0,0))
							)\{|get_acceleration,set_acceleration|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
							    const_SpeedSM_t) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								wait_input::enter,
								update_speed::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|acc__.NID_wait_input.in,internal__.NID_i0,internal__.NID_update_speed|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__,
									   		    const_SpeedSM_t)
									   [| { share__, terminate } |] (
									   wait_input::VS_O__(id__,
									   		    const_SpeedSM_t)
									   [| { share__, terminate } |] (
									   update_speed::VS_O__(id__,
									   		    const_SpeedSM_t)
									   )
									   )
									 )
									 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,acc__.NID_wait_input.in|}]]
									 [[update_speed::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_update_speed|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_acceleration |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setR_acceleration
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_SpeedSM_t))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									  [[set_acceleration <- setR_acceleration]]
									 )
									)
									 [[setR_acceleration <- set_acceleration]]
									)
								)
								 \ hideSet)
								[[
									acc__.x____ <- acc,
									sp__.x____ <- sp
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_SpeedSM_t)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
							    const_SpeedSM_t) = 
						dbisim((let
							stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_update_speed,update_speed::entered|}
						 within
							(MachineBody_VS_O(id__,
									    const_SpeedSM_t) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_SpeedSM_t)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__,
							    const_SpeedSM_t) = 
						dbisim((let
							stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_update_speed,update_speed::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											MachineBody_VS_O(id__,
													    const_SpeedSM_t)
											[| {|get_CLID_update_speed,update_speed::entered,terminate|} |]
											dbisim(Clock_CLID_update_speed(id__,0,
													          const_SpeedSM_t))
										)\{|get_CLID_update_speed|}
									)
									[| {|get_CLID_wait_input,wait_input::entered,terminate|} |]
									dbisim(Clock_CLID_wait_input(id__,0,
											          const_SpeedSM_t))
								)\{|get_CLID_wait_input|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__,
							    const_SpeedSM_t) = 
						dbisim((let
							getsetLocalChannels = {|get_acceleration,set_acceleration,
							get_speed,set_speed|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__,
									    const_SpeedSM_t) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_SpeedSM_t) [| {terminate} |] Clocks(id__,
							 		          const_SpeedSM_t))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__,
							    const_SpeedSM_t) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										IteratedBehaviour_VS_O(id__,
												    const_SpeedSM_t)
										[| {|get_speed,set_speed,terminate|} |]
										Memory_speed((0,0,0))
									)\{|get_speed,set_speed|}
								)
								[| {|get_acceleration,set_acceleration,terminate|} |]
								Memory_acceleration((0,0,0))
							)\{|get_acceleration,set_acceleration|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_acceleration(acceleration) =
						get_acceleration!acceleration -> Memory_acceleration(acceleration)
						[]
						set_acceleration?x__ -> Memory_acceleration(x__)
						[]
						terminate -> SKIP
					Memory_speed(speed) =
						get_speed!speed -> Memory_speed(speed)
						[]
						set_speed?x__ -> Memory_speed(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__,
							    const_SpeedSM_t) = Memory_acceleration((0,0,0))
					[| { terminate } |] (
					Memory_speed((0,0,0))
					)
					
					getsetLocalChannels = {|get_acceleration,set_acceleration,get_speed,set_speed|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
							    const_SpeedSM_t) = STM_VS_O(id__,
							    const_SpeedSM_t) \ localClockResets
					D__(id__,
							    const_SpeedSM_t) = timed_priority(STM(id__,
							    const_SpeedSM_t) \ union(internal_events,localClockResets))
					O__(id__,
							    const_SpeedSM_t) = dbisim(D__(id__,
							    const_SpeedSM_t))
					VS__(id__,
							    const_SpeedSM_t) = FVS__(id__,
							    const_SpeedSM_t)
					VS_O__(id__,
							    const_SpeedSM_t) = dbisim(FVS__(id__,
							    const_SpeedSM_t))
					HEXT__(id__,
							    const_SpeedSM_t) = O__(id__,
							    const_SpeedSM_t) [|shared_variable_events|] SKIP
					FVS_C__(id__,
							    const_SpeedSM_t) = dbisim(timed_priority(STM(id__,
							    const_SpeedSM_t) \ internal_events))
					HUP__(id__,
							    const_SpeedSM_t) = timed_priority(O__(id__,
							    const_SpeedSM_t) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__,
							          const_SpeedSM_t) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_wait_input(id__,x__,
							          const_SpeedSM_t) = 
						TimeOut_1(
							wait_input::entered -> Clock_CLID_wait_input(id__,0,
									          const_SpeedSM_t)
							[]
							get_CLID_wait_input!x__ -> Clock_CLID_wait_input(id__,x__,
									          const_SpeedSM_t)
							[]
							terminate -> SKIP,Clock_CLID_wait_input(id__,clock_type_plus(x__,1,CLID_wait_input_clock_type(id__,
									          const_SpeedSM_t)),
									          const_SpeedSM_t))
					Clock_CLID_update_speed(id__,x__,
							          const_SpeedSM_t) = 
						TimeOut_1(
							update_speed::entered -> Clock_CLID_update_speed(id__,0,
									          const_SpeedSM_t)
							[]
							get_CLID_update_speed!x__ -> Clock_CLID_update_speed(id__,x__,
									          const_SpeedSM_t)
							[]
							terminate -> SKIP,Clock_CLID_update_speed(id__,clock_type_plus(x__,1,CLID_update_speed_clock_type(id__,
									          const_SpeedSM_t)),
									          const_SpeedSM_t))
					
					StateClocks(id__,
							          const_SpeedSM_t) = dbisim(Clock_CLID_wait_input(id__,0,
							          const_SpeedSM_t))
					[| { terminate } |] (
					dbisim(Clock_CLID_update_speed(id__,0,
							          const_SpeedSM_t))
					)
					
					stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_update_speed,update_speed::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__,
							    const_SpeedSM_t) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			module stm_ref2
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_wait_input|
				              NID_update_speed
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_acceleration, set_acceleration, setL_acceleration, setR_acceleration: TripleAxis
				channel get_speed, set_speed, setL_speed, setR_speed: TripleAxis
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel acc__: NIDS.InOut.TripleAxis
				channel acc: InOut.TripleAxis
				channel sp__: NIDS.InOut.TripleAxis
				channel sp: InOut.TripleAxis
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				wait_input::enter,
				update_speed::enter
				|}
				
				enteredSS = 	{|
				wait_input::entered,
				update_speed::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	acc,
					sp
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_wait_input : core_clock_type 
				channel get_CLID_update_speed : core_clock_type 
				--channel increment__
				
				CLID_wait_input_clock_type(id__,
						          const_SpeedSM_t) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_update_speed_clock_type(id__,
						          const_SpeedSM_t) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_SpeedSM_t) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
									    const_SpeedSM_t) = D__(id__,
									    const_SpeedSM_t)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: wait_input
					module wait_input
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_SpeedSM_t) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_SpeedSM_t) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_SpeedSM_t) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: update_speed
					module update_speed
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_SpeedSM_t) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_speed?speed -> share__choice(get_acceleration?acceleration -> true & (share__choice(set_speed!update_TripleAxis_X(speed,Plus(TripleAxis_X(speed), Mult(TripleAxis_X(acceleration), const_SpeedSM_t, core_int), core_int)) -> SKIP)))));share__choice(share__choice(get_speed?speed -> share__choice(get_acceleration?acceleration -> true & (share__choice(set_speed!update_TripleAxis_Y(speed,Plus(TripleAxis_Y(speed), Mult(TripleAxis_Y(acceleration), const_SpeedSM_t, core_int), core_int)) -> SKIP)))));share__choice(share__choice(get_speed?speed -> share__choice(get_acceleration?acceleration -> true & (share__choice(set_speed!update_TripleAxis_Z(speed,Plus(TripleAxis_Z(speed), Mult(TripleAxis_Z(acceleration), const_SpeedSM_t, core_int), core_int)) -> SKIP))))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_SpeedSM_t) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_speed?speed -> share__choice(get_acceleration?acceleration -> true & (share__choice(set_speed!update_TripleAxis_X(speed,Plus(TripleAxis_X(speed), Mult(TripleAxis_X(acceleration), const_SpeedSM_t, core_int), core_int)) -> SKIP)))));share__choice(share__choice(get_speed?speed -> share__choice(get_acceleration?acceleration -> true & (share__choice(set_speed!update_TripleAxis_Y(speed,Plus(TripleAxis_Y(speed), Mult(TripleAxis_Y(acceleration), const_SpeedSM_t, core_int), core_int)) -> SKIP)))));share__choice(share__choice(get_speed?speed -> share__choice(get_acceleration?acceleration -> true & (share__choice(set_speed!update_TripleAxis_Z(speed,Plus(TripleAxis_Z(speed), Mult(TripleAxis_Z(acceleration), const_SpeedSM_t, core_int), core_int)) -> SKIP))))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_SpeedSM_t) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
							    const_SpeedSM_t) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__,
										    const_SpeedSM_t) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_SpeedSM_t))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					STM_VS_O(id__,
							    const_SpeedSM_t) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__,
										    const_SpeedSM_t) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_SpeedSM_t))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					-- Transitions
					Transitions(id__,
							    const_SpeedSM_t) = ((let
						Trans = TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(acc__!NID_wait_input.in?acceleration:{acceleration|acceleration <- TripleAxis, true} -> share__choice(set_acceleration!acceleration -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; update_speed::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((share__choice(share__choice(get_speed?speed -> true & (share__choice(set_speed!update_TripleAxis_X(speed,0) -> SKIP))));share__choice(share__choice(get_speed?speed -> true & (share__choice(set_speed!update_TripleAxis_Y(speed,0) -> SKIP))));share__choice(share__choice(get_speed?speed -> true & (share__choice(set_speed!update_TripleAxis_Z(speed,0) -> SKIP)))) ; wait_input::enter -> SKIP))))
							 [] dbisim((true)&(internal__!NID_update_speed -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_speed?speed -> true&(share__choice(sp.out!speed -> SKIP)));SHARE_WAIT(const_SpeedSM_t) ; wait_input::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
							    const_SpeedSM_t) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								wait_input::enter,
								update_speed::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|acc__.NID_wait_input.in,internal__.NID_i0,internal__.NID_update_speed|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__,
									   		    const_SpeedSM_t)
									   [| { share__, terminate } |] (
									   wait_input::D__(id__,
									   		    const_SpeedSM_t)
									   [| { share__, terminate } |] (
									   update_speed::D__(id__,
									   		    const_SpeedSM_t)
									   )
									   )
									 )
									 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,acc__.NID_wait_input.in|}]]
									 [[update_speed::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_update_speed|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_acceleration |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setR_acceleration
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_SpeedSM_t))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									  [[set_acceleration <- setR_acceleration]]
									 )
									)
									 [[setR_acceleration <- set_acceleration]]
									)
								)
								 \ hideSet)
								[[
									acc__.x____ <- acc,
									sp__.x____ <- sp
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_SpeedSM_t)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
							    const_SpeedSM_t) = 
						dbisim((let
							stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_update_speed,update_speed::entered|}
						 within
							(MachineBody(id__,
									    const_SpeedSM_t) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_SpeedSM_t)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__,
							    const_SpeedSM_t) = 
						dbisim((let
							stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_update_speed,update_speed::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											MachineBody(id__,
													    const_SpeedSM_t)
											[| {|get_CLID_update_speed,update_speed::entered,terminate|} |]
											dbisim(Clock_CLID_update_speed(id__,0,
													          const_SpeedSM_t))
										)\{|get_CLID_update_speed|}
									)
									[| {|get_CLID_wait_input,wait_input::entered,terminate|} |]
									dbisim(Clock_CLID_wait_input(id__,0,
											          const_SpeedSM_t))
								)\{|get_CLID_wait_input|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__,
							    const_SpeedSM_t) = 
						((let
							getsetLocalChannels = {|get_acceleration,set_acceleration,
							get_speed,set_speed|}
							clockSync = {||}
						within
							(Behaviour(id__,
									    const_SpeedSM_t) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_SpeedSM_t) [| {terminate} |] Clocks(id__,
							 		          const_SpeedSM_t))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__,
							    const_SpeedSM_t) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										IteratedBehaviour(id__,
												    const_SpeedSM_t)
										[| {|get_speed,set_speed,terminate|} |]
										Memory_speed((0,0,0))
									)\{|get_speed,set_speed|}
								)
								[| {|get_acceleration,set_acceleration,terminate|} |]
								Memory_acceleration((0,0,0))
							)\{|get_acceleration,set_acceleration|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
							    const_SpeedSM_t) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								wait_input::enter,
								update_speed::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|acc__.NID_wait_input.in,internal__.NID_i0,internal__.NID_update_speed|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__,
									   		    const_SpeedSM_t)
									   [| { share__, terminate } |] (
									   wait_input::VS_O__(id__,
									   		    const_SpeedSM_t)
									   [| { share__, terminate } |] (
									   update_speed::VS_O__(id__,
									   		    const_SpeedSM_t)
									   )
									   )
									 )
									 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,acc__.NID_wait_input.in|}]]
									 [[update_speed::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_update_speed|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_acceleration |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setR_acceleration
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_SpeedSM_t))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									  [[set_acceleration <- setR_acceleration]]
									 )
									)
									 [[setR_acceleration <- set_acceleration]]
									)
								)
								 \ hideSet)
								[[
									acc__.x____ <- acc,
									sp__.x____ <- sp
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_SpeedSM_t)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
							    const_SpeedSM_t) = 
						dbisim((let
							stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_update_speed,update_speed::entered|}
						 within
							(MachineBody_VS_O(id__,
									    const_SpeedSM_t) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_SpeedSM_t)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__,
							    const_SpeedSM_t) = 
						dbisim((let
							stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_update_speed,update_speed::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											MachineBody_VS_O(id__,
													    const_SpeedSM_t)
											[| {|get_CLID_update_speed,update_speed::entered,terminate|} |]
											dbisim(Clock_CLID_update_speed(id__,0,
													          const_SpeedSM_t))
										)\{|get_CLID_update_speed|}
									)
									[| {|get_CLID_wait_input,wait_input::entered,terminate|} |]
									dbisim(Clock_CLID_wait_input(id__,0,
											          const_SpeedSM_t))
								)\{|get_CLID_wait_input|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__,
							    const_SpeedSM_t) = 
						dbisim((let
							getsetLocalChannels = {|get_acceleration,set_acceleration,
							get_speed,set_speed|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__,
									    const_SpeedSM_t) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_SpeedSM_t) [| {terminate} |] Clocks(id__,
							 		          const_SpeedSM_t))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__,
							    const_SpeedSM_t) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										IteratedBehaviour_VS_O(id__,
												    const_SpeedSM_t)
										[| {|get_speed,set_speed,terminate|} |]
										Memory_speed((0,0,0))
									)\{|get_speed,set_speed|}
								)
								[| {|get_acceleration,set_acceleration,terminate|} |]
								Memory_acceleration((0,0,0))
							)\{|get_acceleration,set_acceleration|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_acceleration(acceleration) =
						get_acceleration!acceleration -> Memory_acceleration(acceleration)
						[]
						set_acceleration?x__ -> Memory_acceleration(x__)
						[]
						terminate -> SKIP
					Memory_speed(speed) =
						get_speed!speed -> Memory_speed(speed)
						[]
						set_speed?x__ -> Memory_speed(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__,
							    const_SpeedSM_t) = Memory_acceleration((0,0,0))
					[| { terminate } |] (
					Memory_speed((0,0,0))
					)
					
					getsetLocalChannels = {|get_acceleration,set_acceleration,get_speed,set_speed|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
							    const_SpeedSM_t) = STM_VS_O(id__,
							    const_SpeedSM_t) \ localClockResets
					D__(id__,
							    const_SpeedSM_t) = timed_priority(STM(id__,
							    const_SpeedSM_t) \ union(internal_events,localClockResets))
					O__(id__,
							    const_SpeedSM_t) = dbisim(D__(id__,
							    const_SpeedSM_t))
					VS__(id__,
							    const_SpeedSM_t) = FVS__(id__,
							    const_SpeedSM_t)
					VS_O__(id__,
							    const_SpeedSM_t) = dbisim(FVS__(id__,
							    const_SpeedSM_t))
					HEXT__(id__,
							    const_SpeedSM_t) = O__(id__,
							    const_SpeedSM_t) [|shared_variable_events|] SKIP
					FVS_C__(id__,
							    const_SpeedSM_t) = dbisim(timed_priority(STM(id__,
							    const_SpeedSM_t) \ internal_events))
					HUP__(id__,
							    const_SpeedSM_t) = timed_priority(O__(id__,
							    const_SpeedSM_t) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__,
							          const_SpeedSM_t) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_wait_input(id__,x__,
							          const_SpeedSM_t) = 
						TimeOut_1(
							wait_input::entered -> Clock_CLID_wait_input(id__,0,
									          const_SpeedSM_t)
							[]
							get_CLID_wait_input!x__ -> Clock_CLID_wait_input(id__,x__,
									          const_SpeedSM_t)
							[]
							terminate -> SKIP,Clock_CLID_wait_input(id__,clock_type_plus(x__,1,CLID_wait_input_clock_type(id__,
									          const_SpeedSM_t)),
									          const_SpeedSM_t))
					Clock_CLID_update_speed(id__,x__,
							          const_SpeedSM_t) = 
						TimeOut_1(
							update_speed::entered -> Clock_CLID_update_speed(id__,0,
									          const_SpeedSM_t)
							[]
							get_CLID_update_speed!x__ -> Clock_CLID_update_speed(id__,x__,
									          const_SpeedSM_t)
							[]
							terminate -> SKIP,Clock_CLID_update_speed(id__,clock_type_plus(x__,1,CLID_update_speed_clock_type(id__,
									          const_SpeedSM_t)),
									          const_SpeedSM_t))
					
					StateClocks(id__,
							          const_SpeedSM_t) = dbisim(Clock_CLID_wait_input(id__,0,
							          const_SpeedSM_t))
					[| { terminate } |] (
					dbisim(Clock_CLID_update_speed(id__,0,
							          const_SpeedSM_t))
					)
					
					stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_update_speed,update_speed::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__,
							    const_SpeedSM_t) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			module stm_ref3
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_wait_input|
				              NID_update_displacement|
				              NID_j0
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_d, set_d, setL_d, setR_d: core_int
				channel get_speed, set_speed, setL_speed, setR_speed: TripleAxis
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel sp__: NIDS.InOut.TripleAxis
				channel sp: InOut.TripleAxis
				channel displacement__: NIDS.InOut.core_int
				channel displacement: InOut.core_int
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				wait_input::enter,
				update_displacement::enter,
				j0::enter
				|}
				
				enteredSS = 	{|
				wait_input::entered,
				update_displacement::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	sp,
					displacement
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_update_displacement : core_clock_type 
				channel get_CLID_wait_input : core_clock_type 
				--channel increment__
				
				CLID_update_displacement_clock_type(id__,
						          const_DisplacementSM_t) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_wait_input_clock_type(id__,
						          const_DisplacementSM_t) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_DisplacementSM_t) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
									    const_DisplacementSM_t) = D__(id__,
									    const_DisplacementSM_t)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: wait_input
					module wait_input
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_DisplacementSM_t) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_DisplacementSM_t) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_DisplacementSM_t) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: update_displacement
					module update_displacement
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_DisplacementSM_t) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_d?d -> share__choice(get_speed?speed -> true & (share__choice(set_d!Plus(d, Mult(TripleAxis_X(speed), const_DisplacementSM_t, core_int), core_int) -> SKIP))))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_DisplacementSM_t) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_d?d -> share__choice(get_speed?speed -> true & (share__choice(set_d!Plus(d, Mult(TripleAxis_X(speed), const_DisplacementSM_t, core_int), core_int) -> SKIP))))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_DisplacementSM_t) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Junction: j0
					module j0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_DisplacementSM_t) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_DisplacementSM_t) = D__(id__,
									    const_DisplacementSM_t)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
							    const_DisplacementSM_t) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__,
										    const_DisplacementSM_t) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_DisplacementSM_t))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					STM_VS_O(id__,
							    const_DisplacementSM_t) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__,
										    const_DisplacementSM_t) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_DisplacementSM_t))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					-- Transitions
					Transitions(id__,
							    const_DisplacementSM_t) = ((let
						Trans = share__choice(get_d?d -> TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(sp__!NID_wait_input.in?speed:{speed|speed <- TripleAxis, true} -> share__choice(set_speed!speed -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; update_displacement::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_update_displacement -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_d?d -> true&(share__choice(displacement.out!d -> SKIP)));SHARE_WAIT(const_DisplacementSM_t) ; wait_input::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((share__choice(true & (share__choice(set_d!0 -> SKIP))) ; j0::enter -> SKIP))))
							 [] dbisim((true)&(internal__!NID_j0 -> SKIP ;  ((SKIP ; wait_input::enter -> SKIP))))
							 [] dbisim((displacement__!NID_wait_input.in?d:{d|d <- core_int, (d==0)} -> share__choice(set_d!d -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; j0::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
						)
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
							    const_DisplacementSM_t) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								wait_input::enter,
								update_displacement::enter,
								j0::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|sp__.NID_wait_input.in,internal__.NID_update_displacement,internal__.NID_i0,internal__.NID_j0,displacement__.NID_wait_input.in|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__,
									   		    const_DisplacementSM_t)
									   [| { share__, terminate } |] (
									   wait_input::D__(id__,
									   		    const_DisplacementSM_t)
									   [| { share__, terminate } |] (
									   update_displacement::D__(id__,
									   		    const_DisplacementSM_t)
									   [| { share__, terminate } |] (
									   j0::D__(id__,
									   		    const_DisplacementSM_t)
									   )
									   )
									   )
									 )
									 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,sp__.NID_wait_input.in,displacement__.NID_wait_input.in|}]]
									 [[update_displacement::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_update_displacement|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 [[j0::interrupt <- x__ | x__ <- {|internal__.NID_j0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_d,setR_speed |} ]] 
									  [[set_d <- setL_d]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_d
									 			,setR_d
									 			 			,setR_speed
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_DisplacementSM_t))
									  [[ share__ <- x__ | x__ <- {| share__,setL_d |} ]]
									  [[set_d <- setR_d,set_speed <- setR_speed]]
									 )
									)[[setL_d <- set_d]]
									 [[setR_d <- set_d,setR_speed <- set_speed]]
									)
								)
								 \ hideSet)
								[[
									sp__.x____ <- sp,
									displacement__.x____ <- displacement
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_DisplacementSM_t)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
							    const_DisplacementSM_t) = 
						dbisim((let
							stateClockSync = {|get_CLID_update_displacement,update_displacement::entered,get_CLID_wait_input,wait_input::entered|}
						 within
							(MachineBody(id__,
									    const_DisplacementSM_t) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_DisplacementSM_t)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__,
							    const_DisplacementSM_t) = 
						dbisim((let
							stateClockSync = {|get_CLID_update_displacement,update_displacement::entered,get_CLID_wait_input,wait_input::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											MachineBody(id__,
													    const_DisplacementSM_t)
											[| {|get_CLID_wait_input,wait_input::entered,terminate|} |]
											dbisim(Clock_CLID_wait_input(id__,0,
													          const_DisplacementSM_t))
										)\{|get_CLID_wait_input|}
									)
									[| {|get_CLID_update_displacement,update_displacement::entered,terminate|} |]
									dbisim(Clock_CLID_update_displacement(id__,0,
											          const_DisplacementSM_t))
								)\{|get_CLID_update_displacement|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__,
							    const_DisplacementSM_t) = 
						((let
							getsetLocalChannels = {|get_d,set_d,
							get_speed,set_speed|}
							clockSync = {||}
						within
							(Behaviour(id__,
									    const_DisplacementSM_t) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_DisplacementSM_t) [| {terminate} |] Clocks(id__,
							 		          const_DisplacementSM_t))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__,
							    const_DisplacementSM_t) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										IteratedBehaviour(id__,
												    const_DisplacementSM_t)
										[| {|get_speed,set_speed,terminate|} |]
										Memory_speed((0,0,0))
									)\{|get_speed,set_speed|}
								)
								[| {|get_d,set_d,terminate|} |]
								Memory_d(0)
							)\{|get_d,set_d|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
							    const_DisplacementSM_t) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								wait_input::enter,
								update_displacement::enter,
								j0::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|sp__.NID_wait_input.in,internal__.NID_update_displacement,internal__.NID_i0,internal__.NID_j0,displacement__.NID_wait_input.in|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__,
									   		    const_DisplacementSM_t)
									   [| { share__, terminate } |] (
									   wait_input::VS_O__(id__,
									   		    const_DisplacementSM_t)
									   [| { share__, terminate } |] (
									   update_displacement::VS_O__(id__,
									   		    const_DisplacementSM_t)
									   [| { share__, terminate } |] (
									   j0::VS_O__(id__,
									   		    const_DisplacementSM_t)
									   )
									   )
									   )
									 )
									 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,sp__.NID_wait_input.in,displacement__.NID_wait_input.in|}]]
									 [[update_displacement::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_update_displacement|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 [[j0::interrupt <- x__ | x__ <- {|internal__.NID_j0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_d,setR_speed |} ]] 
									  [[set_d <- setL_d]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_d
									 			,setR_d
									 			 			,setR_speed
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_DisplacementSM_t))
									  [[ share__ <- x__ | x__ <- {| share__,setL_d |} ]]
									  [[set_d <- setR_d,set_speed <- setR_speed]]
									 )
									)[[setL_d <- set_d]]
									 [[setR_d <- set_d,setR_speed <- set_speed]]
									)
								)
								 \ hideSet)
								[[
									sp__.x____ <- sp,
									displacement__.x____ <- displacement
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_DisplacementSM_t)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
							    const_DisplacementSM_t) = 
						dbisim((let
							stateClockSync = {|get_CLID_update_displacement,update_displacement::entered,get_CLID_wait_input,wait_input::entered|}
						 within
							(MachineBody_VS_O(id__,
									    const_DisplacementSM_t) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_DisplacementSM_t)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__,
							    const_DisplacementSM_t) = 
						dbisim((let
							stateClockSync = {|get_CLID_update_displacement,update_displacement::entered,get_CLID_wait_input,wait_input::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											MachineBody_VS_O(id__,
													    const_DisplacementSM_t)
											[| {|get_CLID_wait_input,wait_input::entered,terminate|} |]
											dbisim(Clock_CLID_wait_input(id__,0,
													          const_DisplacementSM_t))
										)\{|get_CLID_wait_input|}
									)
									[| {|get_CLID_update_displacement,update_displacement::entered,terminate|} |]
									dbisim(Clock_CLID_update_displacement(id__,0,
											          const_DisplacementSM_t))
								)\{|get_CLID_update_displacement|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__,
							    const_DisplacementSM_t) = 
						dbisim((let
							getsetLocalChannels = {|get_d,set_d,
							get_speed,set_speed|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__,
									    const_DisplacementSM_t) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_DisplacementSM_t) [| {terminate} |] Clocks(id__,
							 		          const_DisplacementSM_t))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__,
							    const_DisplacementSM_t) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										IteratedBehaviour_VS_O(id__,
												    const_DisplacementSM_t)
										[| {|get_speed,set_speed,terminate|} |]
										Memory_speed((0,0,0))
									)\{|get_speed,set_speed|}
								)
								[| {|get_d,set_d,terminate|} |]
								Memory_d(0)
							)\{|get_d,set_d|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_d(d) =
						get_d!d -> Memory_d(d)
						[]
						set_d?x__ -> Memory_d(x__)
						[]
						terminate -> SKIP
					Memory_speed(speed) =
						get_speed!speed -> Memory_speed(speed)
						[]
						set_speed?x__ -> Memory_speed(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__,
							    const_DisplacementSM_t) = Memory_d(0)
					[| { terminate } |] (
					Memory_speed((0,0,0))
					)
					
					getsetLocalChannels = {|get_d,set_d,get_speed,set_speed|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
							    const_DisplacementSM_t) = STM_VS_O(id__,
							    const_DisplacementSM_t) \ localClockResets
					D__(id__,
							    const_DisplacementSM_t) = timed_priority(STM(id__,
							    const_DisplacementSM_t) \ union(internal_events,localClockResets))
					O__(id__,
							    const_DisplacementSM_t) = dbisim(D__(id__,
							    const_DisplacementSM_t))
					VS__(id__,
							    const_DisplacementSM_t) = FVS__(id__,
							    const_DisplacementSM_t)
					VS_O__(id__,
							    const_DisplacementSM_t) = dbisim(FVS__(id__,
							    const_DisplacementSM_t))
					HEXT__(id__,
							    const_DisplacementSM_t) = O__(id__,
							    const_DisplacementSM_t) [|shared_variable_events|] SKIP
					FVS_C__(id__,
							    const_DisplacementSM_t) = dbisim(timed_priority(STM(id__,
							    const_DisplacementSM_t) \ internal_events))
					HUP__(id__,
							    const_DisplacementSM_t) = timed_priority(O__(id__,
							    const_DisplacementSM_t) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__,
							          const_DisplacementSM_t) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_update_displacement(id__,x__,
							          const_DisplacementSM_t) = 
						TimeOut_1(
							update_displacement::entered -> Clock_CLID_update_displacement(id__,0,
									          const_DisplacementSM_t)
							[]
							get_CLID_update_displacement!x__ -> Clock_CLID_update_displacement(id__,x__,
									          const_DisplacementSM_t)
							[]
							terminate -> SKIP,Clock_CLID_update_displacement(id__,clock_type_plus(x__,1,CLID_update_displacement_clock_type(id__,
									          const_DisplacementSM_t)),
									          const_DisplacementSM_t))
					Clock_CLID_wait_input(id__,x__,
							          const_DisplacementSM_t) = 
						TimeOut_1(
							wait_input::entered -> Clock_CLID_wait_input(id__,0,
									          const_DisplacementSM_t)
							[]
							get_CLID_wait_input!x__ -> Clock_CLID_wait_input(id__,x__,
									          const_DisplacementSM_t)
							[]
							terminate -> SKIP,Clock_CLID_wait_input(id__,clock_type_plus(x__,1,CLID_wait_input_clock_type(id__,
									          const_DisplacementSM_t)),
									          const_DisplacementSM_t))
					
					StateClocks(id__,
							          const_DisplacementSM_t) = dbisim(Clock_CLID_update_displacement(id__,0,
							          const_DisplacementSM_t))
					[| { terminate } |] (
					dbisim(Clock_CLID_wait_input(id__,0,
							          const_DisplacementSM_t))
					)
					
					stateClockSync = {|get_CLID_update_displacement,update_displacement::entered,get_CLID_wait_input,wait_input::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__,
							    const_DisplacementSM_t) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			module stm_ref4
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_clean|
				              NID_dont_clean
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_clean_var, set_clean_var, setL_clean_var, setR_clean_var: core_boolean
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel clean__: NIDS.InOut.core_boolean
				channel clean: InOut.core_boolean
				
				-- Declaring call and ret events for undefined operations
				channel vacuumCall: core_int
				channel brushCall: core_int
				
				enterSS = {|
				i0::enter,
				clean::enter,
				dont_clean::enter
				|}
				
				enteredSS = 	{|
				clean::entered,
				dont_clean::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	clean
				,	vacuumCall,
					brushCall
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_clean : core_clock_type 
				channel get_CLID_dont_clean : core_clock_type 
				--channel increment__
				
				CLID_clean_clock_type(id__,
						          const_CleanSM_voltage) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_dont_clean_clock_type(id__,
						          const_CleanSM_voltage) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_CleanSM_voltage) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
									    const_CleanSM_voltage) = D__(id__,
									    const_CleanSM_voltage)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: clean
					module clean
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_CleanSM_voltage) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&CALL__brush(
											id__,
										    const_CleanSM_voltage,
											const_CleanSM_voltage
										);true&CALL__vacuum(
											id__,
										    const_CleanSM_voltage,
											const_CleanSM_voltage
										) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_CleanSM_voltage) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&CALL__brush(
											id__,
										    const_CleanSM_voltage,
											const_CleanSM_voltage
										);true&CALL__vacuum(
											id__,
										    const_CleanSM_voltage,
											const_CleanSM_voltage
										) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_CleanSM_voltage) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: dont_clean
					module dont_clean
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_CleanSM_voltage) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&CALL__brush(
											id__,
										    const_CleanSM_voltage,
											0
										);true&CALL__vacuum(
											id__,
										    const_CleanSM_voltage,
											0
										) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_CleanSM_voltage) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&CALL__brush(
											id__,
										    const_CleanSM_voltage,
											0
										);true&CALL__vacuum(
											id__,
										    const_CleanSM_voltage,
											0
										) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_CleanSM_voltage) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					CALL__vacuum(id__,
							    const_CleanSM_voltage,
								param_x) = EDeadline(vacuumCall.param_x,0)
					CALL__brush(id__,
							    const_CleanSM_voltage,
								param_x) = EDeadline(brushCall.param_x,0)
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
							    const_CleanSM_voltage) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__,
										    const_CleanSM_voltage) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_CleanSM_voltage))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					STM_VS_O(id__,
							    const_CleanSM_voltage) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__,
										    const_CleanSM_voltage) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_CleanSM_voltage))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					-- Transitions
					Transitions(id__,
							    const_CleanSM_voltage) = ((let
						Trans = share__choice(get_clean_var?clean_var -> TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; dont_clean::enter -> SKIP))))
							 [] dbisim((clean__!NID_dont_clean.in?clean_var:{clean_var|clean_var <- core_boolean, (clean_var==true)} -> share__choice(set_clean_var!clean_var -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; clean::enter -> SKIP)))
							 [] dbisim((clean__!NID_clean.in?clean_var:{clean_var|clean_var <- core_boolean, (clean_var==false)} -> share__choice(set_clean_var!clean_var -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; dont_clean::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
						)
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
							    const_CleanSM_voltage) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								clean::enter,
								dont_clean::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,clean__.NID_dont_clean.in,clean__.NID_clean.in|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__,
									   		    const_CleanSM_voltage)
									   [| { share__, terminate } |] (
									   clean::D__(id__,
									   		    const_CleanSM_voltage)
									   [| { share__, terminate } |] (
									   dont_clean::D__(id__,
									   		    const_CleanSM_voltage)
									   )
									   )
									 )
									 [[clean::interrupt <- x__ | x__ <- {|interrupt,clean__.NID_clean.in|}]]
									 [[dont_clean::interrupt <- x__ | x__ <- {|interrupt,clean__.NID_dont_clean.in|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_clean_var |} ]] 
									  [[set_clean_var <- setL_clean_var]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_clean_var
									 			,setR_clean_var
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_CleanSM_voltage))
									  [[ share__ <- x__ | x__ <- {| share__,setL_clean_var |} ]]
									  [[set_clean_var <- setR_clean_var]]
									 )
									)[[setL_clean_var <- set_clean_var]]
									 [[setR_clean_var <- set_clean_var]]
									)
								)
								 \ hideSet)
								[[
									clean__.x____ <- clean
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_CleanSM_voltage)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
							    const_CleanSM_voltage) = 
						dbisim((let
							stateClockSync = {|get_CLID_clean,clean::entered,get_CLID_dont_clean,dont_clean::entered|}
						 within
							(MachineBody(id__,
									    const_CleanSM_voltage) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_CleanSM_voltage)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__,
							    const_CleanSM_voltage) = 
						dbisim((let
							stateClockSync = {|get_CLID_clean,clean::entered,get_CLID_dont_clean,dont_clean::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											MachineBody(id__,
													    const_CleanSM_voltage)
											[| {|get_CLID_dont_clean,dont_clean::entered,terminate|} |]
											dbisim(Clock_CLID_dont_clean(id__,0,
													          const_CleanSM_voltage))
										)\{|get_CLID_dont_clean|}
									)
									[| {|get_CLID_clean,clean::entered,terminate|} |]
									dbisim(Clock_CLID_clean(id__,0,
											          const_CleanSM_voltage))
								)\{|get_CLID_clean|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__,
							    const_CleanSM_voltage) = 
						((let
							getsetLocalChannels = {|get_clean_var,set_clean_var|}
							clockSync = {||}
						within
							(Behaviour(id__,
									    const_CleanSM_voltage) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_CleanSM_voltage) [| {terminate} |] Clocks(id__,
							 		          const_CleanSM_voltage))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__,
							    const_CleanSM_voltage) =
						(dbisim(
							sbisim(
								IteratedBehaviour(id__,
										    const_CleanSM_voltage)
								[| {|get_clean_var,set_clean_var,terminate|} |]
								Memory_clean_var(true)
							)\{|get_clean_var,set_clean_var|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
							    const_CleanSM_voltage) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								clean::enter,
								dont_clean::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,clean__.NID_dont_clean.in,clean__.NID_clean.in|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__,
									   		    const_CleanSM_voltage)
									   [| { share__, terminate } |] (
									   clean::VS_O__(id__,
									   		    const_CleanSM_voltage)
									   [| { share__, terminate } |] (
									   dont_clean::VS_O__(id__,
									   		    const_CleanSM_voltage)
									   )
									   )
									 )
									 [[clean::interrupt <- x__ | x__ <- {|interrupt,clean__.NID_clean.in|}]]
									 [[dont_clean::interrupt <- x__ | x__ <- {|interrupt,clean__.NID_dont_clean.in|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_clean_var |} ]] 
									  [[set_clean_var <- setL_clean_var]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_clean_var
									 			,setR_clean_var
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_CleanSM_voltage))
									  [[ share__ <- x__ | x__ <- {| share__,setL_clean_var |} ]]
									  [[set_clean_var <- setR_clean_var]]
									 )
									)[[setL_clean_var <- set_clean_var]]
									 [[setR_clean_var <- set_clean_var]]
									)
								)
								 \ hideSet)
								[[
									clean__.x____ <- clean
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_CleanSM_voltage)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
							    const_CleanSM_voltage) = 
						dbisim((let
							stateClockSync = {|get_CLID_clean,clean::entered,get_CLID_dont_clean,dont_clean::entered|}
						 within
							(MachineBody_VS_O(id__,
									    const_CleanSM_voltage) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_CleanSM_voltage)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__,
							    const_CleanSM_voltage) = 
						dbisim((let
							stateClockSync = {|get_CLID_clean,clean::entered,get_CLID_dont_clean,dont_clean::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											MachineBody_VS_O(id__,
													    const_CleanSM_voltage)
											[| {|get_CLID_dont_clean,dont_clean::entered,terminate|} |]
											dbisim(Clock_CLID_dont_clean(id__,0,
													          const_CleanSM_voltage))
										)\{|get_CLID_dont_clean|}
									)
									[| {|get_CLID_clean,clean::entered,terminate|} |]
									dbisim(Clock_CLID_clean(id__,0,
											          const_CleanSM_voltage))
								)\{|get_CLID_clean|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__,
							    const_CleanSM_voltage) = 
						dbisim((let
							getsetLocalChannels = {|get_clean_var,set_clean_var|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__,
									    const_CleanSM_voltage) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_CleanSM_voltage) [| {terminate} |] Clocks(id__,
							 		          const_CleanSM_voltage))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__,
							    const_CleanSM_voltage) =
						(dbisim(
							sbisim(
								IteratedBehaviour_VS_O(id__,
										    const_CleanSM_voltage)
								[| {|get_clean_var,set_clean_var,terminate|} |]
								Memory_clean_var(true)
							)\{|get_clean_var,set_clean_var|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_clean_var(clean_var) =
						get_clean_var!clean_var -> Memory_clean_var(clean_var)
						[]
						set_clean_var?x__ -> Memory_clean_var(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__,
							    const_CleanSM_voltage) = Memory_clean_var(true)
					
					getsetLocalChannels = {|get_clean_var,set_clean_var|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
							    const_CleanSM_voltage) = STM_VS_O(id__,
							    const_CleanSM_voltage) \ localClockResets
					D__(id__,
							    const_CleanSM_voltage) = timed_priority(STM(id__,
							    const_CleanSM_voltage) \ union(internal_events,localClockResets))
					O__(id__,
							    const_CleanSM_voltage) = dbisim(D__(id__,
							    const_CleanSM_voltage))
					VS__(id__,
							    const_CleanSM_voltage) = FVS__(id__,
							    const_CleanSM_voltage)
					VS_O__(id__,
							    const_CleanSM_voltage) = dbisim(FVS__(id__,
							    const_CleanSM_voltage))
					HEXT__(id__,
							    const_CleanSM_voltage) = O__(id__,
							    const_CleanSM_voltage) [|shared_variable_events|] SKIP
					FVS_C__(id__,
							    const_CleanSM_voltage) = dbisim(timed_priority(STM(id__,
							    const_CleanSM_voltage) \ internal_events))
					HUP__(id__,
							    const_CleanSM_voltage) = timed_priority(O__(id__,
							    const_CleanSM_voltage) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__,
							          const_CleanSM_voltage) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_clean(id__,x__,
							          const_CleanSM_voltage) = 
						TimeOut_1(
							clean::entered -> Clock_CLID_clean(id__,0,
									          const_CleanSM_voltage)
							[]
							get_CLID_clean!x__ -> Clock_CLID_clean(id__,x__,
									          const_CleanSM_voltage)
							[]
							terminate -> SKIP,Clock_CLID_clean(id__,clock_type_plus(x__,1,CLID_clean_clock_type(id__,
									          const_CleanSM_voltage)),
									          const_CleanSM_voltage))
					Clock_CLID_dont_clean(id__,x__,
							          const_CleanSM_voltage) = 
						TimeOut_1(
							dont_clean::entered -> Clock_CLID_dont_clean(id__,0,
									          const_CleanSM_voltage)
							[]
							get_CLID_dont_clean!x__ -> Clock_CLID_dont_clean(id__,x__,
									          const_CleanSM_voltage)
							[]
							terminate -> SKIP,Clock_CLID_dont_clean(id__,clock_type_plus(x__,1,CLID_dont_clean_clock_type(id__,
									          const_CleanSM_voltage)),
									          const_CleanSM_voltage))
					
					StateClocks(id__,
							          const_CleanSM_voltage) = dbisim(Clock_CLID_clean(id__,0,
							          const_CleanSM_voltage))
					[| { terminate } |] (
					dbisim(Clock_CLID_dont_clean(id__,0,
							          const_CleanSM_voltage))
					)
					
					stateClockSync = {|get_CLID_clean,clean::entered,get_CLID_dont_clean,dont_clean::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__,
							    const_CleanSM_voltage) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			module stm_ref5
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_wait_input|
				              NID_wait_ar|
				              NID_wait_al|
				              NID_update_value
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_speed, set_speed, setL_speed, setR_speed: core_int
				channel get_turn_angle, set_turn_angle, setL_turn_angle, setR_turn_angle: core_real
				channel get_direction, set_direction, setL_direction, setR_direction: Direction
				channel get_al, set_al, setL_al, setR_al: TripleAxis
				channel get_ar, set_ar, setL_ar, setR_ar: TripleAxis
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel acc_l__: NIDS.InOut.TripleAxis
				channel acc_l: InOut.TripleAxis
				channel acc_r__: NIDS.InOut.TripleAxis
				channel acc_r: InOut.TripleAxis
				channel angle__: NIDS.InOut.core_int
				channel angle: InOut.core_int
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				wait_input::enter,
				wait_ar::enter,
				wait_al::enter,
				update_value::enter
				|}
				
				enteredSS = 	{|
				wait_input::entered,
				wait_ar::entered,
				wait_al::entered,
				update_value::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	acc_l,
					acc_r,
					angle
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_wait_input : core_clock_type 
				channel get_CLID_update_value : core_clock_type 
				channel get_CLID_wait_al : core_clock_type 
				channel get_CLID_wait_ar : core_clock_type 
				--channel increment__
				
				CLID_wait_input_clock_type(id__,
						          const_AngularSpeedSM_t,
						          const_AngularSpeedSM_acc_distance) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_update_value_clock_type(id__,
						          const_AngularSpeedSM_t,
						          const_AngularSpeedSM_acc_distance) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_wait_al_clock_type(id__,
						          const_AngularSpeedSM_t,
						          const_AngularSpeedSM_acc_distance) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_wait_ar_clock_type(id__,
						          const_AngularSpeedSM_t,
						          const_AngularSpeedSM_acc_distance) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_AngularSpeedSM_t,
									    const_AngularSpeedSM_acc_distance) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
									    const_AngularSpeedSM_t,
									    const_AngularSpeedSM_acc_distance) = D__(id__,
									    const_AngularSpeedSM_t,
									    const_AngularSpeedSM_acc_distance)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: wait_input
					module wait_input
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_AngularSpeedSM_t,
									    const_AngularSpeedSM_acc_distance) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_AngularSpeedSM_t,
									    const_AngularSpeedSM_acc_distance) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_AngularSpeedSM_t,
									          const_AngularSpeedSM_acc_distance) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: wait_ar
					module wait_ar
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_AngularSpeedSM_t,
									    const_AngularSpeedSM_acc_distance) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_AngularSpeedSM_t,
									    const_AngularSpeedSM_acc_distance) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_AngularSpeedSM_t,
									          const_AngularSpeedSM_acc_distance) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: wait_al
					module wait_al
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_AngularSpeedSM_t,
									    const_AngularSpeedSM_acc_distance) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_AngularSpeedSM_t,
									    const_AngularSpeedSM_acc_distance) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_AngularSpeedSM_t,
									          const_AngularSpeedSM_acc_distance) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: update_value
					module update_value
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_AngularSpeedSM_t,
									    const_AngularSpeedSM_acc_distance) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_al?al -> share__choice(get_ar?ar -> share__choice(get_turn_angle?turn_angle -> true & (share__choice(set_turn_angle!Plus(turn_angle, Mult(sqrt(Div(abs(Minus(TripleAxis_Y(al), TripleAxis_Y(ar), core_int)), no_zero_div(const_AngularSpeedSM_acc_distance), core_real)), const_AngularSpeedSM_t, core_real), core_real) -> SKIP)))))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_AngularSpeedSM_t,
									    const_AngularSpeedSM_acc_distance) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_al?al -> share__choice(get_ar?ar -> share__choice(get_turn_angle?turn_angle -> true & (share__choice(set_turn_angle!Plus(turn_angle, Mult(sqrt(Div(abs(Minus(TripleAxis_Y(al), TripleAxis_Y(ar), core_int)), no_zero_div(const_AngularSpeedSM_acc_distance), core_real)), const_AngularSpeedSM_t, core_real), core_real) -> SKIP)))))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_AngularSpeedSM_t,
									          const_AngularSpeedSM_acc_distance) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__,
										    const_AngularSpeedSM_t,
										    const_AngularSpeedSM_acc_distance) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_AngularSpeedSM_t,
								    const_AngularSpeedSM_acc_distance))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					STM_VS_O(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__,
										    const_AngularSpeedSM_t,
										    const_AngularSpeedSM_acc_distance) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_AngularSpeedSM_t,
								    const_AngularSpeedSM_acc_distance))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					-- Transitions
					Transitions(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = ((let
						Trans = TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((share__choice(true & (share__choice(set_turn_angle!0 -> SKIP))) ; wait_input::enter -> SKIP))))
							 [] dbisim((true)&(acc_l__!NID_wait_input.in?al:{al|al <- TripleAxis, true} -> share__choice(set_al!al -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; wait_ar::enter -> SKIP)))
							 [] dbisim((true)&(acc_r__!NID_wait_input.in?ar:{ar|ar <- TripleAxis, true} -> share__choice(set_ar!ar -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; wait_al::enter -> SKIP)))
							 [] dbisim((true)&(acc_r__!NID_wait_ar.in?ar:{ar|ar <- TripleAxis, true} -> share__choice(set_ar!ar -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; update_value::enter -> SKIP)))
							 [] dbisim((true)&(acc_l__!NID_wait_al.in?al:{al|al <- TripleAxis, true} -> share__choice(set_al!al -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; update_value::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_update_value -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_al?al -> share__choice(get_turn_angle?turn_angle -> true&(share__choice(angle.out!(Mult(get_sign(TripleAxis_Y(al)), floor(turn_angle), core_int)) -> SKIP))));SHARE_WAIT(const_AngularSpeedSM_t) ; wait_input::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								wait_input::enter,
								wait_ar::enter,
								wait_al::enter,
								update_value::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,acc_l__.NID_wait_input.in,acc_r__.NID_wait_input.in,acc_r__.NID_wait_ar.in,acc_l__.NID_wait_al.in,internal__.NID_update_value|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__,
									   		    const_AngularSpeedSM_t,
									   		    const_AngularSpeedSM_acc_distance)
									   [| { share__, terminate } |] (
									   wait_input::D__(id__,
									   		    const_AngularSpeedSM_t,
									   		    const_AngularSpeedSM_acc_distance)
									   [| { share__, terminate } |] (
									   wait_ar::D__(id__,
									   		    const_AngularSpeedSM_t,
									   		    const_AngularSpeedSM_acc_distance)
									   [| { share__, terminate } |] (
									   wait_al::D__(id__,
									   		    const_AngularSpeedSM_t,
									   		    const_AngularSpeedSM_acc_distance)
									   [| { share__, terminate } |] (
									   update_value::D__(id__,
									   		    const_AngularSpeedSM_t,
									   		    const_AngularSpeedSM_acc_distance)
									   )
									   )
									   )
									   )
									 )
									 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,acc_l__.NID_wait_input.in,acc_r__.NID_wait_input.in|}]]
									 [[wait_ar::interrupt <- x__ | x__ <- {|interrupt,acc_r__.NID_wait_ar.in|}]]
									 [[wait_al::interrupt <- x__ | x__ <- {|interrupt,acc_l__.NID_wait_al.in|}]]
									 [[update_value::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_update_value|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_al,setR_ar |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setR_al
									 			 			,setR_ar
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_AngularSpeedSM_t,
									 		    const_AngularSpeedSM_acc_distance))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									  [[set_al <- setR_al,set_ar <- setR_ar]]
									 )
									)
									 [[setR_al <- set_al,setR_ar <- set_ar]]
									)
								)
								 \ hideSet)
								[[
									acc_l__.x____ <- acc_l,
									acc_r__.x____ <- acc_r,
									angle__.x____ <- angle
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_AngularSpeedSM_t,
							 		          const_AngularSpeedSM_acc_distance)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = 
						dbisim((let
							stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_update_value,update_value::entered,get_CLID_wait_al,wait_al::entered,get_CLID_wait_ar,wait_ar::entered|}
						 within
							(MachineBody(id__,
									    const_AngularSpeedSM_t,
									    const_AngularSpeedSM_acc_distance) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_AngularSpeedSM_t,
									          const_AngularSpeedSM_acc_distance)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = 
						dbisim((let
							stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_update_value,update_value::entered,get_CLID_wait_al,wait_al::entered,get_CLID_wait_ar,wait_ar::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															MachineBody(id__,
																	    const_AngularSpeedSM_t,
																	    const_AngularSpeedSM_acc_distance)
															[| {|get_CLID_wait_ar,wait_ar::entered,terminate|} |]
															dbisim(Clock_CLID_wait_ar(id__,0,
																	          const_AngularSpeedSM_t,
																	          const_AngularSpeedSM_acc_distance))
														)\{|get_CLID_wait_ar|}
													)
													[| {|get_CLID_wait_al,wait_al::entered,terminate|} |]
													dbisim(Clock_CLID_wait_al(id__,0,
															          const_AngularSpeedSM_t,
															          const_AngularSpeedSM_acc_distance))
												)\{|get_CLID_wait_al|}
											)
											[| {|get_CLID_update_value,update_value::entered,terminate|} |]
											dbisim(Clock_CLID_update_value(id__,0,
													          const_AngularSpeedSM_t,
													          const_AngularSpeedSM_acc_distance))
										)\{|get_CLID_update_value|}
									)
									[| {|get_CLID_wait_input,wait_input::entered,terminate|} |]
									dbisim(Clock_CLID_wait_input(id__,0,
											          const_AngularSpeedSM_t,
											          const_AngularSpeedSM_acc_distance))
								)\{|get_CLID_wait_input|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = 
						((let
							getsetLocalChannels = {|get_speed,set_speed,
							get_turn_angle,set_turn_angle,
							get_direction,set_direction,
							get_al,set_al,
							get_ar,set_ar|}
							clockSync = {||}
						within
							(Behaviour(id__,
									    const_AngularSpeedSM_t,
									    const_AngularSpeedSM_acc_distance) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_AngularSpeedSM_t,
							 		    const_AngularSpeedSM_acc_distance) [| {terminate} |] Clocks(id__,
							 		          const_AngularSpeedSM_t,
							 		          const_AngularSpeedSM_acc_distance))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																IteratedBehaviour(id__,
																		    const_AngularSpeedSM_t,
																		    const_AngularSpeedSM_acc_distance)
																[| {|get_ar,set_ar,terminate|} |]
																Memory_ar((0,0,0))
															)\{|get_ar,set_ar|}
														)
														[| {|get_al,set_al,terminate|} |]
														Memory_al((0,0,0))
													)\{|get_al,set_al|}
												)
												[| {|get_direction,set_direction,terminate|} |]
												Memory_direction(Direction_left)
											)\{|get_direction,set_direction|}
										)
										[| {|get_turn_angle,set_turn_angle,terminate|} |]
										Memory_turn_angle(0)
									)\{|get_turn_angle,set_turn_angle|}
								)
								[| {|get_speed,set_speed,terminate|} |]
								Memory_speed(0)
							)\{|get_speed,set_speed|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								wait_input::enter,
								wait_ar::enter,
								wait_al::enter,
								update_value::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,acc_l__.NID_wait_input.in,acc_r__.NID_wait_input.in,acc_r__.NID_wait_ar.in,acc_l__.NID_wait_al.in,internal__.NID_update_value|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__,
									   		    const_AngularSpeedSM_t,
									   		    const_AngularSpeedSM_acc_distance)
									   [| { share__, terminate } |] (
									   wait_input::VS_O__(id__,
									   		    const_AngularSpeedSM_t,
									   		    const_AngularSpeedSM_acc_distance)
									   [| { share__, terminate } |] (
									   wait_ar::VS_O__(id__,
									   		    const_AngularSpeedSM_t,
									   		    const_AngularSpeedSM_acc_distance)
									   [| { share__, terminate } |] (
									   wait_al::VS_O__(id__,
									   		    const_AngularSpeedSM_t,
									   		    const_AngularSpeedSM_acc_distance)
									   [| { share__, terminate } |] (
									   update_value::VS_O__(id__,
									   		    const_AngularSpeedSM_t,
									   		    const_AngularSpeedSM_acc_distance)
									   )
									   )
									   )
									   )
									 )
									 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,acc_l__.NID_wait_input.in,acc_r__.NID_wait_input.in|}]]
									 [[wait_ar::interrupt <- x__ | x__ <- {|interrupt,acc_r__.NID_wait_ar.in|}]]
									 [[wait_al::interrupt <- x__ | x__ <- {|interrupt,acc_l__.NID_wait_al.in|}]]
									 [[update_value::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_update_value|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_al,setR_ar |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setR_al
									 			 			,setR_ar
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_AngularSpeedSM_t,
									 		    const_AngularSpeedSM_acc_distance))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									  [[set_al <- setR_al,set_ar <- setR_ar]]
									 )
									)
									 [[setR_al <- set_al,setR_ar <- set_ar]]
									)
								)
								 \ hideSet)
								[[
									acc_l__.x____ <- acc_l,
									acc_r__.x____ <- acc_r,
									angle__.x____ <- angle
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_AngularSpeedSM_t,
							 		          const_AngularSpeedSM_acc_distance)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = 
						dbisim((let
							stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_update_value,update_value::entered,get_CLID_wait_al,wait_al::entered,get_CLID_wait_ar,wait_ar::entered|}
						 within
							(MachineBody_VS_O(id__,
									    const_AngularSpeedSM_t,
									    const_AngularSpeedSM_acc_distance) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_AngularSpeedSM_t,
									          const_AngularSpeedSM_acc_distance)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = 
						dbisim((let
							stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_update_value,update_value::entered,get_CLID_wait_al,wait_al::entered,get_CLID_wait_ar,wait_ar::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															MachineBody_VS_O(id__,
																	    const_AngularSpeedSM_t,
																	    const_AngularSpeedSM_acc_distance)
															[| {|get_CLID_wait_ar,wait_ar::entered,terminate|} |]
															dbisim(Clock_CLID_wait_ar(id__,0,
																	          const_AngularSpeedSM_t,
																	          const_AngularSpeedSM_acc_distance))
														)\{|get_CLID_wait_ar|}
													)
													[| {|get_CLID_wait_al,wait_al::entered,terminate|} |]
													dbisim(Clock_CLID_wait_al(id__,0,
															          const_AngularSpeedSM_t,
															          const_AngularSpeedSM_acc_distance))
												)\{|get_CLID_wait_al|}
											)
											[| {|get_CLID_update_value,update_value::entered,terminate|} |]
											dbisim(Clock_CLID_update_value(id__,0,
													          const_AngularSpeedSM_t,
													          const_AngularSpeedSM_acc_distance))
										)\{|get_CLID_update_value|}
									)
									[| {|get_CLID_wait_input,wait_input::entered,terminate|} |]
									dbisim(Clock_CLID_wait_input(id__,0,
											          const_AngularSpeedSM_t,
											          const_AngularSpeedSM_acc_distance))
								)\{|get_CLID_wait_input|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = 
						dbisim((let
							getsetLocalChannels = {|get_speed,set_speed,
							get_turn_angle,set_turn_angle,
							get_direction,set_direction,
							get_al,set_al,
							get_ar,set_ar|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__,
									    const_AngularSpeedSM_t,
									    const_AngularSpeedSM_acc_distance) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_AngularSpeedSM_t,
							 		    const_AngularSpeedSM_acc_distance) [| {terminate} |] Clocks(id__,
							 		          const_AngularSpeedSM_t,
							 		          const_AngularSpeedSM_acc_distance))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																IteratedBehaviour_VS_O(id__,
																		    const_AngularSpeedSM_t,
																		    const_AngularSpeedSM_acc_distance)
																[| {|get_ar,set_ar,terminate|} |]
																Memory_ar((0,0,0))
															)\{|get_ar,set_ar|}
														)
														[| {|get_al,set_al,terminate|} |]
														Memory_al((0,0,0))
													)\{|get_al,set_al|}
												)
												[| {|get_direction,set_direction,terminate|} |]
												Memory_direction(Direction_left)
											)\{|get_direction,set_direction|}
										)
										[| {|get_turn_angle,set_turn_angle,terminate|} |]
										Memory_turn_angle(0)
									)\{|get_turn_angle,set_turn_angle|}
								)
								[| {|get_speed,set_speed,terminate|} |]
								Memory_speed(0)
							)\{|get_speed,set_speed|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_speed(speed) =
						get_speed!speed -> Memory_speed(speed)
						[]
						set_speed?x__ -> Memory_speed(x__)
						[]
						terminate -> SKIP
					Memory_turn_angle(turn_angle) =
						get_turn_angle!turn_angle -> Memory_turn_angle(turn_angle)
						[]
						set_turn_angle?x__ -> Memory_turn_angle(x__)
						[]
						terminate -> SKIP
					Memory_direction(direction) =
						get_direction!direction -> Memory_direction(direction)
						[]
						set_direction?x__ -> Memory_direction(x__)
						[]
						terminate -> SKIP
					Memory_al(al) =
						get_al!al -> Memory_al(al)
						[]
						set_al?x__ -> Memory_al(x__)
						[]
						terminate -> SKIP
					Memory_ar(ar) =
						get_ar!ar -> Memory_ar(ar)
						[]
						set_ar?x__ -> Memory_ar(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = Memory_speed(0)
					[| { terminate } |] (
					Memory_turn_angle(0)
					[| { terminate } |] (
					Memory_direction(Direction_left)
					[| { terminate } |] (
					Memory_al((0,0,0))
					[| { terminate } |] (
					Memory_ar((0,0,0))
					)
					)
					)
					)
					
					getsetLocalChannels = {|get_speed,set_speed,get_turn_angle,set_turn_angle,get_direction,set_direction,get_al,set_al,get_ar,set_ar|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = STM_VS_O(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) \ localClockResets
					D__(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = timed_priority(STM(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) \ union(internal_events,localClockResets))
					O__(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = dbisim(D__(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance))
					VS__(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = FVS__(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance)
					VS_O__(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = dbisim(FVS__(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance))
					HEXT__(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = O__(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) [|shared_variable_events|] SKIP
					FVS_C__(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = dbisim(timed_priority(STM(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) \ internal_events))
					HUP__(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = timed_priority(O__(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__,
							          const_AngularSpeedSM_t,
							          const_AngularSpeedSM_acc_distance) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_wait_input(id__,x__,
							          const_AngularSpeedSM_t,
							          const_AngularSpeedSM_acc_distance) = 
						TimeOut_1(
							wait_input::entered -> Clock_CLID_wait_input(id__,0,
									          const_AngularSpeedSM_t,
									          const_AngularSpeedSM_acc_distance)
							[]
							get_CLID_wait_input!x__ -> Clock_CLID_wait_input(id__,x__,
									          const_AngularSpeedSM_t,
									          const_AngularSpeedSM_acc_distance)
							[]
							terminate -> SKIP,Clock_CLID_wait_input(id__,clock_type_plus(x__,1,CLID_wait_input_clock_type(id__,
									          const_AngularSpeedSM_t,
									          const_AngularSpeedSM_acc_distance)),
									          const_AngularSpeedSM_t,
									          const_AngularSpeedSM_acc_distance))
					Clock_CLID_update_value(id__,x__,
							          const_AngularSpeedSM_t,
							          const_AngularSpeedSM_acc_distance) = 
						TimeOut_1(
							update_value::entered -> Clock_CLID_update_value(id__,0,
									          const_AngularSpeedSM_t,
									          const_AngularSpeedSM_acc_distance)
							[]
							get_CLID_update_value!x__ -> Clock_CLID_update_value(id__,x__,
									          const_AngularSpeedSM_t,
									          const_AngularSpeedSM_acc_distance)
							[]
							terminate -> SKIP,Clock_CLID_update_value(id__,clock_type_plus(x__,1,CLID_update_value_clock_type(id__,
									          const_AngularSpeedSM_t,
									          const_AngularSpeedSM_acc_distance)),
									          const_AngularSpeedSM_t,
									          const_AngularSpeedSM_acc_distance))
					Clock_CLID_wait_al(id__,x__,
							          const_AngularSpeedSM_t,
							          const_AngularSpeedSM_acc_distance) = 
						TimeOut_1(
							wait_al::entered -> Clock_CLID_wait_al(id__,0,
									          const_AngularSpeedSM_t,
									          const_AngularSpeedSM_acc_distance)
							[]
							get_CLID_wait_al!x__ -> Clock_CLID_wait_al(id__,x__,
									          const_AngularSpeedSM_t,
									          const_AngularSpeedSM_acc_distance)
							[]
							terminate -> SKIP,Clock_CLID_wait_al(id__,clock_type_plus(x__,1,CLID_wait_al_clock_type(id__,
									          const_AngularSpeedSM_t,
									          const_AngularSpeedSM_acc_distance)),
									          const_AngularSpeedSM_t,
									          const_AngularSpeedSM_acc_distance))
					Clock_CLID_wait_ar(id__,x__,
							          const_AngularSpeedSM_t,
							          const_AngularSpeedSM_acc_distance) = 
						TimeOut_1(
							wait_ar::entered -> Clock_CLID_wait_ar(id__,0,
									          const_AngularSpeedSM_t,
									          const_AngularSpeedSM_acc_distance)
							[]
							get_CLID_wait_ar!x__ -> Clock_CLID_wait_ar(id__,x__,
									          const_AngularSpeedSM_t,
									          const_AngularSpeedSM_acc_distance)
							[]
							terminate -> SKIP,Clock_CLID_wait_ar(id__,clock_type_plus(x__,1,CLID_wait_ar_clock_type(id__,
									          const_AngularSpeedSM_t,
									          const_AngularSpeedSM_acc_distance)),
									          const_AngularSpeedSM_t,
									          const_AngularSpeedSM_acc_distance))
					
					StateClocks(id__,
							          const_AngularSpeedSM_t,
							          const_AngularSpeedSM_acc_distance) = dbisim(Clock_CLID_wait_input(id__,0,
							          const_AngularSpeedSM_t,
							          const_AngularSpeedSM_acc_distance))
					[| { terminate } |] (
					dbisim(Clock_CLID_update_value(id__,0,
							          const_AngularSpeedSM_t,
							          const_AngularSpeedSM_acc_distance))
					[| { terminate } |] (
					dbisim(Clock_CLID_wait_al(id__,0,
							          const_AngularSpeedSM_t,
							          const_AngularSpeedSM_acc_distance))
					[| { terminate } |] (
					dbisim(Clock_CLID_wait_ar(id__,0,
							          const_AngularSpeedSM_t,
							          const_AngularSpeedSM_acc_distance))
					)
					)
					)
					
					stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_update_value,update_value::entered,get_CLID_wait_al,wait_al::entered,get_CLID_wait_ar,wait_ar::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			module stm_ref6
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_Update|
				              NID_Wait_target|
				              NID_Wait_actual|
				              NID_Reset
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_prior_error, set_prior_error, setL_prior_error, setR_prior_error: core_int
				channel get_integral, set_integral, setL_integral, setR_integral: core_int
				channel get_error, set_error, setL_error, setR_error: core_int
				channel get_derivative, set_derivative, setL_derivative, setR_derivative: core_int
				channel get_output, set_output, setL_output, setR_output: core_int
				channel get_target_value, set_target_value, setL_target_value, setR_target_value: core_int
				channel get_actual_value, set_actual_value, setL_actual_value, setR_actual_value: core_int
				channel get_old_target, set_old_target, setL_old_target, setR_old_target: core_int
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel err_output__: NIDS.InOut.core_int
				channel err_output: InOut.core_int
				channel actual__: NIDS.InOut.core_int
				channel actual: InOut.core_int
				channel target__: NIDS.InOut.core_int
				channel target: InOut.core_int
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				Update::enter,
				Wait_target::enter,
				Wait_actual::enter,
				Reset::enter
				|}
				
				enteredSS = 	{|
				Update::entered,
				Wait_target::entered,
				Wait_actual::entered,
				Reset::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	err_output,
					actual,
					target
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_Update : core_clock_type 
				channel get_CLID_Reset : core_clock_type 
				channel get_CLID_Wait_actual : core_clock_type 
				channel get_CLID_Wait_target : core_clock_type 
				--channel increment__
				
				CLID_Update_clock_type(id__,
						          const_PID_kp,
						          const_PID_ki,
						          const_PID_kd,
						          const_PID_step) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Reset_clock_type(id__,
						          const_PID_kp,
						          const_PID_ki,
						          const_PID_kd,
						          const_PID_step) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Wait_actual_clock_type(id__,
						          const_PID_kp,
						          const_PID_ki,
						          const_PID_kd,
						          const_PID_step) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Wait_target_clock_type(id__,
						          const_PID_kp,
						          const_PID_ki,
						          const_PID_kd,
						          const_PID_step) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) = D__(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Update
					module Update
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_actual_value?actual_value -> share__choice(get_target_value?target_value -> true & (share__choice(set_error!Minus(actual_value, target_value, core_int) -> SKIP)))));share__choice(share__choice(get_integral?integral -> share__choice(get_error?error -> true & (share__choice(set_integral!Plus(integral, (Mult(error, const_PID_step, core_int)), core_int) -> SKIP)))));share__choice(share__choice(get_prior_error?prior_error -> share__choice(get_error?error -> const_PID_step != 0 & (share__choice(set_derivative!floor(Div((Minus(error, prior_error, core_int)), no_zero_div(const_PID_step), core_real)) -> SKIP)))));share__choice(share__choice(get_integral?integral -> share__choice(get_derivative?derivative -> share__choice(get_error?error -> true & (share__choice(set_output!Plus(Plus(Mult(const_PID_kp, error, core_int), Mult(const_PID_ki, integral, core_int), core_int), Mult(const_PID_kd, derivative, core_int), core_int) -> SKIP))))));share__choice(share__choice(get_error?error -> true & (share__choice(set_prior_error!error -> SKIP))));share__choice(get_output?output -> true&(share__choice(err_output.out!output -> SKIP)));share__choice(share__choice(get_target_value?target_value -> true & (share__choice(set_old_target!target_value -> SKIP)))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_actual_value?actual_value -> share__choice(get_target_value?target_value -> true & (share__choice(set_error!Minus(actual_value, target_value, core_int) -> SKIP)))));share__choice(share__choice(get_integral?integral -> share__choice(get_error?error -> true & (share__choice(set_integral!Plus(integral, (Mult(error, const_PID_step, core_int)), core_int) -> SKIP)))));share__choice(share__choice(get_prior_error?prior_error -> share__choice(get_error?error -> const_PID_step != 0 & (share__choice(set_derivative!floor(Div((Minus(error, prior_error, core_int)), no_zero_div(const_PID_step), core_real)) -> SKIP)))));share__choice(share__choice(get_integral?integral -> share__choice(get_derivative?derivative -> share__choice(get_error?error -> true & (share__choice(set_output!Plus(Plus(Mult(const_PID_kp, error, core_int), Mult(const_PID_ki, integral, core_int), core_int), Mult(const_PID_kd, derivative, core_int), core_int) -> SKIP))))));share__choice(share__choice(get_error?error -> true & (share__choice(set_prior_error!error -> SKIP))));share__choice(get_output?output -> true&(share__choice(err_output.out!output -> SKIP)));share__choice(share__choice(get_target_value?target_value -> true & (share__choice(set_old_target!target_value -> SKIP)))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Wait_target
					module Wait_target
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Wait_actual
					module Wait_actual
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Reset
					module Reset
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_prior_error!0 -> SKIP)));share__choice(true & (share__choice(set_integral!0 -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_prior_error!0 -> SKIP)));share__choice(true & (share__choice(set_integral!0 -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__,
										    const_PID_kp,
										    const_PID_ki,
										    const_PID_kd,
										    const_PID_step) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_PID_kp,
								    const_PID_ki,
								    const_PID_kd,
								    const_PID_step))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					STM_VS_O(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__,
										    const_PID_kp,
										    const_PID_ki,
										    const_PID_kd,
										    const_PID_step) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_PID_kp,
								    const_PID_ki,
								    const_PID_kd,
								    const_PID_step))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					-- Transitions
					Transitions(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = ((let
						Trans = share__choice(get_target_value?target_value -> get_old_target?old_target -> TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((share__choice(true & (share__choice(set_prior_error!0 -> SKIP)));share__choice(true & (share__choice(set_integral!0 -> SKIP))) ; Wait_target::enter -> SKIP))))
							 [] dbisim((true)&(internal__!NID_Update -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SHARE_WAIT(const_PID_step) ; Wait_target::enter -> SKIP)))
							 [] dbisim((target__!NID_Wait_target.in?target_value:{target_value|target_value <- core_int, (target_value==old_target)} -> share__choice(set_target_value!target_value -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Wait_actual::enter -> SKIP)))
							 [] dbisim((true)&(actual__!NID_Wait_actual.in?actual_value:{actual_value|actual_value <- core_int, true} -> share__choice(set_actual_value!actual_value -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Update::enter -> SKIP)))
							 [] dbisim((target__!NID_Wait_target.in?target_value:{target_value|target_value <- core_int, (target_value!=old_target)} -> share__choice(set_target_value!target_value -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Reset::enter -> SKIP)))
							 [] dbisim((true)&(actual__!NID_Reset.in?actual_value:{actual_value|actual_value <- core_int, true} -> share__choice(set_actual_value!actual_value -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Update::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
						)
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Update::enter,
								Wait_target::enter,
								Wait_actual::enter,
								Reset::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,internal__.NID_Update,target__.NID_Wait_target.in,actual__.NID_Wait_actual.in,target__.NID_Wait_target.in,actual__.NID_Reset.in|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__,
									   		    const_PID_kp,
									   		    const_PID_ki,
									   		    const_PID_kd,
									   		    const_PID_step)
									   [| { share__, terminate } |] (
									   Update::D__(id__,
									   		    const_PID_kp,
									   		    const_PID_ki,
									   		    const_PID_kd,
									   		    const_PID_step)
									   [| { share__, terminate } |] (
									   Wait_target::D__(id__,
									   		    const_PID_kp,
									   		    const_PID_ki,
									   		    const_PID_kd,
									   		    const_PID_step)
									   [| { share__, terminate } |] (
									   Wait_actual::D__(id__,
									   		    const_PID_kp,
									   		    const_PID_ki,
									   		    const_PID_kd,
									   		    const_PID_step)
									   [| { share__, terminate } |] (
									   Reset::D__(id__,
									   		    const_PID_kp,
									   		    const_PID_ki,
									   		    const_PID_kd,
									   		    const_PID_step)
									   )
									   )
									   )
									   )
									 )
									 [[Update::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Update|}]]
									 [[Wait_target::interrupt <- x__ | x__ <- {|interrupt,target__.NID_Wait_target.in,target__.NID_Wait_target.in|}]]
									 [[Wait_actual::interrupt <- x__ | x__ <- {|interrupt,actual__.NID_Wait_actual.in|}]]
									 [[Reset::interrupt <- x__ | x__ <- {|interrupt,actual__.NID_Reset.in|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_target_value,setR_actual_value |} ]] 
									  [[set_target_value <- setL_target_value,set_old_target <- setL_old_target]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_target_value
									 			,setL_old_target
									 			,setR_target_value
									 			 			,setR_actual_value
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_PID_kp,
									 		    const_PID_ki,
									 		    const_PID_kd,
									 		    const_PID_step))
									  [[ share__ <- x__ | x__ <- {| share__,setL_target_value,setL_old_target |} ]]
									  [[set_target_value <- setR_target_value,set_actual_value <- setR_actual_value]]
									 )
									)[[setL_target_value <- set_target_value,setL_old_target <- set_old_target]]
									 [[setR_target_value <- set_target_value,setR_actual_value <- set_actual_value]]
									)
								)
								 \ hideSet)
								[[
									err_output__.x____ <- err_output,
									actual__.x____ <- actual,
									target__.x____ <- target
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_PID_kp,
							 		          const_PID_ki,
							 		          const_PID_kd,
							 		          const_PID_step)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
						dbisim((let
							stateClockSync = {|get_CLID_Update,Update::entered,get_CLID_Reset,Reset::entered,get_CLID_Wait_actual,Wait_actual::entered,get_CLID_Wait_target,Wait_target::entered|}
						 within
							(MachineBody(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
						dbisim((let
							stateClockSync = {|get_CLID_Update,Update::entered,get_CLID_Reset,Reset::entered,get_CLID_Wait_actual,Wait_actual::entered,get_CLID_Wait_target,Wait_target::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															MachineBody(id__,
																	    const_PID_kp,
																	    const_PID_ki,
																	    const_PID_kd,
																	    const_PID_step)
															[| {|get_CLID_Wait_target,Wait_target::entered,terminate|} |]
															dbisim(Clock_CLID_Wait_target(id__,0,
																	          const_PID_kp,
																	          const_PID_ki,
																	          const_PID_kd,
																	          const_PID_step))
														)\{|get_CLID_Wait_target|}
													)
													[| {|get_CLID_Wait_actual,Wait_actual::entered,terminate|} |]
													dbisim(Clock_CLID_Wait_actual(id__,0,
															          const_PID_kp,
															          const_PID_ki,
															          const_PID_kd,
															          const_PID_step))
												)\{|get_CLID_Wait_actual|}
											)
											[| {|get_CLID_Reset,Reset::entered,terminate|} |]
											dbisim(Clock_CLID_Reset(id__,0,
													          const_PID_kp,
													          const_PID_ki,
													          const_PID_kd,
													          const_PID_step))
										)\{|get_CLID_Reset|}
									)
									[| {|get_CLID_Update,Update::entered,terminate|} |]
									dbisim(Clock_CLID_Update(id__,0,
											          const_PID_kp,
											          const_PID_ki,
											          const_PID_kd,
											          const_PID_step))
								)\{|get_CLID_Update|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
						((let
							getsetLocalChannels = {|get_prior_error,set_prior_error,
							get_integral,set_integral,
							get_error,set_error,
							get_derivative,set_derivative,
							get_output,set_output,
							get_target_value,set_target_value,
							get_actual_value,set_actual_value,
							get_old_target,set_old_target|}
							clockSync = {||}
						within
							(Behaviour(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_PID_kp,
							 		    const_PID_ki,
							 		    const_PID_kd,
							 		    const_PID_step) [| {terminate} |] Clocks(id__,
							 		          const_PID_kp,
							 		          const_PID_ki,
							 		          const_PID_kd,
							 		          const_PID_step))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																dbisim(
																	sbisim(
																		dbisim(
																			sbisim(
																				dbisim(
																					sbisim(
																						IteratedBehaviour(id__,
																								    const_PID_kp,
																								    const_PID_ki,
																								    const_PID_kd,
																								    const_PID_step)
																						[| {|get_old_target,set_old_target,terminate|} |]
																						Memory_old_target(0)
																					)\{|get_old_target,set_old_target|}
																				)
																				[| {|get_actual_value,set_actual_value,terminate|} |]
																				Memory_actual_value(0)
																			)\{|get_actual_value,set_actual_value|}
																		)
																		[| {|get_target_value,set_target_value,terminate|} |]
																		Memory_target_value(0)
																	)\{|get_target_value,set_target_value|}
																)
																[| {|get_output,set_output,terminate|} |]
																Memory_output(0)
															)\{|get_output,set_output|}
														)
														[| {|get_derivative,set_derivative,terminate|} |]
														Memory_derivative(0)
													)\{|get_derivative,set_derivative|}
												)
												[| {|get_error,set_error,terminate|} |]
												Memory_error(0)
											)\{|get_error,set_error|}
										)
										[| {|get_integral,set_integral,terminate|} |]
										Memory_integral(0)
									)\{|get_integral,set_integral|}
								)
								[| {|get_prior_error,set_prior_error,terminate|} |]
								Memory_prior_error(0)
							)\{|get_prior_error,set_prior_error|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Update::enter,
								Wait_target::enter,
								Wait_actual::enter,
								Reset::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,internal__.NID_Update,target__.NID_Wait_target.in,actual__.NID_Wait_actual.in,target__.NID_Wait_target.in,actual__.NID_Reset.in|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__,
									   		    const_PID_kp,
									   		    const_PID_ki,
									   		    const_PID_kd,
									   		    const_PID_step)
									   [| { share__, terminate } |] (
									   Update::VS_O__(id__,
									   		    const_PID_kp,
									   		    const_PID_ki,
									   		    const_PID_kd,
									   		    const_PID_step)
									   [| { share__, terminate } |] (
									   Wait_target::VS_O__(id__,
									   		    const_PID_kp,
									   		    const_PID_ki,
									   		    const_PID_kd,
									   		    const_PID_step)
									   [| { share__, terminate } |] (
									   Wait_actual::VS_O__(id__,
									   		    const_PID_kp,
									   		    const_PID_ki,
									   		    const_PID_kd,
									   		    const_PID_step)
									   [| { share__, terminate } |] (
									   Reset::VS_O__(id__,
									   		    const_PID_kp,
									   		    const_PID_ki,
									   		    const_PID_kd,
									   		    const_PID_step)
									   )
									   )
									   )
									   )
									 )
									 [[Update::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Update|}]]
									 [[Wait_target::interrupt <- x__ | x__ <- {|interrupt,target__.NID_Wait_target.in,target__.NID_Wait_target.in|}]]
									 [[Wait_actual::interrupt <- x__ | x__ <- {|interrupt,actual__.NID_Wait_actual.in|}]]
									 [[Reset::interrupt <- x__ | x__ <- {|interrupt,actual__.NID_Reset.in|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_target_value,setR_actual_value |} ]] 
									  [[set_target_value <- setL_target_value,set_old_target <- setL_old_target]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_target_value
									 			,setL_old_target
									 			,setR_target_value
									 			 			,setR_actual_value
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_PID_kp,
									 		    const_PID_ki,
									 		    const_PID_kd,
									 		    const_PID_step))
									  [[ share__ <- x__ | x__ <- {| share__,setL_target_value,setL_old_target |} ]]
									  [[set_target_value <- setR_target_value,set_actual_value <- setR_actual_value]]
									 )
									)[[setL_target_value <- set_target_value,setL_old_target <- set_old_target]]
									 [[setR_target_value <- set_target_value,setR_actual_value <- set_actual_value]]
									)
								)
								 \ hideSet)
								[[
									err_output__.x____ <- err_output,
									actual__.x____ <- actual,
									target__.x____ <- target
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_PID_kp,
							 		          const_PID_ki,
							 		          const_PID_kd,
							 		          const_PID_step)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
						dbisim((let
							stateClockSync = {|get_CLID_Update,Update::entered,get_CLID_Reset,Reset::entered,get_CLID_Wait_actual,Wait_actual::entered,get_CLID_Wait_target,Wait_target::entered|}
						 within
							(MachineBody_VS_O(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
						dbisim((let
							stateClockSync = {|get_CLID_Update,Update::entered,get_CLID_Reset,Reset::entered,get_CLID_Wait_actual,Wait_actual::entered,get_CLID_Wait_target,Wait_target::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															MachineBody_VS_O(id__,
																	    const_PID_kp,
																	    const_PID_ki,
																	    const_PID_kd,
																	    const_PID_step)
															[| {|get_CLID_Wait_target,Wait_target::entered,terminate|} |]
															dbisim(Clock_CLID_Wait_target(id__,0,
																	          const_PID_kp,
																	          const_PID_ki,
																	          const_PID_kd,
																	          const_PID_step))
														)\{|get_CLID_Wait_target|}
													)
													[| {|get_CLID_Wait_actual,Wait_actual::entered,terminate|} |]
													dbisim(Clock_CLID_Wait_actual(id__,0,
															          const_PID_kp,
															          const_PID_ki,
															          const_PID_kd,
															          const_PID_step))
												)\{|get_CLID_Wait_actual|}
											)
											[| {|get_CLID_Reset,Reset::entered,terminate|} |]
											dbisim(Clock_CLID_Reset(id__,0,
													          const_PID_kp,
													          const_PID_ki,
													          const_PID_kd,
													          const_PID_step))
										)\{|get_CLID_Reset|}
									)
									[| {|get_CLID_Update,Update::entered,terminate|} |]
									dbisim(Clock_CLID_Update(id__,0,
											          const_PID_kp,
											          const_PID_ki,
											          const_PID_kd,
											          const_PID_step))
								)\{|get_CLID_Update|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
						dbisim((let
							getsetLocalChannels = {|get_prior_error,set_prior_error,
							get_integral,set_integral,
							get_error,set_error,
							get_derivative,set_derivative,
							get_output,set_output,
							get_target_value,set_target_value,
							get_actual_value,set_actual_value,
							get_old_target,set_old_target|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_PID_kp,
							 		    const_PID_ki,
							 		    const_PID_kd,
							 		    const_PID_step) [| {terminate} |] Clocks(id__,
							 		          const_PID_kp,
							 		          const_PID_ki,
							 		          const_PID_kd,
							 		          const_PID_step))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																dbisim(
																	sbisim(
																		dbisim(
																			sbisim(
																				dbisim(
																					sbisim(
																						IteratedBehaviour_VS_O(id__,
																								    const_PID_kp,
																								    const_PID_ki,
																								    const_PID_kd,
																								    const_PID_step)
																						[| {|get_old_target,set_old_target,terminate|} |]
																						Memory_old_target(0)
																					)\{|get_old_target,set_old_target|}
																				)
																				[| {|get_actual_value,set_actual_value,terminate|} |]
																				Memory_actual_value(0)
																			)\{|get_actual_value,set_actual_value|}
																		)
																		[| {|get_target_value,set_target_value,terminate|} |]
																		Memory_target_value(0)
																	)\{|get_target_value,set_target_value|}
																)
																[| {|get_output,set_output,terminate|} |]
																Memory_output(0)
															)\{|get_output,set_output|}
														)
														[| {|get_derivative,set_derivative,terminate|} |]
														Memory_derivative(0)
													)\{|get_derivative,set_derivative|}
												)
												[| {|get_error,set_error,terminate|} |]
												Memory_error(0)
											)\{|get_error,set_error|}
										)
										[| {|get_integral,set_integral,terminate|} |]
										Memory_integral(0)
									)\{|get_integral,set_integral|}
								)
								[| {|get_prior_error,set_prior_error,terminate|} |]
								Memory_prior_error(0)
							)\{|get_prior_error,set_prior_error|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_prior_error(prior_error) =
						get_prior_error!prior_error -> Memory_prior_error(prior_error)
						[]
						set_prior_error?x__ -> Memory_prior_error(x__)
						[]
						terminate -> SKIP
					Memory_integral(integral) =
						get_integral!integral -> Memory_integral(integral)
						[]
						set_integral?x__ -> Memory_integral(x__)
						[]
						terminate -> SKIP
					Memory_error(error) =
						get_error!error -> Memory_error(error)
						[]
						set_error?x__ -> Memory_error(x__)
						[]
						terminate -> SKIP
					Memory_derivative(derivative) =
						get_derivative!derivative -> Memory_derivative(derivative)
						[]
						set_derivative?x__ -> Memory_derivative(x__)
						[]
						terminate -> SKIP
					Memory_output(output) =
						get_output!output -> Memory_output(output)
						[]
						set_output?x__ -> Memory_output(x__)
						[]
						terminate -> SKIP
					Memory_target_value(target_value) =
						get_target_value!target_value -> Memory_target_value(target_value)
						[]
						set_target_value?x__ -> Memory_target_value(x__)
						[]
						terminate -> SKIP
					Memory_actual_value(actual_value) =
						get_actual_value!actual_value -> Memory_actual_value(actual_value)
						[]
						set_actual_value?x__ -> Memory_actual_value(x__)
						[]
						terminate -> SKIP
					Memory_old_target(old_target) =
						get_old_target!old_target -> Memory_old_target(old_target)
						[]
						set_old_target?x__ -> Memory_old_target(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = Memory_prior_error(0)
					[| { terminate } |] (
					Memory_integral(0)
					[| { terminate } |] (
					Memory_error(0)
					[| { terminate } |] (
					Memory_derivative(0)
					[| { terminate } |] (
					Memory_output(0)
					[| { terminate } |] (
					Memory_target_value(0)
					[| { terminate } |] (
					Memory_actual_value(0)
					[| { terminate } |] (
					Memory_old_target(0)
					)
					)
					)
					)
					)
					)
					)
					
					getsetLocalChannels = {|get_prior_error,set_prior_error,get_integral,set_integral,get_error,set_error,get_derivative,set_derivative,get_output,set_output,get_target_value,set_target_value,get_actual_value,set_actual_value,get_old_target,set_old_target|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = STM_VS_O(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) \ localClockResets
					D__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = timed_priority(STM(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) \ union(internal_events,localClockResets))
					O__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = dbisim(D__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step))
					VS__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = FVS__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step)
					VS_O__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = dbisim(FVS__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step))
					HEXT__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = O__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) [|shared_variable_events|] SKIP
					FVS_C__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = dbisim(timed_priority(STM(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) \ internal_events))
					HUP__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = timed_priority(O__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__,
							          const_PID_kp,
							          const_PID_ki,
							          const_PID_kd,
							          const_PID_step) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_Update(id__,x__,
							          const_PID_kp,
							          const_PID_ki,
							          const_PID_kd,
							          const_PID_step) = 
						TimeOut_1(
							Update::entered -> Clock_CLID_Update(id__,0,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)
							[]
							get_CLID_Update!x__ -> Clock_CLID_Update(id__,x__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)
							[]
							terminate -> SKIP,Clock_CLID_Update(id__,clock_type_plus(x__,1,CLID_Update_clock_type(id__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)),
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step))
					Clock_CLID_Reset(id__,x__,
							          const_PID_kp,
							          const_PID_ki,
							          const_PID_kd,
							          const_PID_step) = 
						TimeOut_1(
							Reset::entered -> Clock_CLID_Reset(id__,0,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)
							[]
							get_CLID_Reset!x__ -> Clock_CLID_Reset(id__,x__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)
							[]
							terminate -> SKIP,Clock_CLID_Reset(id__,clock_type_plus(x__,1,CLID_Reset_clock_type(id__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)),
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step))
					Clock_CLID_Wait_actual(id__,x__,
							          const_PID_kp,
							          const_PID_ki,
							          const_PID_kd,
							          const_PID_step) = 
						TimeOut_1(
							Wait_actual::entered -> Clock_CLID_Wait_actual(id__,0,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)
							[]
							get_CLID_Wait_actual!x__ -> Clock_CLID_Wait_actual(id__,x__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)
							[]
							terminate -> SKIP,Clock_CLID_Wait_actual(id__,clock_type_plus(x__,1,CLID_Wait_actual_clock_type(id__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)),
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step))
					Clock_CLID_Wait_target(id__,x__,
							          const_PID_kp,
							          const_PID_ki,
							          const_PID_kd,
							          const_PID_step) = 
						TimeOut_1(
							Wait_target::entered -> Clock_CLID_Wait_target(id__,0,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)
							[]
							get_CLID_Wait_target!x__ -> Clock_CLID_Wait_target(id__,x__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)
							[]
							terminate -> SKIP,Clock_CLID_Wait_target(id__,clock_type_plus(x__,1,CLID_Wait_target_clock_type(id__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)),
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step))
					
					StateClocks(id__,
							          const_PID_kp,
							          const_PID_ki,
							          const_PID_kd,
							          const_PID_step) = dbisim(Clock_CLID_Update(id__,0,
							          const_PID_kp,
							          const_PID_ki,
							          const_PID_kd,
							          const_PID_step))
					[| { terminate } |] (
					dbisim(Clock_CLID_Reset(id__,0,
							          const_PID_kp,
							          const_PID_ki,
							          const_PID_kd,
							          const_PID_step))
					[| { terminate } |] (
					dbisim(Clock_CLID_Wait_actual(id__,0,
							          const_PID_kp,
							          const_PID_ki,
							          const_PID_kd,
							          const_PID_step))
					[| { terminate } |] (
					dbisim(Clock_CLID_Wait_target(id__,0,
							          const_PID_kp,
							          const_PID_ki,
							          const_PID_kd,
							          const_PID_step))
					)
					)
					)
					
					stateClockSync = {|get_CLID_Update,Update::entered,get_CLID_Reset,Reset::entered,get_CLID_Wait_actual,Wait_actual::entered,get_CLID_Wait_target,Wait_target::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			module stm_ref7
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_Update|
				              NID_Wait_target|
				              NID_Wait_actual|
				              NID_Reset
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_prior_error, set_prior_error, setL_prior_error, setR_prior_error: core_int
				channel get_integral, set_integral, setL_integral, setR_integral: core_int
				channel get_error, set_error, setL_error, setR_error: core_int
				channel get_derivative, set_derivative, setL_derivative, setR_derivative: core_int
				channel get_output, set_output, setL_output, setR_output: core_int
				channel get_target_value, set_target_value, setL_target_value, setR_target_value: core_int
				channel get_actual_value, set_actual_value, setL_actual_value, setR_actual_value: core_int
				channel get_old_target, set_old_target, setL_old_target, setR_old_target: core_int
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel err_output__: NIDS.InOut.core_int
				channel err_output: InOut.core_int
				channel actual__: NIDS.InOut.core_int
				channel actual: InOut.core_int
				channel target__: NIDS.InOut.core_int
				channel target: InOut.core_int
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				Update::enter,
				Wait_target::enter,
				Wait_actual::enter,
				Reset::enter
				|}
				
				enteredSS = 	{|
				Update::entered,
				Wait_target::entered,
				Wait_actual::entered,
				Reset::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	err_output,
					actual,
					target
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_Update : core_clock_type 
				channel get_CLID_Reset : core_clock_type 
				channel get_CLID_Wait_actual : core_clock_type 
				channel get_CLID_Wait_target : core_clock_type 
				--channel increment__
				
				CLID_Update_clock_type(id__,
						          const_PID_kp,
						          const_PID_ki,
						          const_PID_kd,
						          const_PID_step) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Reset_clock_type(id__,
						          const_PID_kp,
						          const_PID_ki,
						          const_PID_kd,
						          const_PID_step) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Wait_actual_clock_type(id__,
						          const_PID_kp,
						          const_PID_ki,
						          const_PID_kd,
						          const_PID_step) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Wait_target_clock_type(id__,
						          const_PID_kp,
						          const_PID_ki,
						          const_PID_kd,
						          const_PID_step) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) = D__(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Update
					module Update
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_actual_value?actual_value -> share__choice(get_target_value?target_value -> true & (share__choice(set_error!Minus(actual_value, target_value, core_int) -> SKIP)))));share__choice(share__choice(get_integral?integral -> share__choice(get_error?error -> true & (share__choice(set_integral!Plus(integral, (Mult(error, const_PID_step, core_int)), core_int) -> SKIP)))));share__choice(share__choice(get_prior_error?prior_error -> share__choice(get_error?error -> const_PID_step != 0 & (share__choice(set_derivative!floor(Div((Minus(error, prior_error, core_int)), no_zero_div(const_PID_step), core_real)) -> SKIP)))));share__choice(share__choice(get_integral?integral -> share__choice(get_derivative?derivative -> share__choice(get_error?error -> true & (share__choice(set_output!Plus(Plus(Mult(const_PID_kp, error, core_int), Mult(const_PID_ki, integral, core_int), core_int), Mult(const_PID_kd, derivative, core_int), core_int) -> SKIP))))));share__choice(share__choice(get_error?error -> true & (share__choice(set_prior_error!error -> SKIP))));share__choice(get_output?output -> true&(share__choice(err_output.out!output -> SKIP)));share__choice(share__choice(get_target_value?target_value -> true & (share__choice(set_old_target!target_value -> SKIP)))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_actual_value?actual_value -> share__choice(get_target_value?target_value -> true & (share__choice(set_error!Minus(actual_value, target_value, core_int) -> SKIP)))));share__choice(share__choice(get_integral?integral -> share__choice(get_error?error -> true & (share__choice(set_integral!Plus(integral, (Mult(error, const_PID_step, core_int)), core_int) -> SKIP)))));share__choice(share__choice(get_prior_error?prior_error -> share__choice(get_error?error -> const_PID_step != 0 & (share__choice(set_derivative!floor(Div((Minus(error, prior_error, core_int)), no_zero_div(const_PID_step), core_real)) -> SKIP)))));share__choice(share__choice(get_integral?integral -> share__choice(get_derivative?derivative -> share__choice(get_error?error -> true & (share__choice(set_output!Plus(Plus(Mult(const_PID_kp, error, core_int), Mult(const_PID_ki, integral, core_int), core_int), Mult(const_PID_kd, derivative, core_int), core_int) -> SKIP))))));share__choice(share__choice(get_error?error -> true & (share__choice(set_prior_error!error -> SKIP))));share__choice(get_output?output -> true&(share__choice(err_output.out!output -> SKIP)));share__choice(share__choice(get_target_value?target_value -> true & (share__choice(set_old_target!target_value -> SKIP)))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Wait_target
					module Wait_target
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Wait_actual
					module Wait_actual
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Reset
					module Reset
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_prior_error!0 -> SKIP)));share__choice(true & (share__choice(set_integral!0 -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_prior_error!0 -> SKIP)));share__choice(true & (share__choice(set_integral!0 -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__,
										    const_PID_kp,
										    const_PID_ki,
										    const_PID_kd,
										    const_PID_step) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_PID_kp,
								    const_PID_ki,
								    const_PID_kd,
								    const_PID_step))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					STM_VS_O(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__,
										    const_PID_kp,
										    const_PID_ki,
										    const_PID_kd,
										    const_PID_step) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_PID_kp,
								    const_PID_ki,
								    const_PID_kd,
								    const_PID_step))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					-- Transitions
					Transitions(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = ((let
						Trans = share__choice(get_target_value?target_value -> get_old_target?old_target -> TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((share__choice(true & (share__choice(set_prior_error!0 -> SKIP)));share__choice(true & (share__choice(set_integral!0 -> SKIP))) ; Wait_target::enter -> SKIP))))
							 [] dbisim((true)&(internal__!NID_Update -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SHARE_WAIT(const_PID_step) ; Wait_target::enter -> SKIP)))
							 [] dbisim((target__!NID_Wait_target.in?target_value:{target_value|target_value <- core_int, (target_value==old_target)} -> share__choice(set_target_value!target_value -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Wait_actual::enter -> SKIP)))
							 [] dbisim((true)&(actual__!NID_Wait_actual.in?actual_value:{actual_value|actual_value <- core_int, true} -> share__choice(set_actual_value!actual_value -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Update::enter -> SKIP)))
							 [] dbisim((target__!NID_Wait_target.in?target_value:{target_value|target_value <- core_int, (target_value!=old_target)} -> share__choice(set_target_value!target_value -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Reset::enter -> SKIP)))
							 [] dbisim((true)&(actual__!NID_Reset.in?actual_value:{actual_value|actual_value <- core_int, true} -> share__choice(set_actual_value!actual_value -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Update::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
						)
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Update::enter,
								Wait_target::enter,
								Wait_actual::enter,
								Reset::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,internal__.NID_Update,target__.NID_Wait_target.in,actual__.NID_Wait_actual.in,target__.NID_Wait_target.in,actual__.NID_Reset.in|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__,
									   		    const_PID_kp,
									   		    const_PID_ki,
									   		    const_PID_kd,
									   		    const_PID_step)
									   [| { share__, terminate } |] (
									   Update::D__(id__,
									   		    const_PID_kp,
									   		    const_PID_ki,
									   		    const_PID_kd,
									   		    const_PID_step)
									   [| { share__, terminate } |] (
									   Wait_target::D__(id__,
									   		    const_PID_kp,
									   		    const_PID_ki,
									   		    const_PID_kd,
									   		    const_PID_step)
									   [| { share__, terminate } |] (
									   Wait_actual::D__(id__,
									   		    const_PID_kp,
									   		    const_PID_ki,
									   		    const_PID_kd,
									   		    const_PID_step)
									   [| { share__, terminate } |] (
									   Reset::D__(id__,
									   		    const_PID_kp,
									   		    const_PID_ki,
									   		    const_PID_kd,
									   		    const_PID_step)
									   )
									   )
									   )
									   )
									 )
									 [[Update::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Update|}]]
									 [[Wait_target::interrupt <- x__ | x__ <- {|interrupt,target__.NID_Wait_target.in,target__.NID_Wait_target.in|}]]
									 [[Wait_actual::interrupt <- x__ | x__ <- {|interrupt,actual__.NID_Wait_actual.in|}]]
									 [[Reset::interrupt <- x__ | x__ <- {|interrupt,actual__.NID_Reset.in|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_target_value,setR_actual_value |} ]] 
									  [[set_target_value <- setL_target_value,set_old_target <- setL_old_target]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_target_value
									 			,setL_old_target
									 			,setR_target_value
									 			 			,setR_actual_value
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_PID_kp,
									 		    const_PID_ki,
									 		    const_PID_kd,
									 		    const_PID_step))
									  [[ share__ <- x__ | x__ <- {| share__,setL_target_value,setL_old_target |} ]]
									  [[set_target_value <- setR_target_value,set_actual_value <- setR_actual_value]]
									 )
									)[[setL_target_value <- set_target_value,setL_old_target <- set_old_target]]
									 [[setR_target_value <- set_target_value,setR_actual_value <- set_actual_value]]
									)
								)
								 \ hideSet)
								[[
									err_output__.x____ <- err_output,
									actual__.x____ <- actual,
									target__.x____ <- target
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_PID_kp,
							 		          const_PID_ki,
							 		          const_PID_kd,
							 		          const_PID_step)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
						dbisim((let
							stateClockSync = {|get_CLID_Update,Update::entered,get_CLID_Reset,Reset::entered,get_CLID_Wait_actual,Wait_actual::entered,get_CLID_Wait_target,Wait_target::entered|}
						 within
							(MachineBody(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
						dbisim((let
							stateClockSync = {|get_CLID_Update,Update::entered,get_CLID_Reset,Reset::entered,get_CLID_Wait_actual,Wait_actual::entered,get_CLID_Wait_target,Wait_target::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															MachineBody(id__,
																	    const_PID_kp,
																	    const_PID_ki,
																	    const_PID_kd,
																	    const_PID_step)
															[| {|get_CLID_Wait_target,Wait_target::entered,terminate|} |]
															dbisim(Clock_CLID_Wait_target(id__,0,
																	          const_PID_kp,
																	          const_PID_ki,
																	          const_PID_kd,
																	          const_PID_step))
														)\{|get_CLID_Wait_target|}
													)
													[| {|get_CLID_Wait_actual,Wait_actual::entered,terminate|} |]
													dbisim(Clock_CLID_Wait_actual(id__,0,
															          const_PID_kp,
															          const_PID_ki,
															          const_PID_kd,
															          const_PID_step))
												)\{|get_CLID_Wait_actual|}
											)
											[| {|get_CLID_Reset,Reset::entered,terminate|} |]
											dbisim(Clock_CLID_Reset(id__,0,
													          const_PID_kp,
													          const_PID_ki,
													          const_PID_kd,
													          const_PID_step))
										)\{|get_CLID_Reset|}
									)
									[| {|get_CLID_Update,Update::entered,terminate|} |]
									dbisim(Clock_CLID_Update(id__,0,
											          const_PID_kp,
											          const_PID_ki,
											          const_PID_kd,
											          const_PID_step))
								)\{|get_CLID_Update|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
						((let
							getsetLocalChannels = {|get_prior_error,set_prior_error,
							get_integral,set_integral,
							get_error,set_error,
							get_derivative,set_derivative,
							get_output,set_output,
							get_target_value,set_target_value,
							get_actual_value,set_actual_value,
							get_old_target,set_old_target|}
							clockSync = {||}
						within
							(Behaviour(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_PID_kp,
							 		    const_PID_ki,
							 		    const_PID_kd,
							 		    const_PID_step) [| {terminate} |] Clocks(id__,
							 		          const_PID_kp,
							 		          const_PID_ki,
							 		          const_PID_kd,
							 		          const_PID_step))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																dbisim(
																	sbisim(
																		dbisim(
																			sbisim(
																				dbisim(
																					sbisim(
																						IteratedBehaviour(id__,
																								    const_PID_kp,
																								    const_PID_ki,
																								    const_PID_kd,
																								    const_PID_step)
																						[| {|get_old_target,set_old_target,terminate|} |]
																						Memory_old_target(0)
																					)\{|get_old_target,set_old_target|}
																				)
																				[| {|get_actual_value,set_actual_value,terminate|} |]
																				Memory_actual_value(0)
																			)\{|get_actual_value,set_actual_value|}
																		)
																		[| {|get_target_value,set_target_value,terminate|} |]
																		Memory_target_value(0)
																	)\{|get_target_value,set_target_value|}
																)
																[| {|get_output,set_output,terminate|} |]
																Memory_output(0)
															)\{|get_output,set_output|}
														)
														[| {|get_derivative,set_derivative,terminate|} |]
														Memory_derivative(0)
													)\{|get_derivative,set_derivative|}
												)
												[| {|get_error,set_error,terminate|} |]
												Memory_error(0)
											)\{|get_error,set_error|}
										)
										[| {|get_integral,set_integral,terminate|} |]
										Memory_integral(0)
									)\{|get_integral,set_integral|}
								)
								[| {|get_prior_error,set_prior_error,terminate|} |]
								Memory_prior_error(0)
							)\{|get_prior_error,set_prior_error|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Update::enter,
								Wait_target::enter,
								Wait_actual::enter,
								Reset::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,internal__.NID_Update,target__.NID_Wait_target.in,actual__.NID_Wait_actual.in,target__.NID_Wait_target.in,actual__.NID_Reset.in|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__,
									   		    const_PID_kp,
									   		    const_PID_ki,
									   		    const_PID_kd,
									   		    const_PID_step)
									   [| { share__, terminate } |] (
									   Update::VS_O__(id__,
									   		    const_PID_kp,
									   		    const_PID_ki,
									   		    const_PID_kd,
									   		    const_PID_step)
									   [| { share__, terminate } |] (
									   Wait_target::VS_O__(id__,
									   		    const_PID_kp,
									   		    const_PID_ki,
									   		    const_PID_kd,
									   		    const_PID_step)
									   [| { share__, terminate } |] (
									   Wait_actual::VS_O__(id__,
									   		    const_PID_kp,
									   		    const_PID_ki,
									   		    const_PID_kd,
									   		    const_PID_step)
									   [| { share__, terminate } |] (
									   Reset::VS_O__(id__,
									   		    const_PID_kp,
									   		    const_PID_ki,
									   		    const_PID_kd,
									   		    const_PID_step)
									   )
									   )
									   )
									   )
									 )
									 [[Update::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Update|}]]
									 [[Wait_target::interrupt <- x__ | x__ <- {|interrupt,target__.NID_Wait_target.in,target__.NID_Wait_target.in|}]]
									 [[Wait_actual::interrupt <- x__ | x__ <- {|interrupt,actual__.NID_Wait_actual.in|}]]
									 [[Reset::interrupt <- x__ | x__ <- {|interrupt,actual__.NID_Reset.in|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_target_value,setR_actual_value |} ]] 
									  [[set_target_value <- setL_target_value,set_old_target <- setL_old_target]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_target_value
									 			,setL_old_target
									 			,setR_target_value
									 			 			,setR_actual_value
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_PID_kp,
									 		    const_PID_ki,
									 		    const_PID_kd,
									 		    const_PID_step))
									  [[ share__ <- x__ | x__ <- {| share__,setL_target_value,setL_old_target |} ]]
									  [[set_target_value <- setR_target_value,set_actual_value <- setR_actual_value]]
									 )
									)[[setL_target_value <- set_target_value,setL_old_target <- set_old_target]]
									 [[setR_target_value <- set_target_value,setR_actual_value <- set_actual_value]]
									)
								)
								 \ hideSet)
								[[
									err_output__.x____ <- err_output,
									actual__.x____ <- actual,
									target__.x____ <- target
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_PID_kp,
							 		          const_PID_ki,
							 		          const_PID_kd,
							 		          const_PID_step)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
						dbisim((let
							stateClockSync = {|get_CLID_Update,Update::entered,get_CLID_Reset,Reset::entered,get_CLID_Wait_actual,Wait_actual::entered,get_CLID_Wait_target,Wait_target::entered|}
						 within
							(MachineBody_VS_O(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
						dbisim((let
							stateClockSync = {|get_CLID_Update,Update::entered,get_CLID_Reset,Reset::entered,get_CLID_Wait_actual,Wait_actual::entered,get_CLID_Wait_target,Wait_target::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															MachineBody_VS_O(id__,
																	    const_PID_kp,
																	    const_PID_ki,
																	    const_PID_kd,
																	    const_PID_step)
															[| {|get_CLID_Wait_target,Wait_target::entered,terminate|} |]
															dbisim(Clock_CLID_Wait_target(id__,0,
																	          const_PID_kp,
																	          const_PID_ki,
																	          const_PID_kd,
																	          const_PID_step))
														)\{|get_CLID_Wait_target|}
													)
													[| {|get_CLID_Wait_actual,Wait_actual::entered,terminate|} |]
													dbisim(Clock_CLID_Wait_actual(id__,0,
															          const_PID_kp,
															          const_PID_ki,
															          const_PID_kd,
															          const_PID_step))
												)\{|get_CLID_Wait_actual|}
											)
											[| {|get_CLID_Reset,Reset::entered,terminate|} |]
											dbisim(Clock_CLID_Reset(id__,0,
													          const_PID_kp,
													          const_PID_ki,
													          const_PID_kd,
													          const_PID_step))
										)\{|get_CLID_Reset|}
									)
									[| {|get_CLID_Update,Update::entered,terminate|} |]
									dbisim(Clock_CLID_Update(id__,0,
											          const_PID_kp,
											          const_PID_ki,
											          const_PID_kd,
											          const_PID_step))
								)\{|get_CLID_Update|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
						dbisim((let
							getsetLocalChannels = {|get_prior_error,set_prior_error,
							get_integral,set_integral,
							get_error,set_error,
							get_derivative,set_derivative,
							get_output,set_output,
							get_target_value,set_target_value,
							get_actual_value,set_actual_value,
							get_old_target,set_old_target|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_PID_kp,
							 		    const_PID_ki,
							 		    const_PID_kd,
							 		    const_PID_step) [| {terminate} |] Clocks(id__,
							 		          const_PID_kp,
							 		          const_PID_ki,
							 		          const_PID_kd,
							 		          const_PID_step))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																dbisim(
																	sbisim(
																		dbisim(
																			sbisim(
																				dbisim(
																					sbisim(
																						IteratedBehaviour_VS_O(id__,
																								    const_PID_kp,
																								    const_PID_ki,
																								    const_PID_kd,
																								    const_PID_step)
																						[| {|get_old_target,set_old_target,terminate|} |]
																						Memory_old_target(0)
																					)\{|get_old_target,set_old_target|}
																				)
																				[| {|get_actual_value,set_actual_value,terminate|} |]
																				Memory_actual_value(0)
																			)\{|get_actual_value,set_actual_value|}
																		)
																		[| {|get_target_value,set_target_value,terminate|} |]
																		Memory_target_value(0)
																	)\{|get_target_value,set_target_value|}
																)
																[| {|get_output,set_output,terminate|} |]
																Memory_output(0)
															)\{|get_output,set_output|}
														)
														[| {|get_derivative,set_derivative,terminate|} |]
														Memory_derivative(0)
													)\{|get_derivative,set_derivative|}
												)
												[| {|get_error,set_error,terminate|} |]
												Memory_error(0)
											)\{|get_error,set_error|}
										)
										[| {|get_integral,set_integral,terminate|} |]
										Memory_integral(0)
									)\{|get_integral,set_integral|}
								)
								[| {|get_prior_error,set_prior_error,terminate|} |]
								Memory_prior_error(0)
							)\{|get_prior_error,set_prior_error|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_prior_error(prior_error) =
						get_prior_error!prior_error -> Memory_prior_error(prior_error)
						[]
						set_prior_error?x__ -> Memory_prior_error(x__)
						[]
						terminate -> SKIP
					Memory_integral(integral) =
						get_integral!integral -> Memory_integral(integral)
						[]
						set_integral?x__ -> Memory_integral(x__)
						[]
						terminate -> SKIP
					Memory_error(error) =
						get_error!error -> Memory_error(error)
						[]
						set_error?x__ -> Memory_error(x__)
						[]
						terminate -> SKIP
					Memory_derivative(derivative) =
						get_derivative!derivative -> Memory_derivative(derivative)
						[]
						set_derivative?x__ -> Memory_derivative(x__)
						[]
						terminate -> SKIP
					Memory_output(output) =
						get_output!output -> Memory_output(output)
						[]
						set_output?x__ -> Memory_output(x__)
						[]
						terminate -> SKIP
					Memory_target_value(target_value) =
						get_target_value!target_value -> Memory_target_value(target_value)
						[]
						set_target_value?x__ -> Memory_target_value(x__)
						[]
						terminate -> SKIP
					Memory_actual_value(actual_value) =
						get_actual_value!actual_value -> Memory_actual_value(actual_value)
						[]
						set_actual_value?x__ -> Memory_actual_value(x__)
						[]
						terminate -> SKIP
					Memory_old_target(old_target) =
						get_old_target!old_target -> Memory_old_target(old_target)
						[]
						set_old_target?x__ -> Memory_old_target(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = Memory_prior_error(0)
					[| { terminate } |] (
					Memory_integral(0)
					[| { terminate } |] (
					Memory_error(0)
					[| { terminate } |] (
					Memory_derivative(0)
					[| { terminate } |] (
					Memory_output(0)
					[| { terminate } |] (
					Memory_target_value(0)
					[| { terminate } |] (
					Memory_actual_value(0)
					[| { terminate } |] (
					Memory_old_target(0)
					)
					)
					)
					)
					)
					)
					)
					
					getsetLocalChannels = {|get_prior_error,set_prior_error,get_integral,set_integral,get_error,set_error,get_derivative,set_derivative,get_output,set_output,get_target_value,set_target_value,get_actual_value,set_actual_value,get_old_target,set_old_target|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = STM_VS_O(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) \ localClockResets
					D__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = timed_priority(STM(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) \ union(internal_events,localClockResets))
					O__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = dbisim(D__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step))
					VS__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = FVS__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step)
					VS_O__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = dbisim(FVS__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step))
					HEXT__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = O__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) [|shared_variable_events|] SKIP
					FVS_C__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = dbisim(timed_priority(STM(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) \ internal_events))
					HUP__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = timed_priority(O__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__,
							          const_PID_kp,
							          const_PID_ki,
							          const_PID_kd,
							          const_PID_step) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_Update(id__,x__,
							          const_PID_kp,
							          const_PID_ki,
							          const_PID_kd,
							          const_PID_step) = 
						TimeOut_1(
							Update::entered -> Clock_CLID_Update(id__,0,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)
							[]
							get_CLID_Update!x__ -> Clock_CLID_Update(id__,x__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)
							[]
							terminate -> SKIP,Clock_CLID_Update(id__,clock_type_plus(x__,1,CLID_Update_clock_type(id__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)),
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step))
					Clock_CLID_Reset(id__,x__,
							          const_PID_kp,
							          const_PID_ki,
							          const_PID_kd,
							          const_PID_step) = 
						TimeOut_1(
							Reset::entered -> Clock_CLID_Reset(id__,0,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)
							[]
							get_CLID_Reset!x__ -> Clock_CLID_Reset(id__,x__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)
							[]
							terminate -> SKIP,Clock_CLID_Reset(id__,clock_type_plus(x__,1,CLID_Reset_clock_type(id__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)),
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step))
					Clock_CLID_Wait_actual(id__,x__,
							          const_PID_kp,
							          const_PID_ki,
							          const_PID_kd,
							          const_PID_step) = 
						TimeOut_1(
							Wait_actual::entered -> Clock_CLID_Wait_actual(id__,0,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)
							[]
							get_CLID_Wait_actual!x__ -> Clock_CLID_Wait_actual(id__,x__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)
							[]
							terminate -> SKIP,Clock_CLID_Wait_actual(id__,clock_type_plus(x__,1,CLID_Wait_actual_clock_type(id__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)),
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step))
					Clock_CLID_Wait_target(id__,x__,
							          const_PID_kp,
							          const_PID_ki,
							          const_PID_kd,
							          const_PID_step) = 
						TimeOut_1(
							Wait_target::entered -> Clock_CLID_Wait_target(id__,0,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)
							[]
							get_CLID_Wait_target!x__ -> Clock_CLID_Wait_target(id__,x__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)
							[]
							terminate -> SKIP,Clock_CLID_Wait_target(id__,clock_type_plus(x__,1,CLID_Wait_target_clock_type(id__,
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step)),
									          const_PID_kp,
									          const_PID_ki,
									          const_PID_kd,
									          const_PID_step))
					
					StateClocks(id__,
							          const_PID_kp,
							          const_PID_ki,
							          const_PID_kd,
							          const_PID_step) = dbisim(Clock_CLID_Update(id__,0,
							          const_PID_kp,
							          const_PID_ki,
							          const_PID_kd,
							          const_PID_step))
					[| { terminate } |] (
					dbisim(Clock_CLID_Reset(id__,0,
							          const_PID_kp,
							          const_PID_ki,
							          const_PID_kd,
							          const_PID_step))
					[| { terminate } |] (
					dbisim(Clock_CLID_Wait_actual(id__,0,
							          const_PID_kp,
							          const_PID_ki,
							          const_PID_kd,
							          const_PID_step))
					[| { terminate } |] (
					dbisim(Clock_CLID_Wait_target(id__,0,
							          const_PID_kp,
							          const_PID_ki,
							          const_PID_kd,
							          const_PID_step))
					)
					)
					)
					
					stateClockSync = {|get_CLID_Update,Update::entered,get_CLID_Reset,Reset::entered,get_CLID_Wait_actual,Wait_actual::entered,get_CLID_Wait_target,Wait_target::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			module stm_ref8
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_Go_up|
				              NID_Turn_right|
				              NID_Go_down|
				              NID_Turn_left|
				              NID_Go_side|
				              NID_Stop
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_lspeed, set_lspeed, setL_lspeed, setR_lspeed: core_int
				channel get_rspeed, set_rspeed, setL_rspeed, setR_rspeed: core_int
				channel get_angle, set_angle, setL_angle, setR_angle: core_int
				channel get_speed_adj, set_speed_adj, setL_speed_adj, setR_speed_adj: core_int
				channel get_angle_adj, set_angle_adj, setL_angle_adj, setR_angle_adj: core_int
				channel get_direction, set_direction, setL_direction, setR_direction: Direction
				channel get_orientation, set_orientation, setL_orientation, setR_orientation: Orientation
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel target_speed__: NIDS.InOut.core_int
				channel target_speed: InOut.core_int
				channel target_angle__: NIDS.InOut.core_int
				channel target_angle: InOut.core_int
				channel speed_adjustment__: NIDS.InOut.core_int
				channel speed_adjustment: InOut.core_int
				channel angle_adjustment__: NIDS.InOut.core_int
				channel angle_adjustment: InOut.core_int
				channel move_forward__: NIDS.InOut
				channel move_forward: InOut
				channel turn__: NIDS.InOut.Direction
				channel turn: InOut.Direction
				channel stop__: NIDS.InOut
				channel stop: InOut
				
				-- Declaring call and ret events for undefined operations
				channel output_right_motorCall: core_int
				channel output_left_motorCall: core_int
				
				enterSS = {|
				i0::enter,
				Go_up::enter,
				Turn_right::enter,
				Go_down::enter,
				Turn_left::enter,
				Go_side::enter,
				Stop::enter
				|}
				
				enteredSS = 	{|
				Go_up::entered,
				Turn_right::entered,
				Go_down::entered,
				Turn_left::entered,
				Go_side::entered,
				Stop::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	target_speed,
					target_angle,
					speed_adjustment,
					angle_adjustment,
					move_forward,
					turn,
					stop
				,	output_right_motorCall,
					output_left_motorCall
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_Turn_right : core_clock_type 
				channel get_CLID_Go_up : core_clock_type 
				channel get_CLID_Stop : core_clock_type 
				channel get_CLID_Turn_left : core_clock_type 
				channel get_CLID_Go_down : core_clock_type 
				channel get_CLID_Go_side : core_clock_type 
				--channel increment__
				
				CLID_Turn_right_clock_type(id__,
						          const_MidLevelSM_step,
						          const_MidLevelSM_climb_speed,
						          const_MidLevelSM_descent_speed,
						          const_MidLevelSM_side_speed,
						          const_MidLevelSM_forward_angle,
						          const_MidLevelSM_left_angle,
						          const_MidLevelSM_right_angle,
						          const_MidLevelSM_turn_speed,
						          const_MidLevelSM_movesp,
						          const_MidLevelSM_stopsp) = 
					let
						max = (clock_type_max(Union({
				{},
				({const_MidLevelSM_step|step <- core_int})
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Go_up_clock_type(id__,
						          const_MidLevelSM_step,
						          const_MidLevelSM_climb_speed,
						          const_MidLevelSM_descent_speed,
						          const_MidLevelSM_side_speed,
						          const_MidLevelSM_forward_angle,
						          const_MidLevelSM_left_angle,
						          const_MidLevelSM_right_angle,
						          const_MidLevelSM_turn_speed,
						          const_MidLevelSM_movesp,
						          const_MidLevelSM_stopsp) = 
					let
						max = (clock_type_max(Union({
				{},
				({const_MidLevelSM_step|step <- core_int})
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Stop_clock_type(id__,
						          const_MidLevelSM_step,
						          const_MidLevelSM_climb_speed,
						          const_MidLevelSM_descent_speed,
						          const_MidLevelSM_side_speed,
						          const_MidLevelSM_forward_angle,
						          const_MidLevelSM_left_angle,
						          const_MidLevelSM_right_angle,
						          const_MidLevelSM_turn_speed,
						          const_MidLevelSM_movesp,
						          const_MidLevelSM_stopsp) = 
					let
						max = (clock_type_max(Union({
				{},
				({const_MidLevelSM_step|step <- core_int})
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Turn_left_clock_type(id__,
						          const_MidLevelSM_step,
						          const_MidLevelSM_climb_speed,
						          const_MidLevelSM_descent_speed,
						          const_MidLevelSM_side_speed,
						          const_MidLevelSM_forward_angle,
						          const_MidLevelSM_left_angle,
						          const_MidLevelSM_right_angle,
						          const_MidLevelSM_turn_speed,
						          const_MidLevelSM_movesp,
						          const_MidLevelSM_stopsp) = 
					let
						max = (clock_type_max(Union({
				{},
				({const_MidLevelSM_step|step <- core_int}),
				({const_MidLevelSM_step|step <- core_int})
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Go_down_clock_type(id__,
						          const_MidLevelSM_step,
						          const_MidLevelSM_climb_speed,
						          const_MidLevelSM_descent_speed,
						          const_MidLevelSM_side_speed,
						          const_MidLevelSM_forward_angle,
						          const_MidLevelSM_left_angle,
						          const_MidLevelSM_right_angle,
						          const_MidLevelSM_turn_speed,
						          const_MidLevelSM_movesp,
						          const_MidLevelSM_stopsp) = 
					let
						max = (clock_type_max(Union({
				{},
				({const_MidLevelSM_step|step <- core_int})
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Go_side_clock_type(id__,
						          const_MidLevelSM_step,
						          const_MidLevelSM_climb_speed,
						          const_MidLevelSM_descent_speed,
						          const_MidLevelSM_side_speed,
						          const_MidLevelSM_forward_angle,
						          const_MidLevelSM_left_angle,
						          const_MidLevelSM_right_angle,
						          const_MidLevelSM_turn_speed,
						          const_MidLevelSM_movesp,
						          const_MidLevelSM_stopsp) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_MidLevelSM_step,
									    const_MidLevelSM_climb_speed,
									    const_MidLevelSM_descent_speed,
									    const_MidLevelSM_side_speed,
									    const_MidLevelSM_forward_angle,
									    const_MidLevelSM_left_angle,
									    const_MidLevelSM_right_angle,
									    const_MidLevelSM_turn_speed,
									    const_MidLevelSM_movesp,
									    const_MidLevelSM_stopsp) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
									    const_MidLevelSM_step,
									    const_MidLevelSM_climb_speed,
									    const_MidLevelSM_descent_speed,
									    const_MidLevelSM_side_speed,
									    const_MidLevelSM_forward_angle,
									    const_MidLevelSM_left_angle,
									    const_MidLevelSM_right_angle,
									    const_MidLevelSM_turn_speed,
									    const_MidLevelSM_movesp,
									    const_MidLevelSM_stopsp) = D__(id__,
									    const_MidLevelSM_step,
									    const_MidLevelSM_climb_speed,
									    const_MidLevelSM_descent_speed,
									    const_MidLevelSM_side_speed,
									    const_MidLevelSM_forward_angle,
									    const_MidLevelSM_left_angle,
									    const_MidLevelSM_right_angle,
									    const_MidLevelSM_turn_speed,
									    const_MidLevelSM_movesp,
									    const_MidLevelSM_stopsp)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Go_up
					module Go_up
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_MidLevelSM_step,
									    const_MidLevelSM_climb_speed,
									    const_MidLevelSM_descent_speed,
									    const_MidLevelSM_side_speed,
									    const_MidLevelSM_forward_angle,
									    const_MidLevelSM_left_angle,
									    const_MidLevelSM_right_angle,
									    const_MidLevelSM_turn_speed,
									    const_MidLevelSM_movesp,
									    const_MidLevelSM_stopsp) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(target_speed.out!const_MidLevelSM_climb_speed -> SKIP));true&(share__choice(speed_adjustment.in?speed_adj -> (SStop /\ set_speed_adj!speed_adj -> SKIP)));true&(share__choice(target_angle.out!const_MidLevelSM_forward_angle -> SKIP));true&(share__choice(angle_adjustment.in?angle_adj -> (SStop /\ set_angle_adj!angle_adj -> SKIP)));share__choice(share__choice(get_angle_adj?angle_adj -> share__choice(get_speed_adj?speed_adj -> share__choice(get_lspeed?lspeed -> true & (share__choice(set_lspeed!Minus(Minus(lspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(share__choice(get_angle_adj?angle_adj -> share__choice(get_speed_adj?speed_adj -> share__choice(get_rspeed?rspeed -> true & (share__choice(set_rspeed!Plus(Minus(rspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(get_lspeed?lspeed -> true&CALL__output_left_motor(
											id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp,
											lspeed
										));share__choice(get_rspeed?rspeed -> true&CALL__output_right_motor(
											id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp,
											rspeed
										)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_MidLevelSM_step,
									    const_MidLevelSM_climb_speed,
									    const_MidLevelSM_descent_speed,
									    const_MidLevelSM_side_speed,
									    const_MidLevelSM_forward_angle,
									    const_MidLevelSM_left_angle,
									    const_MidLevelSM_right_angle,
									    const_MidLevelSM_turn_speed,
									    const_MidLevelSM_movesp,
									    const_MidLevelSM_stopsp) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(target_speed.out!const_MidLevelSM_climb_speed -> SKIP));true&(share__choice(speed_adjustment.in?speed_adj -> (SStop /\ set_speed_adj!speed_adj -> SKIP)));true&(share__choice(target_angle.out!const_MidLevelSM_forward_angle -> SKIP));true&(share__choice(angle_adjustment.in?angle_adj -> (SStop /\ set_angle_adj!angle_adj -> SKIP)));share__choice(share__choice(get_angle_adj?angle_adj -> share__choice(get_speed_adj?speed_adj -> share__choice(get_lspeed?lspeed -> true & (share__choice(set_lspeed!Minus(Minus(lspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(share__choice(get_angle_adj?angle_adj -> share__choice(get_speed_adj?speed_adj -> share__choice(get_rspeed?rspeed -> true & (share__choice(set_rspeed!Plus(Minus(rspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(get_lspeed?lspeed -> true&CALL__output_left_motor(
											id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp,
											lspeed
										));share__choice(get_rspeed?rspeed -> true&CALL__output_right_motor(
											id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp,
											rspeed
										)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Turn_right
					module Turn_right
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_MidLevelSM_step,
									    const_MidLevelSM_climb_speed,
									    const_MidLevelSM_descent_speed,
									    const_MidLevelSM_side_speed,
									    const_MidLevelSM_forward_angle,
									    const_MidLevelSM_left_angle,
									    const_MidLevelSM_right_angle,
									    const_MidLevelSM_turn_speed,
									    const_MidLevelSM_movesp,
									    const_MidLevelSM_stopsp) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(target_speed.out!const_MidLevelSM_turn_speed -> SKIP));true&(share__choice(speed_adjustment.in?speed_adj -> (SStop /\ set_speed_adj!speed_adj -> SKIP)));true&(share__choice(target_angle.out!const_MidLevelSM_right_angle -> SKIP));true&(share__choice(angle_adjustment.in?angle_adj -> (SStop /\ set_angle_adj!angle_adj -> SKIP)));share__choice(share__choice(get_angle_adj?angle_adj -> share__choice(get_speed_adj?speed_adj -> share__choice(get_lspeed?lspeed -> true & (share__choice(set_lspeed!Minus(Minus(lspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(share__choice(get_angle_adj?angle_adj -> share__choice(get_speed_adj?speed_adj -> share__choice(get_rspeed?rspeed -> true & (share__choice(set_rspeed!Plus(Minus(rspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(get_lspeed?lspeed -> true&CALL__output_left_motor(
											id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp,
											lspeed
										));share__choice(get_rspeed?rspeed -> true&CALL__output_right_motor(
											id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp,
											rspeed
										)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_MidLevelSM_step,
									    const_MidLevelSM_climb_speed,
									    const_MidLevelSM_descent_speed,
									    const_MidLevelSM_side_speed,
									    const_MidLevelSM_forward_angle,
									    const_MidLevelSM_left_angle,
									    const_MidLevelSM_right_angle,
									    const_MidLevelSM_turn_speed,
									    const_MidLevelSM_movesp,
									    const_MidLevelSM_stopsp) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(target_speed.out!const_MidLevelSM_turn_speed -> SKIP));true&(share__choice(speed_adjustment.in?speed_adj -> (SStop /\ set_speed_adj!speed_adj -> SKIP)));true&(share__choice(target_angle.out!const_MidLevelSM_right_angle -> SKIP));true&(share__choice(angle_adjustment.in?angle_adj -> (SStop /\ set_angle_adj!angle_adj -> SKIP)));share__choice(share__choice(get_angle_adj?angle_adj -> share__choice(get_speed_adj?speed_adj -> share__choice(get_lspeed?lspeed -> true & (share__choice(set_lspeed!Minus(Minus(lspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(share__choice(get_angle_adj?angle_adj -> share__choice(get_speed_adj?speed_adj -> share__choice(get_rspeed?rspeed -> true & (share__choice(set_rspeed!Plus(Minus(rspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(get_lspeed?lspeed -> true&CALL__output_left_motor(
											id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp,
											lspeed
										));share__choice(get_rspeed?rspeed -> true&CALL__output_right_motor(
											id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp,
											rspeed
										)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Go_down
					module Go_down
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_MidLevelSM_step,
									    const_MidLevelSM_climb_speed,
									    const_MidLevelSM_descent_speed,
									    const_MidLevelSM_side_speed,
									    const_MidLevelSM_forward_angle,
									    const_MidLevelSM_left_angle,
									    const_MidLevelSM_right_angle,
									    const_MidLevelSM_turn_speed,
									    const_MidLevelSM_movesp,
									    const_MidLevelSM_stopsp) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(target_speed.out!const_MidLevelSM_descent_speed -> SKIP));true&(share__choice(speed_adjustment.in?speed_adj -> (SStop /\ set_speed_adj!speed_adj -> SKIP)));true&(share__choice(target_angle.out!const_MidLevelSM_forward_angle -> SKIP));true&(share__choice(angle_adjustment.in?angle_adj -> (SStop /\ set_angle_adj!angle_adj -> SKIP)));share__choice(share__choice(get_angle_adj?angle_adj -> share__choice(get_speed_adj?speed_adj -> share__choice(get_lspeed?lspeed -> true & (share__choice(set_lspeed!Minus(Minus(lspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(share__choice(get_angle_adj?angle_adj -> share__choice(get_speed_adj?speed_adj -> share__choice(get_rspeed?rspeed -> true & (share__choice(set_rspeed!Plus(Minus(rspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(get_lspeed?lspeed -> true&CALL__output_left_motor(
											id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp,
											lspeed
										));share__choice(get_rspeed?rspeed -> true&CALL__output_right_motor(
											id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp,
											rspeed
										)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_MidLevelSM_step,
									    const_MidLevelSM_climb_speed,
									    const_MidLevelSM_descent_speed,
									    const_MidLevelSM_side_speed,
									    const_MidLevelSM_forward_angle,
									    const_MidLevelSM_left_angle,
									    const_MidLevelSM_right_angle,
									    const_MidLevelSM_turn_speed,
									    const_MidLevelSM_movesp,
									    const_MidLevelSM_stopsp) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(target_speed.out!const_MidLevelSM_descent_speed -> SKIP));true&(share__choice(speed_adjustment.in?speed_adj -> (SStop /\ set_speed_adj!speed_adj -> SKIP)));true&(share__choice(target_angle.out!const_MidLevelSM_forward_angle -> SKIP));true&(share__choice(angle_adjustment.in?angle_adj -> (SStop /\ set_angle_adj!angle_adj -> SKIP)));share__choice(share__choice(get_angle_adj?angle_adj -> share__choice(get_speed_adj?speed_adj -> share__choice(get_lspeed?lspeed -> true & (share__choice(set_lspeed!Minus(Minus(lspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(share__choice(get_angle_adj?angle_adj -> share__choice(get_speed_adj?speed_adj -> share__choice(get_rspeed?rspeed -> true & (share__choice(set_rspeed!Plus(Minus(rspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(get_lspeed?lspeed -> true&CALL__output_left_motor(
											id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp,
											lspeed
										));share__choice(get_rspeed?rspeed -> true&CALL__output_right_motor(
											id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp,
											rspeed
										)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Turn_left
					module Turn_left
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_MidLevelSM_step,
									    const_MidLevelSM_climb_speed,
									    const_MidLevelSM_descent_speed,
									    const_MidLevelSM_side_speed,
									    const_MidLevelSM_forward_angle,
									    const_MidLevelSM_left_angle,
									    const_MidLevelSM_right_angle,
									    const_MidLevelSM_turn_speed,
									    const_MidLevelSM_movesp,
									    const_MidLevelSM_stopsp) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(target_speed.out!const_MidLevelSM_turn_speed -> SKIP));true&(share__choice(speed_adjustment.in?speed_adj -> (SStop /\ set_speed_adj!speed_adj -> SKIP)));true&(share__choice(target_angle.out!const_MidLevelSM_left_angle -> SKIP));true&(share__choice(angle_adjustment.in?angle_adj -> (SStop /\ set_angle_adj!angle_adj -> SKIP)));share__choice(share__choice(get_angle_adj?angle_adj -> share__choice(get_speed_adj?speed_adj -> share__choice(get_lspeed?lspeed -> true & (share__choice(set_lspeed!Minus(Minus(lspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(share__choice(get_angle_adj?angle_adj -> share__choice(get_speed_adj?speed_adj -> share__choice(get_rspeed?rspeed -> true & (share__choice(set_rspeed!Plus(Minus(rspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(get_lspeed?lspeed -> true&CALL__output_left_motor(
											id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp,
											lspeed
										));share__choice(get_rspeed?rspeed -> true&CALL__output_right_motor(
											id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp,
											rspeed
										)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_MidLevelSM_step,
									    const_MidLevelSM_climb_speed,
									    const_MidLevelSM_descent_speed,
									    const_MidLevelSM_side_speed,
									    const_MidLevelSM_forward_angle,
									    const_MidLevelSM_left_angle,
									    const_MidLevelSM_right_angle,
									    const_MidLevelSM_turn_speed,
									    const_MidLevelSM_movesp,
									    const_MidLevelSM_stopsp) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(target_speed.out!const_MidLevelSM_turn_speed -> SKIP));true&(share__choice(speed_adjustment.in?speed_adj -> (SStop /\ set_speed_adj!speed_adj -> SKIP)));true&(share__choice(target_angle.out!const_MidLevelSM_left_angle -> SKIP));true&(share__choice(angle_adjustment.in?angle_adj -> (SStop /\ set_angle_adj!angle_adj -> SKIP)));share__choice(share__choice(get_angle_adj?angle_adj -> share__choice(get_speed_adj?speed_adj -> share__choice(get_lspeed?lspeed -> true & (share__choice(set_lspeed!Minus(Minus(lspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(share__choice(get_angle_adj?angle_adj -> share__choice(get_speed_adj?speed_adj -> share__choice(get_rspeed?rspeed -> true & (share__choice(set_rspeed!Plus(Minus(rspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(get_lspeed?lspeed -> true&CALL__output_left_motor(
											id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp,
											lspeed
										));share__choice(get_rspeed?rspeed -> true&CALL__output_right_motor(
											id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp,
											rspeed
										)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Go_side
					module Go_side
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_MidLevelSM_step,
									    const_MidLevelSM_climb_speed,
									    const_MidLevelSM_descent_speed,
									    const_MidLevelSM_side_speed,
									    const_MidLevelSM_forward_angle,
									    const_MidLevelSM_left_angle,
									    const_MidLevelSM_right_angle,
									    const_MidLevelSM_turn_speed,
									    const_MidLevelSM_movesp,
									    const_MidLevelSM_stopsp) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(target_speed.out!const_MidLevelSM_side_speed -> SKIP));true&(share__choice(speed_adjustment.in?speed_adj -> (SStop /\ set_speed_adj!speed_adj -> SKIP)));true&(share__choice(target_angle.out!const_MidLevelSM_forward_angle -> SKIP));true&(share__choice(angle_adjustment.in?angle_adj -> (SStop /\ set_angle_adj!angle_adj -> SKIP)));share__choice(share__choice(get_angle_adj?angle_adj -> share__choice(get_speed_adj?speed_adj -> share__choice(get_lspeed?lspeed -> true & (share__choice(set_lspeed!Minus(Minus(lspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(share__choice(get_angle_adj?angle_adj -> share__choice(get_speed_adj?speed_adj -> share__choice(get_rspeed?rspeed -> true & (share__choice(set_rspeed!Plus(Minus(rspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(get_lspeed?lspeed -> true&CALL__output_left_motor(
											id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp,
											lspeed
										));share__choice(get_rspeed?rspeed -> true&CALL__output_right_motor(
											id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp,
											rspeed
										)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_MidLevelSM_step,
									    const_MidLevelSM_climb_speed,
									    const_MidLevelSM_descent_speed,
									    const_MidLevelSM_side_speed,
									    const_MidLevelSM_forward_angle,
									    const_MidLevelSM_left_angle,
									    const_MidLevelSM_right_angle,
									    const_MidLevelSM_turn_speed,
									    const_MidLevelSM_movesp,
									    const_MidLevelSM_stopsp) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(target_speed.out!const_MidLevelSM_side_speed -> SKIP));true&(share__choice(speed_adjustment.in?speed_adj -> (SStop /\ set_speed_adj!speed_adj -> SKIP)));true&(share__choice(target_angle.out!const_MidLevelSM_forward_angle -> SKIP));true&(share__choice(angle_adjustment.in?angle_adj -> (SStop /\ set_angle_adj!angle_adj -> SKIP)));share__choice(share__choice(get_angle_adj?angle_adj -> share__choice(get_speed_adj?speed_adj -> share__choice(get_lspeed?lspeed -> true & (share__choice(set_lspeed!Minus(Minus(lspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(share__choice(get_angle_adj?angle_adj -> share__choice(get_speed_adj?speed_adj -> share__choice(get_rspeed?rspeed -> true & (share__choice(set_rspeed!Plus(Minus(rspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(get_lspeed?lspeed -> true&CALL__output_left_motor(
											id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp,
											lspeed
										));share__choice(get_rspeed?rspeed -> true&CALL__output_right_motor(
											id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp,
											rspeed
										)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Stop
					module Stop
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_MidLevelSM_step,
									    const_MidLevelSM_climb_speed,
									    const_MidLevelSM_descent_speed,
									    const_MidLevelSM_side_speed,
									    const_MidLevelSM_forward_angle,
									    const_MidLevelSM_left_angle,
									    const_MidLevelSM_right_angle,
									    const_MidLevelSM_turn_speed,
									    const_MidLevelSM_movesp,
									    const_MidLevelSM_stopsp) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(target_speed.out!const_MidLevelSM_turn_speed -> SKIP));true&(share__choice(speed_adjustment.in?speed_adj -> (SStop /\ set_speed_adj!speed_adj -> SKIP)));true&(share__choice(target_angle.out!const_MidLevelSM_forward_angle -> SKIP));true&(share__choice(angle_adjustment.in?angle_adj -> (SStop /\ set_angle_adj!angle_adj -> SKIP)));share__choice(share__choice(get_angle_adj?angle_adj -> share__choice(get_speed_adj?speed_adj -> share__choice(get_lspeed?lspeed -> true & (share__choice(set_lspeed!Minus(Minus(lspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(share__choice(get_angle_adj?angle_adj -> share__choice(get_speed_adj?speed_adj -> share__choice(get_rspeed?rspeed -> true & (share__choice(set_rspeed!Plus(Minus(rspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(get_lspeed?lspeed -> true&CALL__output_left_motor(
											id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp,
											lspeed
										));share__choice(get_rspeed?rspeed -> true&CALL__output_right_motor(
											id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp,
											rspeed
										)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_MidLevelSM_step,
									    const_MidLevelSM_climb_speed,
									    const_MidLevelSM_descent_speed,
									    const_MidLevelSM_side_speed,
									    const_MidLevelSM_forward_angle,
									    const_MidLevelSM_left_angle,
									    const_MidLevelSM_right_angle,
									    const_MidLevelSM_turn_speed,
									    const_MidLevelSM_movesp,
									    const_MidLevelSM_stopsp) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(target_speed.out!const_MidLevelSM_turn_speed -> SKIP));true&(share__choice(speed_adjustment.in?speed_adj -> (SStop /\ set_speed_adj!speed_adj -> SKIP)));true&(share__choice(target_angle.out!const_MidLevelSM_forward_angle -> SKIP));true&(share__choice(angle_adjustment.in?angle_adj -> (SStop /\ set_angle_adj!angle_adj -> SKIP)));share__choice(share__choice(get_angle_adj?angle_adj -> share__choice(get_speed_adj?speed_adj -> share__choice(get_lspeed?lspeed -> true & (share__choice(set_lspeed!Minus(Minus(lspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(share__choice(get_angle_adj?angle_adj -> share__choice(get_speed_adj?speed_adj -> share__choice(get_rspeed?rspeed -> true & (share__choice(set_rspeed!Plus(Minus(rspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(get_lspeed?lspeed -> true&CALL__output_left_motor(
											id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp,
											lspeed
										));share__choice(get_rspeed?rspeed -> true&CALL__output_right_motor(
											id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp,
											rspeed
										)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					CALL__output_right_motor(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp,
								param_x) = EDeadline(output_right_motorCall.param_x,0)
					CALL__output_left_motor(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp,
								param_x) = EDeadline(output_left_motorCall.param_x,0)
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					STM_VS_O(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__,
										    const_MidLevelSM_step,
										    const_MidLevelSM_climb_speed,
										    const_MidLevelSM_descent_speed,
										    const_MidLevelSM_side_speed,
										    const_MidLevelSM_forward_angle,
										    const_MidLevelSM_left_angle,
										    const_MidLevelSM_right_angle,
										    const_MidLevelSM_turn_speed,
										    const_MidLevelSM_movesp,
										    const_MidLevelSM_stopsp) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					-- Transitions
					Transitions(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = ((let
						Trans = share__choice(get_CLID_Turn_right?Turn_right:CLID_Turn_right_clock_type(id__,
								          const_MidLevelSM_step,
								          const_MidLevelSM_climb_speed,
								          const_MidLevelSM_descent_speed,
								          const_MidLevelSM_side_speed,
								          const_MidLevelSM_forward_angle,
								          const_MidLevelSM_left_angle,
								          const_MidLevelSM_right_angle,
								          const_MidLevelSM_turn_speed,
								          const_MidLevelSM_movesp,
								          const_MidLevelSM_stopsp) -> get_orientation?orientation -> get_CLID_Go_up?Go_up:CLID_Go_up_clock_type(id__,
								          const_MidLevelSM_step,
								          const_MidLevelSM_climb_speed,
								          const_MidLevelSM_descent_speed,
								          const_MidLevelSM_side_speed,
								          const_MidLevelSM_forward_angle,
								          const_MidLevelSM_left_angle,
								          const_MidLevelSM_right_angle,
								          const_MidLevelSM_turn_speed,
								          const_MidLevelSM_movesp,
								          const_MidLevelSM_stopsp) -> get_direction?direction -> get_CLID_Stop?Stop:CLID_Stop_clock_type(id__,
								          const_MidLevelSM_step,
								          const_MidLevelSM_climb_speed,
								          const_MidLevelSM_descent_speed,
								          const_MidLevelSM_side_speed,
								          const_MidLevelSM_forward_angle,
								          const_MidLevelSM_left_angle,
								          const_MidLevelSM_right_angle,
								          const_MidLevelSM_turn_speed,
								          const_MidLevelSM_movesp,
								          const_MidLevelSM_stopsp) -> get_CLID_Turn_left?Turn_left:CLID_Turn_left_clock_type(id__,
								          const_MidLevelSM_step,
								          const_MidLevelSM_climb_speed,
								          const_MidLevelSM_descent_speed,
								          const_MidLevelSM_side_speed,
								          const_MidLevelSM_forward_angle,
								          const_MidLevelSM_left_angle,
								          const_MidLevelSM_right_angle,
								          const_MidLevelSM_turn_speed,
								          const_MidLevelSM_movesp,
								          const_MidLevelSM_stopsp) -> get_CLID_Go_down?Go_down:CLID_Go_down_clock_type(id__,
								          const_MidLevelSM_step,
								          const_MidLevelSM_climb_speed,
								          const_MidLevelSM_descent_speed,
								          const_MidLevelSM_side_speed,
								          const_MidLevelSM_forward_angle,
								          const_MidLevelSM_left_angle,
								          const_MidLevelSM_right_angle,
								          const_MidLevelSM_turn_speed,
								          const_MidLevelSM_movesp,
								          const_MidLevelSM_stopsp) -> TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((turn__!NID_Go_up.in?direction:{direction|direction <- Direction, (direction==Direction_right)} -> share__choice(set_direction!direction -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_orientation?orientation -> true & (share__choice(set_orientation!turn_right(orientation) -> SKIP))));share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_stopsp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_stopsp -> SKIP))) ; Turn_right::enter -> SKIP)))
							 [] dbisim((((orientation==Orientation_left) or (orientation==Orientation_right)))&(move_forward__!NID_Turn_right.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_movesp -> SKIP)));share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_movesp -> SKIP))) ; Go_side::enter -> SKIP)))
							 [] dbisim((turn__!NID_Go_up.in?direction:{direction|direction <- Direction, (direction==Direction_left)} -> share__choice(set_direction!direction -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_orientation?orientation -> true & (share__choice(set_orientation!turn_left(orientation) -> SKIP))));share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_stopsp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_stopsp -> SKIP))) ; Turn_left::enter -> SKIP)))
							 [] dbisim((turn__!NID_Turn_right.in?direction:{direction|direction <- Direction, (direction==Direction_right)} -> share__choice(set_direction!direction -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_orientation?orientation -> true & (share__choice(set_orientation!turn_right(orientation) -> SKIP)))) ; Turn_right::enter -> SKIP)))
							 [] dbisim((((orientation==Orientation_left) or (orientation==Orientation_right)))&(move_forward__!NID_Turn_left.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_movesp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_movesp -> SKIP))) ; Go_side::enter -> SKIP)))
							 [] dbisim((turn__!NID_Turn_left.in?direction:{direction|direction <- Direction, (direction==Direction_left)} -> share__choice(set_direction!direction -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_orientation?orientation -> true & (share__choice(set_orientation!turn_left(orientation) -> SKIP)))) ; Turn_left::enter -> SKIP)))
							 [] dbisim(((orientation==Orientation_up))&(move_forward__!NID_Turn_right.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_movesp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_movesp -> SKIP))) ; Go_up::enter -> SKIP)))
							 [] dbisim(((orientation==Orientation_down))&(move_forward__!NID_Turn_right.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_movesp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_movesp -> SKIP))) ; Go_down::enter -> SKIP)))
							 [] dbisim(((orientation==Orientation_up))&(move_forward__!NID_Turn_left.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_movesp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_movesp -> SKIP))) ; Go_up::enter -> SKIP)))
							 [] dbisim(((orientation==Orientation_down))&(move_forward__!NID_Turn_left.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_movesp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_movesp -> SKIP))) ; Go_down::enter -> SKIP)))
							 [] dbisim((turn__!NID_Go_side.in?direction:{direction|direction <- Direction, (direction==Direction_left)} -> share__choice(set_direction!direction -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_orientation?orientation -> true & (share__choice(set_orientation!turn_left(orientation) -> SKIP))));share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_stopsp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_stopsp -> SKIP))) ; Turn_left::enter -> SKIP)))
							 [] dbisim((turn__!NID_Go_side.in?direction:{direction|direction <- Direction, (direction==Direction_right)} -> share__choice(set_direction!direction -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_orientation?orientation -> true & (share__choice(set_orientation!turn_right(orientation) -> SKIP))));share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_stopsp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_stopsp -> SKIP))) ; Turn_right::enter -> SKIP)))
							 [] dbisim((turn__!NID_Go_down.in?direction:{direction|direction <- Direction, (direction==Direction_left)} -> share__choice(set_direction!direction -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_orientation?orientation -> true & (share__choice(set_orientation!turn_left(orientation) -> SKIP))));share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_stopsp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_stopsp -> SKIP))) ; Turn_left::enter -> SKIP)))
							 [] dbisim((turn__!NID_Go_down.in?direction:{direction|direction <- Direction, (direction==Direction_right)} -> share__choice(set_direction!direction -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_orientation?orientation -> true & (share__choice(set_orientation!turn_right(orientation) -> SKIP))));share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_stopsp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_stopsp -> SKIP))) ; Turn_right::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((share__choice(true & (share__choice(set_orientation!Orientation_up -> SKIP)));share__choice(true & (share__choice(set_lspeed!0 -> SKIP)));share__choice(true & (share__choice(set_rspeed!0 -> SKIP))) ; Go_up::enter -> SKIP))))
							 [] dbisim((turn__!NID_Turn_right.in?direction:{direction|direction <- Direction, (direction==Direction_left)} -> share__choice(set_direction!direction -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_orientation?orientation -> true & (share__choice(set_orientation!turn_left(orientation) -> SKIP)))) ; Turn_left::enter -> SKIP)))
							 [] dbisim((turn__!NID_Turn_left.in?direction:{direction|direction <- Direction, (direction==Direction_right)} -> share__choice(set_direction!direction -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_orientation?orientation -> true & (share__choice(set_orientation!turn_right(orientation) -> SKIP)))) ; Turn_right::enter -> SKIP)))
							 [] dbisim((true)&(stop__!NID_Go_up.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_stopsp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_stopsp -> SKIP))) ; Stop::enter -> SKIP)))
							 [] dbisim((true)&(stop__!NID_Go_down.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_stopsp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_stopsp -> SKIP))) ; Stop::enter -> SKIP)))
							 [] dbisim((true)&(stop__!NID_Go_side.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_stopsp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_stopsp -> SKIP))) ; Stop::enter -> SKIP)))
							 [] dbisim((turn__!NID_Stop.in?direction:{direction|direction <- Direction, (direction==Direction_right)} -> share__choice(set_direction!direction -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_orientation?orientation -> true & (share__choice(set_orientation!turn_right(orientation) -> SKIP)))) ; Turn_right::enter -> SKIP)))
							 [] dbisim((turn__!NID_Stop.in?direction:{direction|direction <- Direction, (direction==Direction_left)} -> share__choice(set_direction!direction -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_orientation?orientation -> true & (share__choice(set_orientation!turn_left(orientation) -> SKIP)))) ; Turn_left::enter -> SKIP)))
							 [] dbisim(((Turn_right>=const_MidLevelSM_step))&(internal__!NID_Turn_right -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Turn_right::enter -> SKIP)))
							 [] dbisim(((Turn_left>=const_MidLevelSM_step))&(internal__!NID_Go_side -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Go_side::enter -> SKIP)))
							 [] dbisim(((Go_up>=const_MidLevelSM_step))&(internal__!NID_Go_up -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Go_up::enter -> SKIP)))
							 [] dbisim(((Turn_left>=const_MidLevelSM_step))&(internal__!NID_Turn_left -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Turn_left::enter -> SKIP)))
							 [] dbisim(((Stop>=const_MidLevelSM_step))&(internal__!NID_Stop -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Stop::enter -> SKIP)))
							 [] dbisim(((Go_down>=const_MidLevelSM_step))&(internal__!NID_Go_down -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Go_down::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
						)
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Go_up::enter,
								Turn_right::enter,
								Go_down::enter,
								Turn_left::enter,
								Go_side::enter,
								Stop::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|turn__.NID_Go_up.in,move_forward__.NID_Turn_right.in,turn__.NID_Go_up.in,turn__.NID_Turn_right.in,move_forward__.NID_Turn_left.in,turn__.NID_Turn_left.in,move_forward__.NID_Turn_right.in,move_forward__.NID_Turn_right.in,move_forward__.NID_Turn_left.in,move_forward__.NID_Turn_left.in,turn__.NID_Go_side.in,turn__.NID_Go_side.in,turn__.NID_Go_down.in,turn__.NID_Go_down.in,internal__.NID_i0,turn__.NID_Turn_right.in,turn__.NID_Turn_left.in,stop__.NID_Go_up.in,stop__.NID_Go_down.in,stop__.NID_Go_side.in,turn__.NID_Stop.in,turn__.NID_Stop.in,internal__.NID_Turn_right,internal__.NID_Go_side,internal__.NID_Go_up,internal__.NID_Turn_left,internal__.NID_Stop,internal__.NID_Go_down|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__,
									   		    const_MidLevelSM_step,
									   		    const_MidLevelSM_climb_speed,
									   		    const_MidLevelSM_descent_speed,
									   		    const_MidLevelSM_side_speed,
									   		    const_MidLevelSM_forward_angle,
									   		    const_MidLevelSM_left_angle,
									   		    const_MidLevelSM_right_angle,
									   		    const_MidLevelSM_turn_speed,
									   		    const_MidLevelSM_movesp,
									   		    const_MidLevelSM_stopsp)
									   [| { share__, terminate } |] (
									   Go_up::D__(id__,
									   		    const_MidLevelSM_step,
									   		    const_MidLevelSM_climb_speed,
									   		    const_MidLevelSM_descent_speed,
									   		    const_MidLevelSM_side_speed,
									   		    const_MidLevelSM_forward_angle,
									   		    const_MidLevelSM_left_angle,
									   		    const_MidLevelSM_right_angle,
									   		    const_MidLevelSM_turn_speed,
									   		    const_MidLevelSM_movesp,
									   		    const_MidLevelSM_stopsp)
									   [| { share__, terminate } |] (
									   Turn_right::D__(id__,
									   		    const_MidLevelSM_step,
									   		    const_MidLevelSM_climb_speed,
									   		    const_MidLevelSM_descent_speed,
									   		    const_MidLevelSM_side_speed,
									   		    const_MidLevelSM_forward_angle,
									   		    const_MidLevelSM_left_angle,
									   		    const_MidLevelSM_right_angle,
									   		    const_MidLevelSM_turn_speed,
									   		    const_MidLevelSM_movesp,
									   		    const_MidLevelSM_stopsp)
									   [| { share__, terminate } |] (
									   Go_down::D__(id__,
									   		    const_MidLevelSM_step,
									   		    const_MidLevelSM_climb_speed,
									   		    const_MidLevelSM_descent_speed,
									   		    const_MidLevelSM_side_speed,
									   		    const_MidLevelSM_forward_angle,
									   		    const_MidLevelSM_left_angle,
									   		    const_MidLevelSM_right_angle,
									   		    const_MidLevelSM_turn_speed,
									   		    const_MidLevelSM_movesp,
									   		    const_MidLevelSM_stopsp)
									   [| { share__, terminate } |] (
									   Turn_left::D__(id__,
									   		    const_MidLevelSM_step,
									   		    const_MidLevelSM_climb_speed,
									   		    const_MidLevelSM_descent_speed,
									   		    const_MidLevelSM_side_speed,
									   		    const_MidLevelSM_forward_angle,
									   		    const_MidLevelSM_left_angle,
									   		    const_MidLevelSM_right_angle,
									   		    const_MidLevelSM_turn_speed,
									   		    const_MidLevelSM_movesp,
									   		    const_MidLevelSM_stopsp)
									   [| { share__, terminate } |] (
									   Go_side::D__(id__,
									   		    const_MidLevelSM_step,
									   		    const_MidLevelSM_climb_speed,
									   		    const_MidLevelSM_descent_speed,
									   		    const_MidLevelSM_side_speed,
									   		    const_MidLevelSM_forward_angle,
									   		    const_MidLevelSM_left_angle,
									   		    const_MidLevelSM_right_angle,
									   		    const_MidLevelSM_turn_speed,
									   		    const_MidLevelSM_movesp,
									   		    const_MidLevelSM_stopsp)
									   [| { share__, terminate } |] (
									   Stop::D__(id__,
									   		    const_MidLevelSM_step,
									   		    const_MidLevelSM_climb_speed,
									   		    const_MidLevelSM_descent_speed,
									   		    const_MidLevelSM_side_speed,
									   		    const_MidLevelSM_forward_angle,
									   		    const_MidLevelSM_left_angle,
									   		    const_MidLevelSM_right_angle,
									   		    const_MidLevelSM_turn_speed,
									   		    const_MidLevelSM_movesp,
									   		    const_MidLevelSM_stopsp)
									   )
									   )
									   )
									   )
									   )
									   )
									 )
									 [[Go_up::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_Go_up.in,turn__.NID_Go_up.in,stop__.NID_Go_up.in,internal__.NID_Go_up|}]]
									 [[Turn_right::interrupt <- x__ | x__ <- {|interrupt,move_forward__.NID_Turn_right.in,turn__.NID_Turn_right.in,move_forward__.NID_Turn_right.in,move_forward__.NID_Turn_right.in,turn__.NID_Turn_right.in,internal__.NID_Turn_right|}]]
									 [[Go_down::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_Go_down.in,turn__.NID_Go_down.in,stop__.NID_Go_down.in,internal__.NID_Go_down|}]]
									 [[Turn_left::interrupt <- x__ | x__ <- {|interrupt,move_forward__.NID_Turn_left.in,turn__.NID_Turn_left.in,move_forward__.NID_Turn_left.in,move_forward__.NID_Turn_left.in,turn__.NID_Turn_left.in,internal__.NID_Turn_left|}]]
									 [[Go_side::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_Go_side.in,turn__.NID_Go_side.in,stop__.NID_Go_side.in,internal__.NID_Go_side|}]]
									 [[Stop::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_Stop.in,turn__.NID_Stop.in,internal__.NID_Stop|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_direction |} ]] 
									  [[Turn_right::entered <- Turn_right::enteredL,set_orientation <- setL_orientation,Go_up::entered <- Go_up::enteredL,set_direction <- setL_direction,Stop::entered <- Stop::enteredL,Turn_left::entered <- Turn_left::enteredL,Go_down::entered <- Go_down::enteredL]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,Turn_right::enteredL
									 			,setL_orientation
									 			,Go_up::enteredL
									 			,setL_direction
									 			,Stop::enteredL
									 			,Turn_left::enteredL
									 			,Go_down::enteredL
									 			,setR_direction
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_MidLevelSM_step,
									 		    const_MidLevelSM_climb_speed,
									 		    const_MidLevelSM_descent_speed,
									 		    const_MidLevelSM_side_speed,
									 		    const_MidLevelSM_forward_angle,
									 		    const_MidLevelSM_left_angle,
									 		    const_MidLevelSM_right_angle,
									 		    const_MidLevelSM_turn_speed,
									 		    const_MidLevelSM_movesp,
									 		    const_MidLevelSM_stopsp))
									  [[ share__ <- x__ | x__ <- {| share__,Turn_right::enteredL,setL_orientation,Go_up::enteredL,setL_direction,Stop::enteredL,Turn_left::enteredL,Go_down::enteredL |} ]]
									  [[set_direction <- setR_direction]]
									 )
									)[[Turn_right::enteredL <- Turn_right::entered,setL_orientation <- set_orientation,Go_up::enteredL <- Go_up::entered,setL_direction <- set_direction,Stop::enteredL <- Stop::entered,Turn_left::enteredL <- Turn_left::entered,Go_down::enteredL <- Go_down::entered]]
									 [[setR_direction <- set_direction]]
									)
								)
								 \ hideSet)
								[[
									target_speed__.x____ <- target_speed,
									target_angle__.x____ <- target_angle,
									speed_adjustment__.x____ <- speed_adjustment,
									angle_adjustment__.x____ <- angle_adjustment,
									move_forward__.x____ <- move_forward,
									turn__.x____ <- turn,
									stop__.x____ <- stop
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_MidLevelSM_step,
							 		          const_MidLevelSM_climb_speed,
							 		          const_MidLevelSM_descent_speed,
							 		          const_MidLevelSM_side_speed,
							 		          const_MidLevelSM_forward_angle,
							 		          const_MidLevelSM_left_angle,
							 		          const_MidLevelSM_right_angle,
							 		          const_MidLevelSM_turn_speed,
							 		          const_MidLevelSM_movesp,
							 		          const_MidLevelSM_stopsp)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = 
						dbisim((let
							stateClockSync = {|get_CLID_Turn_right,Turn_right::entered,get_CLID_Go_up,Go_up::entered,get_CLID_Stop,Stop::entered,get_CLID_Turn_left,Turn_left::entered,get_CLID_Go_down,Go_down::entered,get_CLID_Go_side,Go_side::entered|}
						 within
							(MachineBody(id__,
									    const_MidLevelSM_step,
									    const_MidLevelSM_climb_speed,
									    const_MidLevelSM_descent_speed,
									    const_MidLevelSM_side_speed,
									    const_MidLevelSM_forward_angle,
									    const_MidLevelSM_left_angle,
									    const_MidLevelSM_right_angle,
									    const_MidLevelSM_turn_speed,
									    const_MidLevelSM_movesp,
									    const_MidLevelSM_stopsp) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = 
						dbisim((let
							stateClockSync = {|get_CLID_Turn_right,Turn_right::entered,get_CLID_Go_up,Go_up::entered,get_CLID_Stop,Stop::entered,get_CLID_Turn_left,Turn_left::entered,get_CLID_Go_down,Go_down::entered,get_CLID_Go_side,Go_side::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															dbisim(
																sbisim(
																	dbisim(
																		sbisim(
																			MachineBody(id__,
																					    const_MidLevelSM_step,
																					    const_MidLevelSM_climb_speed,
																					    const_MidLevelSM_descent_speed,
																					    const_MidLevelSM_side_speed,
																					    const_MidLevelSM_forward_angle,
																					    const_MidLevelSM_left_angle,
																					    const_MidLevelSM_right_angle,
																					    const_MidLevelSM_turn_speed,
																					    const_MidLevelSM_movesp,
																					    const_MidLevelSM_stopsp)
																			[| {|get_CLID_Go_side,Go_side::entered,terminate|} |]
																			dbisim(Clock_CLID_Go_side(id__,0,
																					          const_MidLevelSM_step,
																					          const_MidLevelSM_climb_speed,
																					          const_MidLevelSM_descent_speed,
																					          const_MidLevelSM_side_speed,
																					          const_MidLevelSM_forward_angle,
																					          const_MidLevelSM_left_angle,
																					          const_MidLevelSM_right_angle,
																					          const_MidLevelSM_turn_speed,
																					          const_MidLevelSM_movesp,
																					          const_MidLevelSM_stopsp))
																		)\{|get_CLID_Go_side|}
																	)
																	[| {|get_CLID_Go_down,Go_down::entered,terminate|} |]
																	dbisim(Clock_CLID_Go_down(id__,0,
																			          const_MidLevelSM_step,
																			          const_MidLevelSM_climb_speed,
																			          const_MidLevelSM_descent_speed,
																			          const_MidLevelSM_side_speed,
																			          const_MidLevelSM_forward_angle,
																			          const_MidLevelSM_left_angle,
																			          const_MidLevelSM_right_angle,
																			          const_MidLevelSM_turn_speed,
																			          const_MidLevelSM_movesp,
																			          const_MidLevelSM_stopsp))
																)\{|get_CLID_Go_down|}
															)
															[| {|get_CLID_Turn_left,Turn_left::entered,terminate|} |]
															dbisim(Clock_CLID_Turn_left(id__,0,
																	          const_MidLevelSM_step,
																	          const_MidLevelSM_climb_speed,
																	          const_MidLevelSM_descent_speed,
																	          const_MidLevelSM_side_speed,
																	          const_MidLevelSM_forward_angle,
																	          const_MidLevelSM_left_angle,
																	          const_MidLevelSM_right_angle,
																	          const_MidLevelSM_turn_speed,
																	          const_MidLevelSM_movesp,
																	          const_MidLevelSM_stopsp))
														)\{|get_CLID_Turn_left|}
													)
													[| {|get_CLID_Stop,Stop::entered,terminate|} |]
													dbisim(Clock_CLID_Stop(id__,0,
															          const_MidLevelSM_step,
															          const_MidLevelSM_climb_speed,
															          const_MidLevelSM_descent_speed,
															          const_MidLevelSM_side_speed,
															          const_MidLevelSM_forward_angle,
															          const_MidLevelSM_left_angle,
															          const_MidLevelSM_right_angle,
															          const_MidLevelSM_turn_speed,
															          const_MidLevelSM_movesp,
															          const_MidLevelSM_stopsp))
												)\{|get_CLID_Stop|}
											)
											[| {|get_CLID_Go_up,Go_up::entered,terminate|} |]
											dbisim(Clock_CLID_Go_up(id__,0,
													          const_MidLevelSM_step,
													          const_MidLevelSM_climb_speed,
													          const_MidLevelSM_descent_speed,
													          const_MidLevelSM_side_speed,
													          const_MidLevelSM_forward_angle,
													          const_MidLevelSM_left_angle,
													          const_MidLevelSM_right_angle,
													          const_MidLevelSM_turn_speed,
													          const_MidLevelSM_movesp,
													          const_MidLevelSM_stopsp))
										)\{|get_CLID_Go_up|}
									)
									[| {|get_CLID_Turn_right,Turn_right::entered,terminate|} |]
									dbisim(Clock_CLID_Turn_right(id__,0,
											          const_MidLevelSM_step,
											          const_MidLevelSM_climb_speed,
											          const_MidLevelSM_descent_speed,
											          const_MidLevelSM_side_speed,
											          const_MidLevelSM_forward_angle,
											          const_MidLevelSM_left_angle,
											          const_MidLevelSM_right_angle,
											          const_MidLevelSM_turn_speed,
											          const_MidLevelSM_movesp,
											          const_MidLevelSM_stopsp))
								)\{|get_CLID_Turn_right|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = 
						((let
							getsetLocalChannels = {|get_lspeed,set_lspeed,
							get_rspeed,set_rspeed,
							get_angle,set_angle,
							get_speed_adj,set_speed_adj,
							get_angle_adj,set_angle_adj,
							get_direction,set_direction,
							get_orientation,set_orientation|}
							clockSync = {||}
						within
							(Behaviour(id__,
									    const_MidLevelSM_step,
									    const_MidLevelSM_climb_speed,
									    const_MidLevelSM_descent_speed,
									    const_MidLevelSM_side_speed,
									    const_MidLevelSM_forward_angle,
									    const_MidLevelSM_left_angle,
									    const_MidLevelSM_right_angle,
									    const_MidLevelSM_turn_speed,
									    const_MidLevelSM_movesp,
									    const_MidLevelSM_stopsp) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_MidLevelSM_step,
							 		    const_MidLevelSM_climb_speed,
							 		    const_MidLevelSM_descent_speed,
							 		    const_MidLevelSM_side_speed,
							 		    const_MidLevelSM_forward_angle,
							 		    const_MidLevelSM_left_angle,
							 		    const_MidLevelSM_right_angle,
							 		    const_MidLevelSM_turn_speed,
							 		    const_MidLevelSM_movesp,
							 		    const_MidLevelSM_stopsp) [| {terminate} |] Clocks(id__,
							 		          const_MidLevelSM_step,
							 		          const_MidLevelSM_climb_speed,
							 		          const_MidLevelSM_descent_speed,
							 		          const_MidLevelSM_side_speed,
							 		          const_MidLevelSM_forward_angle,
							 		          const_MidLevelSM_left_angle,
							 		          const_MidLevelSM_right_angle,
							 		          const_MidLevelSM_turn_speed,
							 		          const_MidLevelSM_movesp,
							 		          const_MidLevelSM_stopsp))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																dbisim(
																	sbisim(
																		dbisim(
																			sbisim(
																				IteratedBehaviour(id__,
																						    const_MidLevelSM_step,
																						    const_MidLevelSM_climb_speed,
																						    const_MidLevelSM_descent_speed,
																						    const_MidLevelSM_side_speed,
																						    const_MidLevelSM_forward_angle,
																						    const_MidLevelSM_left_angle,
																						    const_MidLevelSM_right_angle,
																						    const_MidLevelSM_turn_speed,
																						    const_MidLevelSM_movesp,
																						    const_MidLevelSM_stopsp)
																				[| {|get_orientation,set_orientation,terminate|} |]
																				Memory_orientation(Orientation_up)
																			)\{|get_orientation,set_orientation|}
																		)
																		[| {|get_direction,set_direction,terminate|} |]
																		Memory_direction(Direction_left)
																	)\{|get_direction,set_direction|}
																)
																[| {|get_angle_adj,set_angle_adj,terminate|} |]
																Memory_angle_adj(0)
															)\{|get_angle_adj,set_angle_adj|}
														)
														[| {|get_speed_adj,set_speed_adj,terminate|} |]
														Memory_speed_adj(0)
													)\{|get_speed_adj,set_speed_adj|}
												)
												[| {|get_angle,set_angle,terminate|} |]
												Memory_angle(0)
											)\{|get_angle,set_angle|}
										)
										[| {|get_rspeed,set_rspeed,terminate|} |]
										Memory_rspeed(0)
									)\{|get_rspeed,set_rspeed|}
								)
								[| {|get_lspeed,set_lspeed,terminate|} |]
								Memory_lspeed(0)
							)\{|get_lspeed,set_lspeed|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Go_up::enter,
								Turn_right::enter,
								Go_down::enter,
								Turn_left::enter,
								Go_side::enter,
								Stop::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|turn__.NID_Go_up.in,move_forward__.NID_Turn_right.in,turn__.NID_Go_up.in,turn__.NID_Turn_right.in,move_forward__.NID_Turn_left.in,turn__.NID_Turn_left.in,move_forward__.NID_Turn_right.in,move_forward__.NID_Turn_right.in,move_forward__.NID_Turn_left.in,move_forward__.NID_Turn_left.in,turn__.NID_Go_side.in,turn__.NID_Go_side.in,turn__.NID_Go_down.in,turn__.NID_Go_down.in,internal__.NID_i0,turn__.NID_Turn_right.in,turn__.NID_Turn_left.in,stop__.NID_Go_up.in,stop__.NID_Go_down.in,stop__.NID_Go_side.in,turn__.NID_Stop.in,turn__.NID_Stop.in,internal__.NID_Turn_right,internal__.NID_Go_side,internal__.NID_Go_up,internal__.NID_Turn_left,internal__.NID_Stop,internal__.NID_Go_down|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__,
									   		    const_MidLevelSM_step,
									   		    const_MidLevelSM_climb_speed,
									   		    const_MidLevelSM_descent_speed,
									   		    const_MidLevelSM_side_speed,
									   		    const_MidLevelSM_forward_angle,
									   		    const_MidLevelSM_left_angle,
									   		    const_MidLevelSM_right_angle,
									   		    const_MidLevelSM_turn_speed,
									   		    const_MidLevelSM_movesp,
									   		    const_MidLevelSM_stopsp)
									   [| { share__, terminate } |] (
									   Go_up::VS_O__(id__,
									   		    const_MidLevelSM_step,
									   		    const_MidLevelSM_climb_speed,
									   		    const_MidLevelSM_descent_speed,
									   		    const_MidLevelSM_side_speed,
									   		    const_MidLevelSM_forward_angle,
									   		    const_MidLevelSM_left_angle,
									   		    const_MidLevelSM_right_angle,
									   		    const_MidLevelSM_turn_speed,
									   		    const_MidLevelSM_movesp,
									   		    const_MidLevelSM_stopsp)
									   [| { share__, terminate } |] (
									   Turn_right::VS_O__(id__,
									   		    const_MidLevelSM_step,
									   		    const_MidLevelSM_climb_speed,
									   		    const_MidLevelSM_descent_speed,
									   		    const_MidLevelSM_side_speed,
									   		    const_MidLevelSM_forward_angle,
									   		    const_MidLevelSM_left_angle,
									   		    const_MidLevelSM_right_angle,
									   		    const_MidLevelSM_turn_speed,
									   		    const_MidLevelSM_movesp,
									   		    const_MidLevelSM_stopsp)
									   [| { share__, terminate } |] (
									   Go_down::VS_O__(id__,
									   		    const_MidLevelSM_step,
									   		    const_MidLevelSM_climb_speed,
									   		    const_MidLevelSM_descent_speed,
									   		    const_MidLevelSM_side_speed,
									   		    const_MidLevelSM_forward_angle,
									   		    const_MidLevelSM_left_angle,
									   		    const_MidLevelSM_right_angle,
									   		    const_MidLevelSM_turn_speed,
									   		    const_MidLevelSM_movesp,
									   		    const_MidLevelSM_stopsp)
									   [| { share__, terminate } |] (
									   Turn_left::VS_O__(id__,
									   		    const_MidLevelSM_step,
									   		    const_MidLevelSM_climb_speed,
									   		    const_MidLevelSM_descent_speed,
									   		    const_MidLevelSM_side_speed,
									   		    const_MidLevelSM_forward_angle,
									   		    const_MidLevelSM_left_angle,
									   		    const_MidLevelSM_right_angle,
									   		    const_MidLevelSM_turn_speed,
									   		    const_MidLevelSM_movesp,
									   		    const_MidLevelSM_stopsp)
									   [| { share__, terminate } |] (
									   Go_side::VS_O__(id__,
									   		    const_MidLevelSM_step,
									   		    const_MidLevelSM_climb_speed,
									   		    const_MidLevelSM_descent_speed,
									   		    const_MidLevelSM_side_speed,
									   		    const_MidLevelSM_forward_angle,
									   		    const_MidLevelSM_left_angle,
									   		    const_MidLevelSM_right_angle,
									   		    const_MidLevelSM_turn_speed,
									   		    const_MidLevelSM_movesp,
									   		    const_MidLevelSM_stopsp)
									   [| { share__, terminate } |] (
									   Stop::VS_O__(id__,
									   		    const_MidLevelSM_step,
									   		    const_MidLevelSM_climb_speed,
									   		    const_MidLevelSM_descent_speed,
									   		    const_MidLevelSM_side_speed,
									   		    const_MidLevelSM_forward_angle,
									   		    const_MidLevelSM_left_angle,
									   		    const_MidLevelSM_right_angle,
									   		    const_MidLevelSM_turn_speed,
									   		    const_MidLevelSM_movesp,
									   		    const_MidLevelSM_stopsp)
									   )
									   )
									   )
									   )
									   )
									   )
									 )
									 [[Go_up::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_Go_up.in,turn__.NID_Go_up.in,stop__.NID_Go_up.in,internal__.NID_Go_up|}]]
									 [[Turn_right::interrupt <- x__ | x__ <- {|interrupt,move_forward__.NID_Turn_right.in,turn__.NID_Turn_right.in,move_forward__.NID_Turn_right.in,move_forward__.NID_Turn_right.in,turn__.NID_Turn_right.in,internal__.NID_Turn_right|}]]
									 [[Go_down::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_Go_down.in,turn__.NID_Go_down.in,stop__.NID_Go_down.in,internal__.NID_Go_down|}]]
									 [[Turn_left::interrupt <- x__ | x__ <- {|interrupt,move_forward__.NID_Turn_left.in,turn__.NID_Turn_left.in,move_forward__.NID_Turn_left.in,move_forward__.NID_Turn_left.in,turn__.NID_Turn_left.in,internal__.NID_Turn_left|}]]
									 [[Go_side::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_Go_side.in,turn__.NID_Go_side.in,stop__.NID_Go_side.in,internal__.NID_Go_side|}]]
									 [[Stop::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_Stop.in,turn__.NID_Stop.in,internal__.NID_Stop|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_direction |} ]] 
									  [[Turn_right::entered <- Turn_right::enteredL,set_orientation <- setL_orientation,Go_up::entered <- Go_up::enteredL,set_direction <- setL_direction,Stop::entered <- Stop::enteredL,Turn_left::entered <- Turn_left::enteredL,Go_down::entered <- Go_down::enteredL]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,Turn_right::enteredL
									 			,setL_orientation
									 			,Go_up::enteredL
									 			,setL_direction
									 			,Stop::enteredL
									 			,Turn_left::enteredL
									 			,Go_down::enteredL
									 			,setR_direction
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_MidLevelSM_step,
									 		    const_MidLevelSM_climb_speed,
									 		    const_MidLevelSM_descent_speed,
									 		    const_MidLevelSM_side_speed,
									 		    const_MidLevelSM_forward_angle,
									 		    const_MidLevelSM_left_angle,
									 		    const_MidLevelSM_right_angle,
									 		    const_MidLevelSM_turn_speed,
									 		    const_MidLevelSM_movesp,
									 		    const_MidLevelSM_stopsp))
									  [[ share__ <- x__ | x__ <- {| share__,Turn_right::enteredL,setL_orientation,Go_up::enteredL,setL_direction,Stop::enteredL,Turn_left::enteredL,Go_down::enteredL |} ]]
									  [[set_direction <- setR_direction]]
									 )
									)[[Turn_right::enteredL <- Turn_right::entered,setL_orientation <- set_orientation,Go_up::enteredL <- Go_up::entered,setL_direction <- set_direction,Stop::enteredL <- Stop::entered,Turn_left::enteredL <- Turn_left::entered,Go_down::enteredL <- Go_down::entered]]
									 [[setR_direction <- set_direction]]
									)
								)
								 \ hideSet)
								[[
									target_speed__.x____ <- target_speed,
									target_angle__.x____ <- target_angle,
									speed_adjustment__.x____ <- speed_adjustment,
									angle_adjustment__.x____ <- angle_adjustment,
									move_forward__.x____ <- move_forward,
									turn__.x____ <- turn,
									stop__.x____ <- stop
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_MidLevelSM_step,
							 		          const_MidLevelSM_climb_speed,
							 		          const_MidLevelSM_descent_speed,
							 		          const_MidLevelSM_side_speed,
							 		          const_MidLevelSM_forward_angle,
							 		          const_MidLevelSM_left_angle,
							 		          const_MidLevelSM_right_angle,
							 		          const_MidLevelSM_turn_speed,
							 		          const_MidLevelSM_movesp,
							 		          const_MidLevelSM_stopsp)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = 
						dbisim((let
							stateClockSync = {|get_CLID_Turn_right,Turn_right::entered,get_CLID_Go_up,Go_up::entered,get_CLID_Stop,Stop::entered,get_CLID_Turn_left,Turn_left::entered,get_CLID_Go_down,Go_down::entered,get_CLID_Go_side,Go_side::entered|}
						 within
							(MachineBody_VS_O(id__,
									    const_MidLevelSM_step,
									    const_MidLevelSM_climb_speed,
									    const_MidLevelSM_descent_speed,
									    const_MidLevelSM_side_speed,
									    const_MidLevelSM_forward_angle,
									    const_MidLevelSM_left_angle,
									    const_MidLevelSM_right_angle,
									    const_MidLevelSM_turn_speed,
									    const_MidLevelSM_movesp,
									    const_MidLevelSM_stopsp) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = 
						dbisim((let
							stateClockSync = {|get_CLID_Turn_right,Turn_right::entered,get_CLID_Go_up,Go_up::entered,get_CLID_Stop,Stop::entered,get_CLID_Turn_left,Turn_left::entered,get_CLID_Go_down,Go_down::entered,get_CLID_Go_side,Go_side::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															dbisim(
																sbisim(
																	dbisim(
																		sbisim(
																			MachineBody_VS_O(id__,
																					    const_MidLevelSM_step,
																					    const_MidLevelSM_climb_speed,
																					    const_MidLevelSM_descent_speed,
																					    const_MidLevelSM_side_speed,
																					    const_MidLevelSM_forward_angle,
																					    const_MidLevelSM_left_angle,
																					    const_MidLevelSM_right_angle,
																					    const_MidLevelSM_turn_speed,
																					    const_MidLevelSM_movesp,
																					    const_MidLevelSM_stopsp)
																			[| {|get_CLID_Go_side,Go_side::entered,terminate|} |]
																			dbisim(Clock_CLID_Go_side(id__,0,
																					          const_MidLevelSM_step,
																					          const_MidLevelSM_climb_speed,
																					          const_MidLevelSM_descent_speed,
																					          const_MidLevelSM_side_speed,
																					          const_MidLevelSM_forward_angle,
																					          const_MidLevelSM_left_angle,
																					          const_MidLevelSM_right_angle,
																					          const_MidLevelSM_turn_speed,
																					          const_MidLevelSM_movesp,
																					          const_MidLevelSM_stopsp))
																		)\{|get_CLID_Go_side|}
																	)
																	[| {|get_CLID_Go_down,Go_down::entered,terminate|} |]
																	dbisim(Clock_CLID_Go_down(id__,0,
																			          const_MidLevelSM_step,
																			          const_MidLevelSM_climb_speed,
																			          const_MidLevelSM_descent_speed,
																			          const_MidLevelSM_side_speed,
																			          const_MidLevelSM_forward_angle,
																			          const_MidLevelSM_left_angle,
																			          const_MidLevelSM_right_angle,
																			          const_MidLevelSM_turn_speed,
																			          const_MidLevelSM_movesp,
																			          const_MidLevelSM_stopsp))
																)\{|get_CLID_Go_down|}
															)
															[| {|get_CLID_Turn_left,Turn_left::entered,terminate|} |]
															dbisim(Clock_CLID_Turn_left(id__,0,
																	          const_MidLevelSM_step,
																	          const_MidLevelSM_climb_speed,
																	          const_MidLevelSM_descent_speed,
																	          const_MidLevelSM_side_speed,
																	          const_MidLevelSM_forward_angle,
																	          const_MidLevelSM_left_angle,
																	          const_MidLevelSM_right_angle,
																	          const_MidLevelSM_turn_speed,
																	          const_MidLevelSM_movesp,
																	          const_MidLevelSM_stopsp))
														)\{|get_CLID_Turn_left|}
													)
													[| {|get_CLID_Stop,Stop::entered,terminate|} |]
													dbisim(Clock_CLID_Stop(id__,0,
															          const_MidLevelSM_step,
															          const_MidLevelSM_climb_speed,
															          const_MidLevelSM_descent_speed,
															          const_MidLevelSM_side_speed,
															          const_MidLevelSM_forward_angle,
															          const_MidLevelSM_left_angle,
															          const_MidLevelSM_right_angle,
															          const_MidLevelSM_turn_speed,
															          const_MidLevelSM_movesp,
															          const_MidLevelSM_stopsp))
												)\{|get_CLID_Stop|}
											)
											[| {|get_CLID_Go_up,Go_up::entered,terminate|} |]
											dbisim(Clock_CLID_Go_up(id__,0,
													          const_MidLevelSM_step,
													          const_MidLevelSM_climb_speed,
													          const_MidLevelSM_descent_speed,
													          const_MidLevelSM_side_speed,
													          const_MidLevelSM_forward_angle,
													          const_MidLevelSM_left_angle,
													          const_MidLevelSM_right_angle,
													          const_MidLevelSM_turn_speed,
													          const_MidLevelSM_movesp,
													          const_MidLevelSM_stopsp))
										)\{|get_CLID_Go_up|}
									)
									[| {|get_CLID_Turn_right,Turn_right::entered,terminate|} |]
									dbisim(Clock_CLID_Turn_right(id__,0,
											          const_MidLevelSM_step,
											          const_MidLevelSM_climb_speed,
											          const_MidLevelSM_descent_speed,
											          const_MidLevelSM_side_speed,
											          const_MidLevelSM_forward_angle,
											          const_MidLevelSM_left_angle,
											          const_MidLevelSM_right_angle,
											          const_MidLevelSM_turn_speed,
											          const_MidLevelSM_movesp,
											          const_MidLevelSM_stopsp))
								)\{|get_CLID_Turn_right|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = 
						dbisim((let
							getsetLocalChannels = {|get_lspeed,set_lspeed,
							get_rspeed,set_rspeed,
							get_angle,set_angle,
							get_speed_adj,set_speed_adj,
							get_angle_adj,set_angle_adj,
							get_direction,set_direction,
							get_orientation,set_orientation|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__,
									    const_MidLevelSM_step,
									    const_MidLevelSM_climb_speed,
									    const_MidLevelSM_descent_speed,
									    const_MidLevelSM_side_speed,
									    const_MidLevelSM_forward_angle,
									    const_MidLevelSM_left_angle,
									    const_MidLevelSM_right_angle,
									    const_MidLevelSM_turn_speed,
									    const_MidLevelSM_movesp,
									    const_MidLevelSM_stopsp) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_MidLevelSM_step,
							 		    const_MidLevelSM_climb_speed,
							 		    const_MidLevelSM_descent_speed,
							 		    const_MidLevelSM_side_speed,
							 		    const_MidLevelSM_forward_angle,
							 		    const_MidLevelSM_left_angle,
							 		    const_MidLevelSM_right_angle,
							 		    const_MidLevelSM_turn_speed,
							 		    const_MidLevelSM_movesp,
							 		    const_MidLevelSM_stopsp) [| {terminate} |] Clocks(id__,
							 		          const_MidLevelSM_step,
							 		          const_MidLevelSM_climb_speed,
							 		          const_MidLevelSM_descent_speed,
							 		          const_MidLevelSM_side_speed,
							 		          const_MidLevelSM_forward_angle,
							 		          const_MidLevelSM_left_angle,
							 		          const_MidLevelSM_right_angle,
							 		          const_MidLevelSM_turn_speed,
							 		          const_MidLevelSM_movesp,
							 		          const_MidLevelSM_stopsp))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																dbisim(
																	sbisim(
																		dbisim(
																			sbisim(
																				IteratedBehaviour_VS_O(id__,
																						    const_MidLevelSM_step,
																						    const_MidLevelSM_climb_speed,
																						    const_MidLevelSM_descent_speed,
																						    const_MidLevelSM_side_speed,
																						    const_MidLevelSM_forward_angle,
																						    const_MidLevelSM_left_angle,
																						    const_MidLevelSM_right_angle,
																						    const_MidLevelSM_turn_speed,
																						    const_MidLevelSM_movesp,
																						    const_MidLevelSM_stopsp)
																				[| {|get_orientation,set_orientation,terminate|} |]
																				Memory_orientation(Orientation_up)
																			)\{|get_orientation,set_orientation|}
																		)
																		[| {|get_direction,set_direction,terminate|} |]
																		Memory_direction(Direction_left)
																	)\{|get_direction,set_direction|}
																)
																[| {|get_angle_adj,set_angle_adj,terminate|} |]
																Memory_angle_adj(0)
															)\{|get_angle_adj,set_angle_adj|}
														)
														[| {|get_speed_adj,set_speed_adj,terminate|} |]
														Memory_speed_adj(0)
													)\{|get_speed_adj,set_speed_adj|}
												)
												[| {|get_angle,set_angle,terminate|} |]
												Memory_angle(0)
											)\{|get_angle,set_angle|}
										)
										[| {|get_rspeed,set_rspeed,terminate|} |]
										Memory_rspeed(0)
									)\{|get_rspeed,set_rspeed|}
								)
								[| {|get_lspeed,set_lspeed,terminate|} |]
								Memory_lspeed(0)
							)\{|get_lspeed,set_lspeed|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_lspeed(lspeed) =
						get_lspeed!lspeed -> Memory_lspeed(lspeed)
						[]
						set_lspeed?x__ -> Memory_lspeed(x__)
						[]
						terminate -> SKIP
					Memory_rspeed(rspeed) =
						get_rspeed!rspeed -> Memory_rspeed(rspeed)
						[]
						set_rspeed?x__ -> Memory_rspeed(x__)
						[]
						terminate -> SKIP
					Memory_angle(angle) =
						get_angle!angle -> Memory_angle(angle)
						[]
						set_angle?x__ -> Memory_angle(x__)
						[]
						terminate -> SKIP
					Memory_speed_adj(speed_adj) =
						get_speed_adj!speed_adj -> Memory_speed_adj(speed_adj)
						[]
						set_speed_adj?x__ -> Memory_speed_adj(x__)
						[]
						terminate -> SKIP
					Memory_angle_adj(angle_adj) =
						get_angle_adj!angle_adj -> Memory_angle_adj(angle_adj)
						[]
						set_angle_adj?x__ -> Memory_angle_adj(x__)
						[]
						terminate -> SKIP
					Memory_direction(direction) =
						get_direction!direction -> Memory_direction(direction)
						[]
						set_direction?x__ -> Memory_direction(x__)
						[]
						terminate -> SKIP
					Memory_orientation(orientation) =
						get_orientation!orientation -> Memory_orientation(orientation)
						[]
						set_orientation?x__ -> Memory_orientation(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = Memory_lspeed(0)
					[| { terminate } |] (
					Memory_rspeed(0)
					[| { terminate } |] (
					Memory_angle(0)
					[| { terminate } |] (
					Memory_speed_adj(0)
					[| { terminate } |] (
					Memory_angle_adj(0)
					[| { terminate } |] (
					Memory_direction(Direction_left)
					[| { terminate } |] (
					Memory_orientation(Orientation_up)
					)
					)
					)
					)
					)
					)
					
					getsetLocalChannels = {|get_lspeed,set_lspeed,get_rspeed,set_rspeed,get_angle,set_angle,get_speed_adj,set_speed_adj,get_angle_adj,set_angle_adj,get_direction,set_direction,get_orientation,set_orientation|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = STM_VS_O(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) \ localClockResets
					D__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = timed_priority(STM(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) \ union(internal_events,localClockResets))
					O__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = dbisim(D__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp))
					VS__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = FVS__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp)
					VS_O__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = dbisim(FVS__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp))
					HEXT__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = O__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) [|shared_variable_events|] SKIP
					FVS_C__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = dbisim(timed_priority(STM(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) \ internal_events))
					HUP__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = timed_priority(O__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__,
							          const_MidLevelSM_step,
							          const_MidLevelSM_climb_speed,
							          const_MidLevelSM_descent_speed,
							          const_MidLevelSM_side_speed,
							          const_MidLevelSM_forward_angle,
							          const_MidLevelSM_left_angle,
							          const_MidLevelSM_right_angle,
							          const_MidLevelSM_turn_speed,
							          const_MidLevelSM_movesp,
							          const_MidLevelSM_stopsp) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_Turn_right(id__,x__,
							          const_MidLevelSM_step,
							          const_MidLevelSM_climb_speed,
							          const_MidLevelSM_descent_speed,
							          const_MidLevelSM_side_speed,
							          const_MidLevelSM_forward_angle,
							          const_MidLevelSM_left_angle,
							          const_MidLevelSM_right_angle,
							          const_MidLevelSM_turn_speed,
							          const_MidLevelSM_movesp,
							          const_MidLevelSM_stopsp) = 
						TimeOut_1(
							Turn_right::entered -> Clock_CLID_Turn_right(id__,0,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp)
							[]
							get_CLID_Turn_right!x__ -> Clock_CLID_Turn_right(id__,x__,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp)
							[]
							terminate -> SKIP,Clock_CLID_Turn_right(id__,clock_type_plus(x__,1,CLID_Turn_right_clock_type(id__,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp)),
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp))
					Clock_CLID_Go_up(id__,x__,
							          const_MidLevelSM_step,
							          const_MidLevelSM_climb_speed,
							          const_MidLevelSM_descent_speed,
							          const_MidLevelSM_side_speed,
							          const_MidLevelSM_forward_angle,
							          const_MidLevelSM_left_angle,
							          const_MidLevelSM_right_angle,
							          const_MidLevelSM_turn_speed,
							          const_MidLevelSM_movesp,
							          const_MidLevelSM_stopsp) = 
						TimeOut_1(
							Go_up::entered -> Clock_CLID_Go_up(id__,0,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp)
							[]
							get_CLID_Go_up!x__ -> Clock_CLID_Go_up(id__,x__,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp)
							[]
							terminate -> SKIP,Clock_CLID_Go_up(id__,clock_type_plus(x__,1,CLID_Go_up_clock_type(id__,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp)),
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp))
					Clock_CLID_Stop(id__,x__,
							          const_MidLevelSM_step,
							          const_MidLevelSM_climb_speed,
							          const_MidLevelSM_descent_speed,
							          const_MidLevelSM_side_speed,
							          const_MidLevelSM_forward_angle,
							          const_MidLevelSM_left_angle,
							          const_MidLevelSM_right_angle,
							          const_MidLevelSM_turn_speed,
							          const_MidLevelSM_movesp,
							          const_MidLevelSM_stopsp) = 
						TimeOut_1(
							Stop::entered -> Clock_CLID_Stop(id__,0,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp)
							[]
							get_CLID_Stop!x__ -> Clock_CLID_Stop(id__,x__,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp)
							[]
							terminate -> SKIP,Clock_CLID_Stop(id__,clock_type_plus(x__,1,CLID_Stop_clock_type(id__,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp)),
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp))
					Clock_CLID_Turn_left(id__,x__,
							          const_MidLevelSM_step,
							          const_MidLevelSM_climb_speed,
							          const_MidLevelSM_descent_speed,
							          const_MidLevelSM_side_speed,
							          const_MidLevelSM_forward_angle,
							          const_MidLevelSM_left_angle,
							          const_MidLevelSM_right_angle,
							          const_MidLevelSM_turn_speed,
							          const_MidLevelSM_movesp,
							          const_MidLevelSM_stopsp) = 
						TimeOut_1(
							Turn_left::entered -> Clock_CLID_Turn_left(id__,0,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp)
							[]
							get_CLID_Turn_left!x__ -> Clock_CLID_Turn_left(id__,x__,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp)
							[]
							terminate -> SKIP,Clock_CLID_Turn_left(id__,clock_type_plus(x__,1,CLID_Turn_left_clock_type(id__,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp)),
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp))
					Clock_CLID_Go_down(id__,x__,
							          const_MidLevelSM_step,
							          const_MidLevelSM_climb_speed,
							          const_MidLevelSM_descent_speed,
							          const_MidLevelSM_side_speed,
							          const_MidLevelSM_forward_angle,
							          const_MidLevelSM_left_angle,
							          const_MidLevelSM_right_angle,
							          const_MidLevelSM_turn_speed,
							          const_MidLevelSM_movesp,
							          const_MidLevelSM_stopsp) = 
						TimeOut_1(
							Go_down::entered -> Clock_CLID_Go_down(id__,0,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp)
							[]
							get_CLID_Go_down!x__ -> Clock_CLID_Go_down(id__,x__,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp)
							[]
							terminate -> SKIP,Clock_CLID_Go_down(id__,clock_type_plus(x__,1,CLID_Go_down_clock_type(id__,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp)),
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp))
					Clock_CLID_Go_side(id__,x__,
							          const_MidLevelSM_step,
							          const_MidLevelSM_climb_speed,
							          const_MidLevelSM_descent_speed,
							          const_MidLevelSM_side_speed,
							          const_MidLevelSM_forward_angle,
							          const_MidLevelSM_left_angle,
							          const_MidLevelSM_right_angle,
							          const_MidLevelSM_turn_speed,
							          const_MidLevelSM_movesp,
							          const_MidLevelSM_stopsp) = 
						TimeOut_1(
							Go_side::entered -> Clock_CLID_Go_side(id__,0,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp)
							[]
							get_CLID_Go_side!x__ -> Clock_CLID_Go_side(id__,x__,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp)
							[]
							terminate -> SKIP,Clock_CLID_Go_side(id__,clock_type_plus(x__,1,CLID_Go_side_clock_type(id__,
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp)),
									          const_MidLevelSM_step,
									          const_MidLevelSM_climb_speed,
									          const_MidLevelSM_descent_speed,
									          const_MidLevelSM_side_speed,
									          const_MidLevelSM_forward_angle,
									          const_MidLevelSM_left_angle,
									          const_MidLevelSM_right_angle,
									          const_MidLevelSM_turn_speed,
									          const_MidLevelSM_movesp,
									          const_MidLevelSM_stopsp))
					
					StateClocks(id__,
							          const_MidLevelSM_step,
							          const_MidLevelSM_climb_speed,
							          const_MidLevelSM_descent_speed,
							          const_MidLevelSM_side_speed,
							          const_MidLevelSM_forward_angle,
							          const_MidLevelSM_left_angle,
							          const_MidLevelSM_right_angle,
							          const_MidLevelSM_turn_speed,
							          const_MidLevelSM_movesp,
							          const_MidLevelSM_stopsp) = dbisim(Clock_CLID_Turn_right(id__,0,
							          const_MidLevelSM_step,
							          const_MidLevelSM_climb_speed,
							          const_MidLevelSM_descent_speed,
							          const_MidLevelSM_side_speed,
							          const_MidLevelSM_forward_angle,
							          const_MidLevelSM_left_angle,
							          const_MidLevelSM_right_angle,
							          const_MidLevelSM_turn_speed,
							          const_MidLevelSM_movesp,
							          const_MidLevelSM_stopsp))
					[| { terminate } |] (
					dbisim(Clock_CLID_Go_up(id__,0,
							          const_MidLevelSM_step,
							          const_MidLevelSM_climb_speed,
							          const_MidLevelSM_descent_speed,
							          const_MidLevelSM_side_speed,
							          const_MidLevelSM_forward_angle,
							          const_MidLevelSM_left_angle,
							          const_MidLevelSM_right_angle,
							          const_MidLevelSM_turn_speed,
							          const_MidLevelSM_movesp,
							          const_MidLevelSM_stopsp))
					[| { terminate } |] (
					dbisim(Clock_CLID_Stop(id__,0,
							          const_MidLevelSM_step,
							          const_MidLevelSM_climb_speed,
							          const_MidLevelSM_descent_speed,
							          const_MidLevelSM_side_speed,
							          const_MidLevelSM_forward_angle,
							          const_MidLevelSM_left_angle,
							          const_MidLevelSM_right_angle,
							          const_MidLevelSM_turn_speed,
							          const_MidLevelSM_movesp,
							          const_MidLevelSM_stopsp))
					[| { terminate } |] (
					dbisim(Clock_CLID_Turn_left(id__,0,
							          const_MidLevelSM_step,
							          const_MidLevelSM_climb_speed,
							          const_MidLevelSM_descent_speed,
							          const_MidLevelSM_side_speed,
							          const_MidLevelSM_forward_angle,
							          const_MidLevelSM_left_angle,
							          const_MidLevelSM_right_angle,
							          const_MidLevelSM_turn_speed,
							          const_MidLevelSM_movesp,
							          const_MidLevelSM_stopsp))
					[| { terminate } |] (
					dbisim(Clock_CLID_Go_down(id__,0,
							          const_MidLevelSM_step,
							          const_MidLevelSM_climb_speed,
							          const_MidLevelSM_descent_speed,
							          const_MidLevelSM_side_speed,
							          const_MidLevelSM_forward_angle,
							          const_MidLevelSM_left_angle,
							          const_MidLevelSM_right_angle,
							          const_MidLevelSM_turn_speed,
							          const_MidLevelSM_movesp,
							          const_MidLevelSM_stopsp))
					[| { terminate } |] (
					dbisim(Clock_CLID_Go_side(id__,0,
							          const_MidLevelSM_step,
							          const_MidLevelSM_climb_speed,
							          const_MidLevelSM_descent_speed,
							          const_MidLevelSM_side_speed,
							          const_MidLevelSM_forward_angle,
							          const_MidLevelSM_left_angle,
							          const_MidLevelSM_right_angle,
							          const_MidLevelSM_turn_speed,
							          const_MidLevelSM_movesp,
							          const_MidLevelSM_stopsp))
					)
					)
					)
					)
					)
					
					stateClockSync = {|get_CLID_Turn_right,Turn_right::entered,get_CLID_Go_up,Go_up::entered,get_CLID_Stop,Stop::entered,get_CLID_Turn_left,Turn_left::entered,get_CLID_Go_down,Go_down::entered,get_CLID_Go_side,Go_side::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			module stm_ref9
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_wait_input|
				              NID_send_output|
				              NID_wait_right|
				              NID_wait_left
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_spl, set_spl, setL_spl, setR_spl: TripleAxis
				channel get_spr, set_spr, setL_spr, setR_spr: TripleAxis
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel speed_l__: NIDS.InOut.TripleAxis
				channel speed_l: InOut.TripleAxis
				channel speed_r__: NIDS.InOut.TripleAxis
				channel speed_r: InOut.TripleAxis
				channel linear_speed__: NIDS.InOut.core_int
				channel linear_speed: InOut.core_int
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				wait_input::enter,
				send_output::enter,
				wait_right::enter,
				wait_left::enter
				|}
				
				enteredSS = 	{|
				wait_input::entered,
				send_output::entered,
				wait_right::entered,
				wait_left::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	speed_l,
					speed_r,
					linear_speed
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_send_output : core_clock_type 
				channel get_CLID_wait_left : core_clock_type 
				channel get_CLID_wait_right : core_clock_type 
				channel get_CLID_wait_input : core_clock_type 
				--channel increment__
				
				CLID_send_output_clock_type(id__) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_wait_left_clock_type(id__) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_wait_right_clock_type(id__) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_wait_input_clock_type(id__) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__) = D__(id__)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: wait_input
					module wait_input
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: send_output
					module send_output
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: wait_right
					module wait_right
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: wait_left
					module wait_left
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					STM_VS_O(id__) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					-- Transitions
					Transitions(id__) = ((let
						Trans = TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; wait_input::enter -> SKIP))))
							 [] dbisim((true)&(speed_l__!NID_wait_input.in?spl:{spl|spl <- TripleAxis, true} -> share__choice(set_spl!spl -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; wait_right::enter -> SKIP)))
							 [] dbisim((true)&(speed_r__!NID_wait_input.in?spr:{spr|spr <- TripleAxis, true} -> share__choice(set_spr!spr -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; wait_left::enter -> SKIP)))
							 [] dbisim((true)&(speed_r__!NID_wait_right.in?spr:{spr|spr <- TripleAxis, true} -> share__choice(set_spr!spr -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; send_output::enter -> SKIP)))
							 [] dbisim((true)&(speed_l__!NID_wait_left.in?spl:{spl|spl <- TripleAxis, true} -> share__choice(set_spl!spl -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; send_output::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_send_output -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_spr?spr -> share__choice(get_spl?spl -> true&(share__choice(linear_speed.out!get_linear_speed(TripleAxis_Z(spl),TripleAxis_Z(spr)) -> SKIP)))) ; wait_input::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								wait_input::enter,
								send_output::enter,
								wait_right::enter,
								wait_left::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,speed_l__.NID_wait_input.in,speed_r__.NID_wait_input.in,speed_r__.NID_wait_right.in,speed_l__.NID_wait_left.in,internal__.NID_send_output|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__)
									   [| { share__, terminate } |] (
									   wait_input::D__(id__)
									   [| { share__, terminate } |] (
									   send_output::D__(id__)
									   [| { share__, terminate } |] (
									   wait_right::D__(id__)
									   [| { share__, terminate } |] (
									   wait_left::D__(id__)
									   )
									   )
									   )
									   )
									 )
									 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,speed_l__.NID_wait_input.in,speed_r__.NID_wait_input.in|}]]
									 [[send_output::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_send_output|}]]
									 [[wait_right::interrupt <- x__ | x__ <- {|interrupt,speed_r__.NID_wait_right.in|}]]
									 [[wait_left::interrupt <- x__ | x__ <- {|interrupt,speed_l__.NID_wait_left.in|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_spr,setR_spl |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setR_spr
									 			 			,setR_spl
									 			|}) |]
									 ((i0::enter -> Transitions(id__))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									  [[set_spr <- setR_spr,set_spl <- setR_spl]]
									 )
									)
									 [[setR_spr <- set_spr,setR_spl <- set_spl]]
									)
								)
								 \ hideSet)
								[[
									speed_l__.x____ <- speed_l,
									speed_r__.x____ <- speed_r,
									linear_speed__.x____ <- linear_speed
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_send_output,send_output::entered,get_CLID_wait_left,wait_left::entered,get_CLID_wait_right,wait_right::entered,get_CLID_wait_input,wait_input::entered|}
						 within
							(MachineBody(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_send_output,send_output::entered,get_CLID_wait_left,wait_left::entered,get_CLID_wait_right,wait_right::entered,get_CLID_wait_input,wait_input::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															MachineBody(id__)
															[| {|get_CLID_wait_input,wait_input::entered,terminate|} |]
															dbisim(Clock_CLID_wait_input(id__,0))
														)\{|get_CLID_wait_input|}
													)
													[| {|get_CLID_wait_right,wait_right::entered,terminate|} |]
													dbisim(Clock_CLID_wait_right(id__,0))
												)\{|get_CLID_wait_right|}
											)
											[| {|get_CLID_wait_left,wait_left::entered,terminate|} |]
											dbisim(Clock_CLID_wait_left(id__,0))
										)\{|get_CLID_wait_left|}
									)
									[| {|get_CLID_send_output,send_output::entered,terminate|} |]
									dbisim(Clock_CLID_send_output(id__,0))
								)\{|get_CLID_send_output|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__) = 
						((let
							getsetLocalChannels = {|get_spl,set_spl,
							get_spr,set_spr|}
							clockSync = {||}
						within
							(Behaviour(id__) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__) [| {terminate} |] Clocks(id__))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										IteratedBehaviour(id__)
										[| {|get_spr,set_spr,terminate|} |]
										Memory_spr((0,0,0))
									)\{|get_spr,set_spr|}
								)
								[| {|get_spl,set_spl,terminate|} |]
								Memory_spl((0,0,0))
							)\{|get_spl,set_spl|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								wait_input::enter,
								send_output::enter,
								wait_right::enter,
								wait_left::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,speed_l__.NID_wait_input.in,speed_r__.NID_wait_input.in,speed_r__.NID_wait_right.in,speed_l__.NID_wait_left.in,internal__.NID_send_output|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__)
									   [| { share__, terminate } |] (
									   wait_input::VS_O__(id__)
									   [| { share__, terminate } |] (
									   send_output::VS_O__(id__)
									   [| { share__, terminate } |] (
									   wait_right::VS_O__(id__)
									   [| { share__, terminate } |] (
									   wait_left::VS_O__(id__)
									   )
									   )
									   )
									   )
									 )
									 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,speed_l__.NID_wait_input.in,speed_r__.NID_wait_input.in|}]]
									 [[send_output::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_send_output|}]]
									 [[wait_right::interrupt <- x__ | x__ <- {|interrupt,speed_r__.NID_wait_right.in|}]]
									 [[wait_left::interrupt <- x__ | x__ <- {|interrupt,speed_l__.NID_wait_left.in|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_spr,setR_spl |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setR_spr
									 			 			,setR_spl
									 			|}) |]
									 ((i0::enter -> Transitions(id__))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									  [[set_spr <- setR_spr,set_spl <- setR_spl]]
									 )
									)
									 [[setR_spr <- set_spr,setR_spl <- set_spl]]
									)
								)
								 \ hideSet)
								[[
									speed_l__.x____ <- speed_l,
									speed_r__.x____ <- speed_r,
									linear_speed__.x____ <- linear_speed
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_send_output,send_output::entered,get_CLID_wait_left,wait_left::entered,get_CLID_wait_right,wait_right::entered,get_CLID_wait_input,wait_input::entered|}
						 within
							(MachineBody_VS_O(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_send_output,send_output::entered,get_CLID_wait_left,wait_left::entered,get_CLID_wait_right,wait_right::entered,get_CLID_wait_input,wait_input::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															MachineBody_VS_O(id__)
															[| {|get_CLID_wait_input,wait_input::entered,terminate|} |]
															dbisim(Clock_CLID_wait_input(id__,0))
														)\{|get_CLID_wait_input|}
													)
													[| {|get_CLID_wait_right,wait_right::entered,terminate|} |]
													dbisim(Clock_CLID_wait_right(id__,0))
												)\{|get_CLID_wait_right|}
											)
											[| {|get_CLID_wait_left,wait_left::entered,terminate|} |]
											dbisim(Clock_CLID_wait_left(id__,0))
										)\{|get_CLID_wait_left|}
									)
									[| {|get_CLID_send_output,send_output::entered,terminate|} |]
									dbisim(Clock_CLID_send_output(id__,0))
								)\{|get_CLID_send_output|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__) = 
						dbisim((let
							getsetLocalChannels = {|get_spl,set_spl,
							get_spr,set_spr|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__) [| {terminate} |] Clocks(id__))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										IteratedBehaviour_VS_O(id__)
										[| {|get_spr,set_spr,terminate|} |]
										Memory_spr((0,0,0))
									)\{|get_spr,set_spr|}
								)
								[| {|get_spl,set_spl,terminate|} |]
								Memory_spl((0,0,0))
							)\{|get_spl,set_spl|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_spl(spl) =
						get_spl!spl -> Memory_spl(spl)
						[]
						set_spl?x__ -> Memory_spl(x__)
						[]
						terminate -> SKIP
					Memory_spr(spr) =
						get_spr!spr -> Memory_spr(spr)
						[]
						set_spr?x__ -> Memory_spr(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__) = Memory_spl((0,0,0))
					[| { terminate } |] (
					Memory_spr((0,0,0))
					)
					
					getsetLocalChannels = {|get_spl,set_spl,get_spr,set_spr|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__) = STM_VS_O(id__) \ localClockResets
					D__(id__) = timed_priority(STM(id__) \ union(internal_events,localClockResets))
					O__(id__) = dbisim(D__(id__))
					VS__(id__) = FVS__(id__)
					VS_O__(id__) = dbisim(FVS__(id__))
					HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
					FVS_C__(id__) = dbisim(timed_priority(STM(id__) \ internal_events))
					HUP__(id__) = timed_priority(O__(id__) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_send_output(id__,x__) = 
						TimeOut_1(
							send_output::entered -> Clock_CLID_send_output(id__,0)
							[]
							get_CLID_send_output!x__ -> Clock_CLID_send_output(id__,x__)
							[]
							terminate -> SKIP,Clock_CLID_send_output(id__,clock_type_plus(x__,1,CLID_send_output_clock_type(id__))))
					Clock_CLID_wait_left(id__,x__) = 
						TimeOut_1(
							wait_left::entered -> Clock_CLID_wait_left(id__,0)
							[]
							get_CLID_wait_left!x__ -> Clock_CLID_wait_left(id__,x__)
							[]
							terminate -> SKIP,Clock_CLID_wait_left(id__,clock_type_plus(x__,1,CLID_wait_left_clock_type(id__))))
					Clock_CLID_wait_right(id__,x__) = 
						TimeOut_1(
							wait_right::entered -> Clock_CLID_wait_right(id__,0)
							[]
							get_CLID_wait_right!x__ -> Clock_CLID_wait_right(id__,x__)
							[]
							terminate -> SKIP,Clock_CLID_wait_right(id__,clock_type_plus(x__,1,CLID_wait_right_clock_type(id__))))
					Clock_CLID_wait_input(id__,x__) = 
						TimeOut_1(
							wait_input::entered -> Clock_CLID_wait_input(id__,0)
							[]
							get_CLID_wait_input!x__ -> Clock_CLID_wait_input(id__,x__)
							[]
							terminate -> SKIP,Clock_CLID_wait_input(id__,clock_type_plus(x__,1,CLID_wait_input_clock_type(id__))))
					
					StateClocks(id__) = dbisim(Clock_CLID_send_output(id__,0))
					[| { terminate } |] (
					dbisim(Clock_CLID_wait_left(id__,0))
					[| { terminate } |] (
					dbisim(Clock_CLID_wait_right(id__,0))
					[| { terminate } |] (
					dbisim(Clock_CLID_wait_input(id__,0))
					)
					)
					)
					
					stateClockSync = {|get_CLID_send_output,send_output::entered,get_CLID_wait_left,wait_left::entered,get_CLID_wait_right,wait_right::entered,get_CLID_wait_input,wait_input::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			module stm_ref10
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_wait_input|
				              NID_send_output
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_x, set_x, setL_x, setR_x: TripleAxis
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel input__: NIDS.InOut.TripleAxis
				channel input: InOut.TripleAxis
				channel output1__: NIDS.InOut.TripleAxis
				channel output1: InOut.TripleAxis
				channel output2__: NIDS.InOut.TripleAxis
				channel output2: InOut.TripleAxis
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				wait_input::enter,
				send_output::enter
				|}
				
				enteredSS = 	{|
				wait_input::entered,
				send_output::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	input,
					output1,
					output2
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_wait_input : core_clock_type 
				channel get_CLID_send_output : core_clock_type 
				--channel increment__
				
				CLID_wait_input_clock_type(id__) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_send_output_clock_type(id__) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__) = D__(id__)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: wait_input
					module wait_input
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: send_output
					module send_output
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					STM_VS_O(id__) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					-- Transitions
					Transitions(id__) = ((let
						Trans = TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; wait_input::enter -> SKIP))))
							 [] dbisim((true)&(input__!NID_wait_input.in?x:{x|x <- TripleAxis, true} -> share__choice(set_x!x -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; send_output::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_send_output -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_x?x -> true&(share__choice(output1.out!x -> SKIP)));share__choice(get_x?x -> true&(share__choice(output2.out!x -> SKIP))) ; wait_input::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								wait_input::enter,
								send_output::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,input__.NID_wait_input.in,internal__.NID_send_output|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__)
									   [| { share__, terminate } |] (
									   wait_input::D__(id__)
									   [| { share__, terminate } |] (
									   send_output::D__(id__)
									   )
									   )
									 )
									 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,input__.NID_wait_input.in|}]]
									 [[send_output::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_send_output|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_x |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setR_x
									 			|}) |]
									 ((i0::enter -> Transitions(id__))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									  [[set_x <- setR_x]]
									 )
									)
									 [[setR_x <- set_x]]
									)
								)
								 \ hideSet)
								[[
									input__.x____ <- input,
									output1__.x____ <- output1,
									output2__.x____ <- output2
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_send_output,send_output::entered|}
						 within
							(MachineBody(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_send_output,send_output::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											MachineBody(id__)
											[| {|get_CLID_send_output,send_output::entered,terminate|} |]
											dbisim(Clock_CLID_send_output(id__,0))
										)\{|get_CLID_send_output|}
									)
									[| {|get_CLID_wait_input,wait_input::entered,terminate|} |]
									dbisim(Clock_CLID_wait_input(id__,0))
								)\{|get_CLID_wait_input|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__) = 
						((let
							getsetLocalChannels = {|get_x,set_x|}
							clockSync = {||}
						within
							(Behaviour(id__) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__) [| {terminate} |] Clocks(id__))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__) =
						(dbisim(
							sbisim(
								IteratedBehaviour(id__)
								[| {|get_x,set_x,terminate|} |]
								Memory_x((0,0,0))
							)\{|get_x,set_x|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								wait_input::enter,
								send_output::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,input__.NID_wait_input.in,internal__.NID_send_output|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__)
									   [| { share__, terminate } |] (
									   wait_input::VS_O__(id__)
									   [| { share__, terminate } |] (
									   send_output::VS_O__(id__)
									   )
									   )
									 )
									 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,input__.NID_wait_input.in|}]]
									 [[send_output::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_send_output|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_x |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setR_x
									 			|}) |]
									 ((i0::enter -> Transitions(id__))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									  [[set_x <- setR_x]]
									 )
									)
									 [[setR_x <- set_x]]
									)
								)
								 \ hideSet)
								[[
									input__.x____ <- input,
									output1__.x____ <- output1,
									output2__.x____ <- output2
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_send_output,send_output::entered|}
						 within
							(MachineBody_VS_O(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_send_output,send_output::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											MachineBody_VS_O(id__)
											[| {|get_CLID_send_output,send_output::entered,terminate|} |]
											dbisim(Clock_CLID_send_output(id__,0))
										)\{|get_CLID_send_output|}
									)
									[| {|get_CLID_wait_input,wait_input::entered,terminate|} |]
									dbisim(Clock_CLID_wait_input(id__,0))
								)\{|get_CLID_wait_input|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__) = 
						dbisim((let
							getsetLocalChannels = {|get_x,set_x|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__) [| {terminate} |] Clocks(id__))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__) =
						(dbisim(
							sbisim(
								IteratedBehaviour_VS_O(id__)
								[| {|get_x,set_x,terminate|} |]
								Memory_x((0,0,0))
							)\{|get_x,set_x|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_x(x) =
						get_x!x -> Memory_x(x)
						[]
						set_x?x__ -> Memory_x(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__) = Memory_x((0,0,0))
					
					getsetLocalChannels = {|get_x,set_x|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__) = STM_VS_O(id__) \ localClockResets
					D__(id__) = timed_priority(STM(id__) \ union(internal_events,localClockResets))
					O__(id__) = dbisim(D__(id__))
					VS__(id__) = FVS__(id__)
					VS_O__(id__) = dbisim(FVS__(id__))
					HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
					FVS_C__(id__) = dbisim(timed_priority(STM(id__) \ internal_events))
					HUP__(id__) = timed_priority(O__(id__) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_wait_input(id__,x__) = 
						TimeOut_1(
							wait_input::entered -> Clock_CLID_wait_input(id__,0)
							[]
							get_CLID_wait_input!x__ -> Clock_CLID_wait_input(id__,x__)
							[]
							terminate -> SKIP,Clock_CLID_wait_input(id__,clock_type_plus(x__,1,CLID_wait_input_clock_type(id__))))
					Clock_CLID_send_output(id__,x__) = 
						TimeOut_1(
							send_output::entered -> Clock_CLID_send_output(id__,0)
							[]
							get_CLID_send_output!x__ -> Clock_CLID_send_output(id__,x__)
							[]
							terminate -> SKIP,Clock_CLID_send_output(id__,clock_type_plus(x__,1,CLID_send_output_clock_type(id__))))
					
					StateClocks(id__) = dbisim(Clock_CLID_wait_input(id__,0))
					[| { terminate } |] (
					dbisim(Clock_CLID_send_output(id__,0))
					)
					
					stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_send_output,send_output::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			module stm_ref11
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_wait_input|
				              NID_send_output
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_x, set_x, setL_x, setR_x: TripleAxis
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel input__: NIDS.InOut.TripleAxis
				channel input: InOut.TripleAxis
				channel output1__: NIDS.InOut.TripleAxis
				channel output1: InOut.TripleAxis
				channel output2__: NIDS.InOut.TripleAxis
				channel output2: InOut.TripleAxis
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				wait_input::enter,
				send_output::enter
				|}
				
				enteredSS = 	{|
				wait_input::entered,
				send_output::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	input,
					output1,
					output2
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_wait_input : core_clock_type 
				channel get_CLID_send_output : core_clock_type 
				--channel increment__
				
				CLID_wait_input_clock_type(id__) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_send_output_clock_type(id__) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__) = D__(id__)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: wait_input
					module wait_input
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: send_output
					module send_output
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					STM_VS_O(id__) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					-- Transitions
					Transitions(id__) = ((let
						Trans = TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; wait_input::enter -> SKIP))))
							 [] dbisim((true)&(input__!NID_wait_input.in?x:{x|x <- TripleAxis, true} -> share__choice(set_x!x -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; send_output::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_send_output -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_x?x -> true&(share__choice(output1.out!x -> SKIP)));share__choice(get_x?x -> true&(share__choice(output2.out!x -> SKIP))) ; wait_input::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								wait_input::enter,
								send_output::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,input__.NID_wait_input.in,internal__.NID_send_output|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__)
									   [| { share__, terminate } |] (
									   wait_input::D__(id__)
									   [| { share__, terminate } |] (
									   send_output::D__(id__)
									   )
									   )
									 )
									 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,input__.NID_wait_input.in|}]]
									 [[send_output::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_send_output|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_x |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setR_x
									 			|}) |]
									 ((i0::enter -> Transitions(id__))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									  [[set_x <- setR_x]]
									 )
									)
									 [[setR_x <- set_x]]
									)
								)
								 \ hideSet)
								[[
									input__.x____ <- input,
									output1__.x____ <- output1,
									output2__.x____ <- output2
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_send_output,send_output::entered|}
						 within
							(MachineBody(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_send_output,send_output::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											MachineBody(id__)
											[| {|get_CLID_send_output,send_output::entered,terminate|} |]
											dbisim(Clock_CLID_send_output(id__,0))
										)\{|get_CLID_send_output|}
									)
									[| {|get_CLID_wait_input,wait_input::entered,terminate|} |]
									dbisim(Clock_CLID_wait_input(id__,0))
								)\{|get_CLID_wait_input|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__) = 
						((let
							getsetLocalChannels = {|get_x,set_x|}
							clockSync = {||}
						within
							(Behaviour(id__) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__) [| {terminate} |] Clocks(id__))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__) =
						(dbisim(
							sbisim(
								IteratedBehaviour(id__)
								[| {|get_x,set_x,terminate|} |]
								Memory_x((0,0,0))
							)\{|get_x,set_x|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								wait_input::enter,
								send_output::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,input__.NID_wait_input.in,internal__.NID_send_output|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__)
									   [| { share__, terminate } |] (
									   wait_input::VS_O__(id__)
									   [| { share__, terminate } |] (
									   send_output::VS_O__(id__)
									   )
									   )
									 )
									 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,input__.NID_wait_input.in|}]]
									 [[send_output::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_send_output|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_x |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setR_x
									 			|}) |]
									 ((i0::enter -> Transitions(id__))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									  [[set_x <- setR_x]]
									 )
									)
									 [[setR_x <- set_x]]
									)
								)
								 \ hideSet)
								[[
									input__.x____ <- input,
									output1__.x____ <- output1,
									output2__.x____ <- output2
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_send_output,send_output::entered|}
						 within
							(MachineBody_VS_O(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_send_output,send_output::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											MachineBody_VS_O(id__)
											[| {|get_CLID_send_output,send_output::entered,terminate|} |]
											dbisim(Clock_CLID_send_output(id__,0))
										)\{|get_CLID_send_output|}
									)
									[| {|get_CLID_wait_input,wait_input::entered,terminate|} |]
									dbisim(Clock_CLID_wait_input(id__,0))
								)\{|get_CLID_wait_input|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__) = 
						dbisim((let
							getsetLocalChannels = {|get_x,set_x|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__) [| {terminate} |] Clocks(id__))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__) =
						(dbisim(
							sbisim(
								IteratedBehaviour_VS_O(id__)
								[| {|get_x,set_x,terminate|} |]
								Memory_x((0,0,0))
							)\{|get_x,set_x|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_x(x) =
						get_x!x -> Memory_x(x)
						[]
						set_x?x__ -> Memory_x(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__) = Memory_x((0,0,0))
					
					getsetLocalChannels = {|get_x,set_x|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__) = STM_VS_O(id__) \ localClockResets
					D__(id__) = timed_priority(STM(id__) \ union(internal_events,localClockResets))
					O__(id__) = dbisim(D__(id__))
					VS__(id__) = FVS__(id__)
					VS_O__(id__) = dbisim(FVS__(id__))
					HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
					FVS_C__(id__) = dbisim(timed_priority(STM(id__) \ internal_events))
					HUP__(id__) = timed_priority(O__(id__) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_wait_input(id__,x__) = 
						TimeOut_1(
							wait_input::entered -> Clock_CLID_wait_input(id__,0)
							[]
							get_CLID_wait_input!x__ -> Clock_CLID_wait_input(id__,x__)
							[]
							terminate -> SKIP,Clock_CLID_wait_input(id__,clock_type_plus(x__,1,CLID_wait_input_clock_type(id__))))
					Clock_CLID_send_output(id__,x__) = 
						TimeOut_1(
							send_output::entered -> Clock_CLID_send_output(id__,0)
							[]
							get_CLID_send_output!x__ -> Clock_CLID_send_output(id__,x__)
							[]
							terminate -> SKIP,Clock_CLID_send_output(id__,clock_type_plus(x__,1,CLID_send_output_clock_type(id__))))
					
					StateClocks(id__) = dbisim(Clock_CLID_wait_input(id__,0))
					[| { terminate } |] (
					dbisim(Clock_CLID_send_output(id__,0))
					)
					
					stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_send_output,send_output::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			module stm_ref12
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_wait_input|
				              NID_send_output
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_x, set_x, setL_x, setR_x: TripleAxis
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel input__: NIDS.InOut.TripleAxis
				channel input: InOut.TripleAxis
				channel output1__: NIDS.InOut.TripleAxis
				channel output1: InOut.TripleAxis
				channel output2__: NIDS.InOut.TripleAxis
				channel output2: InOut.TripleAxis
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				wait_input::enter,
				send_output::enter
				|}
				
				enteredSS = 	{|
				wait_input::entered,
				send_output::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	input,
					output1,
					output2
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_wait_input : core_clock_type 
				channel get_CLID_send_output : core_clock_type 
				--channel increment__
				
				CLID_wait_input_clock_type(id__) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_send_output_clock_type(id__) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__) = D__(id__)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: wait_input
					module wait_input
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: send_output
					module send_output
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					STM_VS_O(id__) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__))
					)\sharedVarHide
					,<{terminate},{tock}>)
					
					-- Transitions
					Transitions(id__) = ((let
						Trans = TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; wait_input::enter -> SKIP))))
							 [] dbisim((true)&(input__!NID_wait_input.in?x:{x|x <- TripleAxis, true} -> share__choice(set_x!x -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; send_output::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_send_output -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_x?x -> true&(share__choice(output1.out!x -> SKIP)));share__choice(get_x?x -> true&(share__choice(output2.out!x -> SKIP))) ; wait_input::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								wait_input::enter,
								send_output::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,input__.NID_wait_input.in,internal__.NID_send_output|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__)
									   [| { share__, terminate } |] (
									   wait_input::D__(id__)
									   [| { share__, terminate } |] (
									   send_output::D__(id__)
									   )
									   )
									 )
									 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,input__.NID_wait_input.in|}]]
									 [[send_output::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_send_output|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_x |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setR_x
									 			|}) |]
									 ((i0::enter -> Transitions(id__))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									  [[set_x <- setR_x]]
									 )
									)
									 [[setR_x <- set_x]]
									)
								)
								 \ hideSet)
								[[
									input__.x____ <- input,
									output1__.x____ <- output1,
									output2__.x____ <- output2
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_send_output,send_output::entered|}
						 within
							(MachineBody(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_send_output,send_output::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											MachineBody(id__)
											[| {|get_CLID_send_output,send_output::entered,terminate|} |]
											dbisim(Clock_CLID_send_output(id__,0))
										)\{|get_CLID_send_output|}
									)
									[| {|get_CLID_wait_input,wait_input::entered,terminate|} |]
									dbisim(Clock_CLID_wait_input(id__,0))
								)\{|get_CLID_wait_input|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__) = 
						((let
							getsetLocalChannels = {|get_x,set_x|}
							clockSync = {||}
						within
							(Behaviour(id__) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__) [| {terminate} |] Clocks(id__))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__) =
						(dbisim(
							sbisim(
								IteratedBehaviour(id__)
								[| {|get_x,set_x,terminate|} |]
								Memory_x((0,0,0))
							)\{|get_x,set_x|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								wait_input::enter,
								send_output::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,input__.NID_wait_input.in,internal__.NID_send_output|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__)
									   [| { share__, terminate } |] (
									   wait_input::VS_O__(id__)
									   [| { share__, terminate } |] (
									   send_output::VS_O__(id__)
									   )
									   )
									 )
									 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,input__.NID_wait_input.in|}]]
									 [[send_output::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_send_output|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_x |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setR_x
									 			|}) |]
									 ((i0::enter -> Transitions(id__))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									  [[set_x <- setR_x]]
									 )
									)
									 [[setR_x <- set_x]]
									)
								)
								 \ hideSet)
								[[
									input__.x____ <- input,
									output1__.x____ <- output1,
									output2__.x____ <- output2
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_send_output,send_output::entered|}
						 within
							(MachineBody_VS_O(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_send_output,send_output::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											MachineBody_VS_O(id__)
											[| {|get_CLID_send_output,send_output::entered,terminate|} |]
											dbisim(Clock_CLID_send_output(id__,0))
										)\{|get_CLID_send_output|}
									)
									[| {|get_CLID_wait_input,wait_input::entered,terminate|} |]
									dbisim(Clock_CLID_wait_input(id__,0))
								)\{|get_CLID_wait_input|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__) = 
						dbisim((let
							getsetLocalChannels = {|get_x,set_x|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__) [| {terminate} |] Clocks(id__))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__) =
						(dbisim(
							sbisim(
								IteratedBehaviour_VS_O(id__)
								[| {|get_x,set_x,terminate|} |]
								Memory_x((0,0,0))
							)\{|get_x,set_x|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_x(x) =
						get_x!x -> Memory_x(x)
						[]
						set_x?x__ -> Memory_x(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__) = Memory_x((0,0,0))
					
					getsetLocalChannels = {|get_x,set_x|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__) = STM_VS_O(id__) \ localClockResets
					D__(id__) = timed_priority(STM(id__) \ union(internal_events,localClockResets))
					O__(id__) = dbisim(D__(id__))
					VS__(id__) = FVS__(id__)
					VS_O__(id__) = dbisim(FVS__(id__))
					HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
					FVS_C__(id__) = dbisim(timed_priority(STM(id__) \ internal_events))
					HUP__(id__) = timed_priority(O__(id__) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_wait_input(id__,x__) = 
						TimeOut_1(
							wait_input::entered -> Clock_CLID_wait_input(id__,0)
							[]
							get_CLID_wait_input!x__ -> Clock_CLID_wait_input(id__,x__)
							[]
							terminate -> SKIP,Clock_CLID_wait_input(id__,clock_type_plus(x__,1,CLID_wait_input_clock_type(id__))))
					Clock_CLID_send_output(id__,x__) = 
						TimeOut_1(
							send_output::entered -> Clock_CLID_send_output(id__,0)
							[]
							get_CLID_send_output!x__ -> Clock_CLID_send_output(id__,x__)
							[]
							terminate -> SKIP,Clock_CLID_send_output(id__,clock_type_plus(x__,1,CLID_send_output_clock_type(id__))))
					
					StateClocks(id__) = dbisim(Clock_CLID_wait_input(id__,0))
					[| { terminate } |] (
					dbisim(Clock_CLID_send_output(id__,0))
					)
					
					stateClockSync = {|get_CLID_wait_input,wait_input::entered,get_CLID_send_output,send_output::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			
			Timed(OneStep) {
					-- undefined operations
					CALL__output_right_motor(id__,
							    param_x) 	= output_right_motorCall.param_x -> SKIP
					CALL__vacuum(id__,
							    param_x) 	= vacuumCall.param_x -> SKIP
					CALL__brush(id__,
							    param_x) 	= brushCall.param_x -> SKIP
					CALL__output_left_motor(id__,
							    param_x) 	= output_left_motorCall.param_x -> SKIP
					
					-- declaring controller memory
					Memory(id__) = SKIP
					
					D__(id__,
							    const_Module_PathPlanningController_stm_ref0_cliff,
							    const_Module_PathPlanningController_stm_ref0_nozzle,
							    const_Module_PathPlanningController_stm_ref0_battery_low,
							    const_Module_PathPlanningController_stm_ref0_sleep_time,
							    const_Module_PathPlanningController_stm_ref0_acc_distance,
							    const_Module_PathPlanningController_stm_ref1_t,
							    const_Module_PathPlanningController_stm_ref2_t,
							    const_Module_PathPlanningController_stm_ref3_t,
							    const_Module_PathPlanningController_stm_ref4_voltage,
							    const_Module_PathPlanningController_stm_ref5_t,
							    const_Module_PathPlanningController_stm_ref5_acc_distance,
							    const_Module_PathPlanningController_stm_ref6_kp,
							    const_Module_PathPlanningController_stm_ref6_ki,
							    const_Module_PathPlanningController_stm_ref6_kd,
							    const_Module_PathPlanningController_stm_ref6_step,
							    const_Module_PathPlanningController_stm_ref7_kp,
							    const_Module_PathPlanningController_stm_ref7_ki,
							    const_Module_PathPlanningController_stm_ref7_kd,
							    const_Module_PathPlanningController_stm_ref7_step,
							    const_Module_PathPlanningController_stm_ref8_step,
							    const_Module_PathPlanningController_stm_ref8_climb_speed,
							    const_Module_PathPlanningController_stm_ref8_descent_speed,
							    const_Module_PathPlanningController_stm_ref8_side_speed,
							    const_Module_PathPlanningController_stm_ref8_forward_angle,
							    const_Module_PathPlanningController_stm_ref8_left_angle,
							    const_Module_PathPlanningController_stm_ref8_right_angle,
							    const_Module_PathPlanningController_stm_ref8_turn_speed,
							    const_Module_PathPlanningController_stm_ref8_movesp,
							    const_Module_PathPlanningController_stm_ref8_stopsp) = prioritise(	((
							(
								let
									const_PathPlanningSM_cliff = const_Module_PathPlanningController_stm_ref0_cliff
									const_PathPlanningSM_nozzle = const_Module_PathPlanningController_stm_ref0_nozzle
									const_PathPlanningSM_battery_low = const_Module_PathPlanningController_stm_ref0_battery_low
									const_PathPlanningSM_sleep_time = const_Module_PathPlanningController_stm_ref0_sleep_time
									const_PathPlanningSM_acc_distance = const_Module_PathPlanningController_stm_ref0_acc_distance
								within 
								stm_ref0::D__(id__,
										    const_PathPlanningSM_cliff,
										    const_PathPlanningSM_nozzle,
										    const_PathPlanningSM_battery_low,
										    const_PathPlanningSM_sleep_time,
										    const_PathPlanningSM_acc_distance)[[
									stm_ref0::terminate <- terminate,
									stm_ref0::displacement.in <- stm_ref3::displacement.out,
									stm_ref0::displacement.out <- stm_ref3::displacement.in,
									stm_ref0::ultrasonic <- ultrasonic,
									stm_ref0::battery_level <- battery_level,
									stm_ref0::charging <- charging
								]]
							)
								[|{|terminate, stm_ref0::clean, stm_ref3::displacement, stm_ref0::move_forward, stm_ref0::turn, stm_ref0::stop|}|]
							(
								(
									let
										const_SpeedSM_t = const_Module_PathPlanningController_stm_ref1_t
									within 
									stm_ref1::D__(id__,
											    const_SpeedSM_t)[[
										stm_ref1::terminate <- terminate,
										stm_ref1::acc.in <- stm_ref10::output1.out,
										stm_ref1::acc.out <- stm_ref10::output1.in
									]]
								)
									[|{|terminate, stm_ref1::sp, stm_ref10::output1|}|]
								(
									(
										let
											const_SpeedSM_t = const_Module_PathPlanningController_stm_ref2_t
										within 
										stm_ref2::D__(id__,
												    const_SpeedSM_t)[[
											stm_ref2::terminate <- terminate,
											stm_ref2::acc.in <- stm_ref11::output1.out,
											stm_ref2::acc.out <- stm_ref11::output1.in
										]]
									)
										[|{|terminate, stm_ref11::output1, stm_ref2::sp|}|]
									(
										(
											let
												const_DisplacementSM_t = const_Module_PathPlanningController_stm_ref3_t
											within 
											stm_ref3::D__(id__,
													    const_DisplacementSM_t)[[
												stm_ref3::terminate <- terminate,
												stm_ref3::sp.in <- stm_ref12::output1.out,
												stm_ref3::sp.out <- stm_ref12::output1.in
											]]
										)
											[|{|terminate, stm_ref12::output1|}|]
										(
											(
												let
													const_CleanSM_voltage = const_Module_PathPlanningController_stm_ref4_voltage
												within 
												stm_ref4::D__(id__,
														    const_CleanSM_voltage)[[
													stm_ref4::terminate <- terminate,
													stm_ref4::clean.in <- stm_ref0::clean.out,
													stm_ref4::clean.out <- stm_ref0::clean.in,
													stm_ref4::vacuumCall <- vacuumCall,
													stm_ref4::brushCall <- brushCall
												]]
											)
												[|{|terminate|}|]
											(
												(
													let
														const_AngularSpeedSM_t = const_Module_PathPlanningController_stm_ref5_t
														const_AngularSpeedSM_acc_distance = const_Module_PathPlanningController_stm_ref5_acc_distance
													within 
													stm_ref5::D__(id__,
															    const_AngularSpeedSM_t,
															    const_AngularSpeedSM_acc_distance)[[
														stm_ref5::terminate <- terminate,
														stm_ref5::acc_l.in <- stm_ref10::output2.out,
														stm_ref5::acc_l.out <- stm_ref10::output2.in,
														stm_ref5::acc_r.in <- stm_ref11::output2.out,
														stm_ref5::acc_r.out <- stm_ref11::output2.in
													]]
												)
													[|{|terminate, stm_ref5::angle, stm_ref10::output2, stm_ref11::output2|}|]
												(
													(
														let
															const_PID_kp = const_Module_PathPlanningController_stm_ref6_kp
															const_PID_ki = const_Module_PathPlanningController_stm_ref6_ki
															const_PID_kd = const_Module_PathPlanningController_stm_ref6_kd
															const_PID_step = const_Module_PathPlanningController_stm_ref6_step
														within 
														stm_ref6::D__(id__,
																    const_PID_kp,
																    const_PID_ki,
																    const_PID_kd,
																    const_PID_step)[[
															stm_ref6::terminate <- terminate,
															stm_ref6::target.in <- stm_ref8::target_angle.out,
															stm_ref6::target.out <- stm_ref8::target_angle.in,
															stm_ref6::actual.in <- stm_ref5::angle.out,
															stm_ref6::actual.out <- stm_ref5::angle.in
														]]
													)
														[|{|terminate, stm_ref8::target_angle, stm_ref6::err_output|}|]
													(
														(
															let
																const_PID_kp = const_Module_PathPlanningController_stm_ref7_kp
																const_PID_ki = const_Module_PathPlanningController_stm_ref7_ki
																const_PID_kd = const_Module_PathPlanningController_stm_ref7_kd
																const_PID_step = const_Module_PathPlanningController_stm_ref7_step
															within 
															stm_ref7::D__(id__,
																	    const_PID_kp,
																	    const_PID_ki,
																	    const_PID_kd,
																	    const_PID_step)[[
																stm_ref7::terminate <- terminate,
																stm_ref7::target.in <- stm_ref8::target_speed.out,
																stm_ref7::target.out <- stm_ref8::target_speed.in,
																stm_ref7::actual.in <- stm_ref9::linear_speed.out,
																stm_ref7::actual.out <- stm_ref9::linear_speed.in
															]]
														)
															[|{|terminate, stm_ref8::target_speed, stm_ref7::err_output, stm_ref9::linear_speed|}|]
														(
															(
																let
																	const_MidLevelSM_step = const_Module_PathPlanningController_stm_ref8_step
																	const_MidLevelSM_climb_speed = const_Module_PathPlanningController_stm_ref8_climb_speed
																	const_MidLevelSM_descent_speed = const_Module_PathPlanningController_stm_ref8_descent_speed
																	const_MidLevelSM_side_speed = const_Module_PathPlanningController_stm_ref8_side_speed
																	const_MidLevelSM_forward_angle = const_Module_PathPlanningController_stm_ref8_forward_angle
																	const_MidLevelSM_left_angle = const_Module_PathPlanningController_stm_ref8_left_angle
																	const_MidLevelSM_right_angle = const_Module_PathPlanningController_stm_ref8_right_angle
																	const_MidLevelSM_turn_speed = const_Module_PathPlanningController_stm_ref8_turn_speed
																	const_MidLevelSM_movesp = const_Module_PathPlanningController_stm_ref8_movesp
																	const_MidLevelSM_stopsp = const_Module_PathPlanningController_stm_ref8_stopsp
																within 
																stm_ref8::D__(id__,
																		    const_MidLevelSM_step,
																		    const_MidLevelSM_climb_speed,
																		    const_MidLevelSM_descent_speed,
																		    const_MidLevelSM_side_speed,
																		    const_MidLevelSM_forward_angle,
																		    const_MidLevelSM_left_angle,
																		    const_MidLevelSM_right_angle,
																		    const_MidLevelSM_turn_speed,
																		    const_MidLevelSM_movesp,
																		    const_MidLevelSM_stopsp)[[
																	stm_ref8::terminate <- terminate,
																	stm_ref8::speed_adjustment.in <- stm_ref7::err_output.out,
																	stm_ref8::speed_adjustment.out <- stm_ref7::err_output.in,
																	stm_ref8::angle_adjustment.in <- stm_ref6::err_output.out,
																	stm_ref8::angle_adjustment.out <- stm_ref6::err_output.in,
																	stm_ref8::move_forward.in <- stm_ref0::move_forward.out,
																	stm_ref8::move_forward.out <- stm_ref0::move_forward.in,
																	stm_ref8::turn.in <- stm_ref0::turn.out,
																	stm_ref8::turn.out <- stm_ref0::turn.in,
																	stm_ref8::stop.in <- stm_ref0::stop.out,
																	stm_ref8::stop.out <- stm_ref0::stop.in,
																	stm_ref8::output_right_motorCall <- output_right_motorCall,
																	stm_ref8::output_left_motorCall <- output_left_motorCall
																]]
															)
																[|{|terminate|}|]
															(
																(
																	stm_ref9::D__(id__)[[
																		stm_ref9::terminate <- terminate,
																		stm_ref9::speed_l.in <- stm_ref1::sp.out,
																		stm_ref9::speed_l.out <- stm_ref1::sp.in,
																		stm_ref9::speed_r.in <- stm_ref12::output2.out,
																		stm_ref9::speed_r.out <- stm_ref12::output2.in
																	]]
																)
																	[|{|terminate, stm_ref12::output2|}|]
																(
																	(
																		stm_ref10::D__(id__)[[
																			stm_ref10::terminate <- terminate,
																			stm_ref10::input <- acc_l
																		]]
																	)
																		[|{|terminate|}|]
																	(
																		(
																			stm_ref11::D__(id__)[[
																				stm_ref11::terminate <- terminate,
																				stm_ref11::input <- acc_r
																			]]
																		)
																			[|{|terminate|}|]
																		(
																			stm_ref12::D__(id__)[[
																				stm_ref12::terminate <- terminate,
																				stm_ref12::input.in <- stm_ref2::sp.out,
																				stm_ref12::input.out <- stm_ref2::sp.in
																			]]
																		)
																	)
																	\diff(
																		{|terminate|},
																		{|terminate|}
																	)
																)
																\diff(
																	{|terminate|},
																	{|terminate|}
																)
															)
															\diff(
																{|terminate, stm_ref12::output2|},
																{|terminate|}
															)
														)
														\diff(
															{|terminate|},
															{|terminate|}
														)
													)
													\diff(
														{|terminate, stm_ref8::target_speed, stm_ref7::err_output, stm_ref9::linear_speed|},
														{|terminate|}
													)
												)
												\diff(
													{|terminate, stm_ref8::target_angle, stm_ref6::err_output|},
													{|terminate|}
												)
											)
											\diff(
												{|terminate, stm_ref5::angle, stm_ref10::output2, stm_ref11::output2|},
												{|terminate|}
											)
										)
										\diff(
											{|terminate|},
											{|terminate|}
										)
									)
									\diff(
										{|terminate, stm_ref12::output1|},
										{|terminate|}
									)
								)
								\diff(
									{|terminate, stm_ref11::output1, stm_ref2::sp|},
									{|terminate|}
								)
							)
							\diff(
								{|terminate, stm_ref1::sp, stm_ref10::output1|},
								{|terminate|}
							)
						)
						\diff(
							{|terminate, stm_ref0::clean, stm_ref3::displacement, stm_ref0::move_forward, stm_ref0::turn, stm_ref0::stop|},
							{|terminate|}
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						Memory(id__)
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<union(visibleMemoryEvents,{terminate}),{tock}>)
					
					-- VS version
					VS__(id__,
							    const_Module_PathPlanningController_stm_ref0_cliff,
							    const_Module_PathPlanningController_stm_ref0_nozzle,
							    const_Module_PathPlanningController_stm_ref0_battery_low,
							    const_Module_PathPlanningController_stm_ref0_sleep_time,
							    const_Module_PathPlanningController_stm_ref0_acc_distance,
							    const_Module_PathPlanningController_stm_ref1_t,
							    const_Module_PathPlanningController_stm_ref2_t,
							    const_Module_PathPlanningController_stm_ref3_t,
							    const_Module_PathPlanningController_stm_ref4_voltage,
							    const_Module_PathPlanningController_stm_ref5_t,
							    const_Module_PathPlanningController_stm_ref5_acc_distance,
							    const_Module_PathPlanningController_stm_ref6_kp,
							    const_Module_PathPlanningController_stm_ref6_ki,
							    const_Module_PathPlanningController_stm_ref6_kd,
							    const_Module_PathPlanningController_stm_ref6_step,
							    const_Module_PathPlanningController_stm_ref7_kp,
							    const_Module_PathPlanningController_stm_ref7_ki,
							    const_Module_PathPlanningController_stm_ref7_kd,
							    const_Module_PathPlanningController_stm_ref7_step,
							    const_Module_PathPlanningController_stm_ref8_step,
							    const_Module_PathPlanningController_stm_ref8_climb_speed,
							    const_Module_PathPlanningController_stm_ref8_descent_speed,
							    const_Module_PathPlanningController_stm_ref8_side_speed,
							    const_Module_PathPlanningController_stm_ref8_forward_angle,
							    const_Module_PathPlanningController_stm_ref8_left_angle,
							    const_Module_PathPlanningController_stm_ref8_right_angle,
							    const_Module_PathPlanningController_stm_ref8_turn_speed,
							    const_Module_PathPlanningController_stm_ref8_movesp,
							    const_Module_PathPlanningController_stm_ref8_stopsp) = prioritise(	((
							(
								let
									const_PathPlanningSM_cliff = const_Module_PathPlanningController_stm_ref0_cliff
									const_PathPlanningSM_nozzle = const_Module_PathPlanningController_stm_ref0_nozzle
									const_PathPlanningSM_battery_low = const_Module_PathPlanningController_stm_ref0_battery_low
									const_PathPlanningSM_sleep_time = const_Module_PathPlanningController_stm_ref0_sleep_time
									const_PathPlanningSM_acc_distance = const_Module_PathPlanningController_stm_ref0_acc_distance
								within 
								stm_ref0::VS__(id__,
										    const_PathPlanningSM_cliff,
										    const_PathPlanningSM_nozzle,
										    const_PathPlanningSM_battery_low,
										    const_PathPlanningSM_sleep_time,
										    const_PathPlanningSM_acc_distance)[[
									stm_ref0::terminate <- terminate,
									stm_ref0::displacement.in <- stm_ref3::displacement.out,
									stm_ref0::displacement.out <- stm_ref3::displacement.in,
									stm_ref0::ultrasonic <- ultrasonic,
									stm_ref0::battery_level <- battery_level,
									stm_ref0::charging <- charging
								]]
							)
								[|{|terminate, stm_ref0::clean, stm_ref3::displacement, stm_ref0::move_forward, stm_ref0::turn, stm_ref0::stop|}|]
							(
								(
									let
										const_SpeedSM_t = const_Module_PathPlanningController_stm_ref1_t
									within 
									stm_ref1::VS__(id__,
											    const_SpeedSM_t)[[
										stm_ref1::terminate <- terminate,
										stm_ref1::acc.in <- stm_ref10::output1.out,
										stm_ref1::acc.out <- stm_ref10::output1.in
									]]
								)
									[|{|terminate, stm_ref1::sp, stm_ref10::output1|}|]
								(
									(
										let
											const_SpeedSM_t = const_Module_PathPlanningController_stm_ref2_t
										within 
										stm_ref2::VS__(id__,
												    const_SpeedSM_t)[[
											stm_ref2::terminate <- terminate,
											stm_ref2::acc.in <- stm_ref11::output1.out,
											stm_ref2::acc.out <- stm_ref11::output1.in
										]]
									)
										[|{|terminate, stm_ref11::output1, stm_ref2::sp|}|]
									(
										(
											let
												const_DisplacementSM_t = const_Module_PathPlanningController_stm_ref3_t
											within 
											stm_ref3::VS__(id__,
													    const_DisplacementSM_t)[[
												stm_ref3::terminate <- terminate,
												stm_ref3::sp.in <- stm_ref12::output1.out,
												stm_ref3::sp.out <- stm_ref12::output1.in
											]]
										)
											[|{|terminate, stm_ref12::output1|}|]
										(
											(
												let
													const_CleanSM_voltage = const_Module_PathPlanningController_stm_ref4_voltage
												within 
												stm_ref4::VS__(id__,
														    const_CleanSM_voltage)[[
													stm_ref4::terminate <- terminate,
													stm_ref4::clean.in <- stm_ref0::clean.out,
													stm_ref4::clean.out <- stm_ref0::clean.in,
													stm_ref4::vacuumCall <- vacuumCall,
													stm_ref4::brushCall <- brushCall
												]]
											)
												[|{|terminate|}|]
											(
												(
													let
														const_AngularSpeedSM_t = const_Module_PathPlanningController_stm_ref5_t
														const_AngularSpeedSM_acc_distance = const_Module_PathPlanningController_stm_ref5_acc_distance
													within 
													stm_ref5::VS__(id__,
															    const_AngularSpeedSM_t,
															    const_AngularSpeedSM_acc_distance)[[
														stm_ref5::terminate <- terminate,
														stm_ref5::acc_l.in <- stm_ref10::output2.out,
														stm_ref5::acc_l.out <- stm_ref10::output2.in,
														stm_ref5::acc_r.in <- stm_ref11::output2.out,
														stm_ref5::acc_r.out <- stm_ref11::output2.in
													]]
												)
													[|{|terminate, stm_ref5::angle, stm_ref10::output2, stm_ref11::output2|}|]
												(
													(
														let
															const_PID_kp = const_Module_PathPlanningController_stm_ref6_kp
															const_PID_ki = const_Module_PathPlanningController_stm_ref6_ki
															const_PID_kd = const_Module_PathPlanningController_stm_ref6_kd
															const_PID_step = const_Module_PathPlanningController_stm_ref6_step
														within 
														stm_ref6::VS__(id__,
																    const_PID_kp,
																    const_PID_ki,
																    const_PID_kd,
																    const_PID_step)[[
															stm_ref6::terminate <- terminate,
															stm_ref6::target.in <- stm_ref8::target_angle.out,
															stm_ref6::target.out <- stm_ref8::target_angle.in,
															stm_ref6::actual.in <- stm_ref5::angle.out,
															stm_ref6::actual.out <- stm_ref5::angle.in
														]]
													)
														[|{|terminate, stm_ref8::target_angle, stm_ref6::err_output|}|]
													(
														(
															let
																const_PID_kp = const_Module_PathPlanningController_stm_ref7_kp
																const_PID_ki = const_Module_PathPlanningController_stm_ref7_ki
																const_PID_kd = const_Module_PathPlanningController_stm_ref7_kd
																const_PID_step = const_Module_PathPlanningController_stm_ref7_step
															within 
															stm_ref7::VS__(id__,
																	    const_PID_kp,
																	    const_PID_ki,
																	    const_PID_kd,
																	    const_PID_step)[[
																stm_ref7::terminate <- terminate,
																stm_ref7::target.in <- stm_ref8::target_speed.out,
																stm_ref7::target.out <- stm_ref8::target_speed.in,
																stm_ref7::actual.in <- stm_ref9::linear_speed.out,
																stm_ref7::actual.out <- stm_ref9::linear_speed.in
															]]
														)
															[|{|terminate, stm_ref8::target_speed, stm_ref7::err_output, stm_ref9::linear_speed|}|]
														(
															(
																let
																	const_MidLevelSM_step = const_Module_PathPlanningController_stm_ref8_step
																	const_MidLevelSM_climb_speed = const_Module_PathPlanningController_stm_ref8_climb_speed
																	const_MidLevelSM_descent_speed = const_Module_PathPlanningController_stm_ref8_descent_speed
																	const_MidLevelSM_side_speed = const_Module_PathPlanningController_stm_ref8_side_speed
																	const_MidLevelSM_forward_angle = const_Module_PathPlanningController_stm_ref8_forward_angle
																	const_MidLevelSM_left_angle = const_Module_PathPlanningController_stm_ref8_left_angle
																	const_MidLevelSM_right_angle = const_Module_PathPlanningController_stm_ref8_right_angle
																	const_MidLevelSM_turn_speed = const_Module_PathPlanningController_stm_ref8_turn_speed
																	const_MidLevelSM_movesp = const_Module_PathPlanningController_stm_ref8_movesp
																	const_MidLevelSM_stopsp = const_Module_PathPlanningController_stm_ref8_stopsp
																within 
																stm_ref8::VS__(id__,
																		    const_MidLevelSM_step,
																		    const_MidLevelSM_climb_speed,
																		    const_MidLevelSM_descent_speed,
																		    const_MidLevelSM_side_speed,
																		    const_MidLevelSM_forward_angle,
																		    const_MidLevelSM_left_angle,
																		    const_MidLevelSM_right_angle,
																		    const_MidLevelSM_turn_speed,
																		    const_MidLevelSM_movesp,
																		    const_MidLevelSM_stopsp)[[
																	stm_ref8::terminate <- terminate,
																	stm_ref8::speed_adjustment.in <- stm_ref7::err_output.out,
																	stm_ref8::speed_adjustment.out <- stm_ref7::err_output.in,
																	stm_ref8::angle_adjustment.in <- stm_ref6::err_output.out,
																	stm_ref8::angle_adjustment.out <- stm_ref6::err_output.in,
																	stm_ref8::move_forward.in <- stm_ref0::move_forward.out,
																	stm_ref8::move_forward.out <- stm_ref0::move_forward.in,
																	stm_ref8::turn.in <- stm_ref0::turn.out,
																	stm_ref8::turn.out <- stm_ref0::turn.in,
																	stm_ref8::stop.in <- stm_ref0::stop.out,
																	stm_ref8::stop.out <- stm_ref0::stop.in,
																	stm_ref8::output_right_motorCall <- output_right_motorCall,
																	stm_ref8::output_left_motorCall <- output_left_motorCall
																]]
															)
																[|{|terminate|}|]
															(
																(
																	stm_ref9::VS__(id__)[[
																		stm_ref9::terminate <- terminate,
																		stm_ref9::speed_l.in <- stm_ref1::sp.out,
																		stm_ref9::speed_l.out <- stm_ref1::sp.in,
																		stm_ref9::speed_r.in <- stm_ref12::output2.out,
																		stm_ref9::speed_r.out <- stm_ref12::output2.in
																	]]
																)
																	[|{|terminate, stm_ref12::output2|}|]
																(
																	(
																		stm_ref10::VS__(id__)[[
																			stm_ref10::terminate <- terminate,
																			stm_ref10::input <- acc_l
																		]]
																	)
																		[|{|terminate|}|]
																	(
																		(
																			stm_ref11::VS__(id__)[[
																				stm_ref11::terminate <- terminate,
																				stm_ref11::input <- acc_r
																			]]
																		)
																			[|{|terminate|}|]
																		(
																			stm_ref12::VS__(id__)[[
																				stm_ref12::terminate <- terminate,
																				stm_ref12::input.in <- stm_ref2::sp.out,
																				stm_ref12::input.out <- stm_ref2::sp.in
																			]]
																		)
																	)
																	\diff(
																		{|terminate|},
																		{|terminate|}
																	)
																)
																\diff(
																	{|terminate|},
																	{|terminate|}
																)
															)
															\diff(
																{|terminate, stm_ref12::output2|},
																{|terminate|}
															)
														)
														\diff(
															{|terminate|},
															{|terminate|}
														)
													)
													\diff(
														{|terminate, stm_ref8::target_speed, stm_ref7::err_output, stm_ref9::linear_speed|},
														{|terminate|}
													)
												)
												\diff(
													{|terminate, stm_ref8::target_angle, stm_ref6::err_output|},
													{|terminate|}
												)
											)
											\diff(
												{|terminate, stm_ref5::angle, stm_ref10::output2, stm_ref11::output2|},
												{|terminate|}
											)
										)
										\diff(
											{|terminate|},
											{|terminate|}
										)
									)
									\diff(
										{|terminate, stm_ref12::output1|},
										{|terminate|}
									)
								)
								\diff(
									{|terminate, stm_ref11::output1, stm_ref2::sp|},
									{|terminate|}
								)
							)
							\diff(
								{|terminate, stm_ref1::sp, stm_ref10::output1|},
								{|terminate|}
							)
						)
						\diff(
							{|terminate, stm_ref0::clean, stm_ref3::displacement, stm_ref0::move_forward, stm_ref0::turn, stm_ref0::stop|},
							{|terminate|}
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						Memory(id__)
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<union(visibleMemoryEvents,{terminate}),{tock}>)
				
					-- O version (optimised) THESE TWO PROCESSES SHOULD BE KEPT IN SYNC WITH THE ABOVE TWO
					O__(id__,
							    const_Module_PathPlanningController_stm_ref0_cliff,
							    const_Module_PathPlanningController_stm_ref0_nozzle,
							    const_Module_PathPlanningController_stm_ref0_battery_low,
							    const_Module_PathPlanningController_stm_ref0_sleep_time,
							    const_Module_PathPlanningController_stm_ref0_acc_distance,
							    const_Module_PathPlanningController_stm_ref1_t,
							    const_Module_PathPlanningController_stm_ref2_t,
							    const_Module_PathPlanningController_stm_ref3_t,
							    const_Module_PathPlanningController_stm_ref4_voltage,
							    const_Module_PathPlanningController_stm_ref5_t,
							    const_Module_PathPlanningController_stm_ref5_acc_distance,
							    const_Module_PathPlanningController_stm_ref6_kp,
							    const_Module_PathPlanningController_stm_ref6_ki,
							    const_Module_PathPlanningController_stm_ref6_kd,
							    const_Module_PathPlanningController_stm_ref6_step,
							    const_Module_PathPlanningController_stm_ref7_kp,
							    const_Module_PathPlanningController_stm_ref7_ki,
							    const_Module_PathPlanningController_stm_ref7_kd,
							    const_Module_PathPlanningController_stm_ref7_step,
							    const_Module_PathPlanningController_stm_ref8_step,
							    const_Module_PathPlanningController_stm_ref8_climb_speed,
							    const_Module_PathPlanningController_stm_ref8_descent_speed,
							    const_Module_PathPlanningController_stm_ref8_side_speed,
							    const_Module_PathPlanningController_stm_ref8_forward_angle,
							    const_Module_PathPlanningController_stm_ref8_left_angle,
							    const_Module_PathPlanningController_stm_ref8_right_angle,
							    const_Module_PathPlanningController_stm_ref8_turn_speed,
							    const_Module_PathPlanningController_stm_ref8_movesp,
							    const_Module_PathPlanningController_stm_ref8_stopsp) = dbisim(prioritise(	((
							(
								let
									const_PathPlanningSM_cliff = const_Module_PathPlanningController_stm_ref0_cliff
									const_PathPlanningSM_nozzle = const_Module_PathPlanningController_stm_ref0_nozzle
									const_PathPlanningSM_battery_low = const_Module_PathPlanningController_stm_ref0_battery_low
									const_PathPlanningSM_sleep_time = const_Module_PathPlanningController_stm_ref0_sleep_time
									const_PathPlanningSM_acc_distance = const_Module_PathPlanningController_stm_ref0_acc_distance
								within 
								stm_ref0::O__(id__,
										    const_PathPlanningSM_cliff,
										    const_PathPlanningSM_nozzle,
										    const_PathPlanningSM_battery_low,
										    const_PathPlanningSM_sleep_time,
										    const_PathPlanningSM_acc_distance)[[
									stm_ref0::terminate <- terminate,
									stm_ref0::displacement.in <- stm_ref3::displacement.out,
									stm_ref0::displacement.out <- stm_ref3::displacement.in,
									stm_ref0::ultrasonic <- ultrasonic,
									stm_ref0::battery_level <- battery_level,
									stm_ref0::charging <- charging
								]]
							)
								[|{|terminate, stm_ref0::clean, stm_ref3::displacement, stm_ref0::move_forward, stm_ref0::turn, stm_ref0::stop|}|]
							(
								(
									let
										const_SpeedSM_t = const_Module_PathPlanningController_stm_ref1_t
									within 
									stm_ref1::O__(id__,
											    const_SpeedSM_t)[[
										stm_ref1::terminate <- terminate,
										stm_ref1::acc.in <- stm_ref10::output1.out,
										stm_ref1::acc.out <- stm_ref10::output1.in
									]]
								)
									[|{|terminate, stm_ref1::sp, stm_ref10::output1|}|]
								(
									(
										let
											const_SpeedSM_t = const_Module_PathPlanningController_stm_ref2_t
										within 
										stm_ref2::O__(id__,
												    const_SpeedSM_t)[[
											stm_ref2::terminate <- terminate,
											stm_ref2::acc.in <- stm_ref11::output1.out,
											stm_ref2::acc.out <- stm_ref11::output1.in
										]]
									)
										[|{|terminate, stm_ref11::output1, stm_ref2::sp|}|]
									(
										(
											let
												const_DisplacementSM_t = const_Module_PathPlanningController_stm_ref3_t
											within 
											stm_ref3::O__(id__,
													    const_DisplacementSM_t)[[
												stm_ref3::terminate <- terminate,
												stm_ref3::sp.in <- stm_ref12::output1.out,
												stm_ref3::sp.out <- stm_ref12::output1.in
											]]
										)
											[|{|terminate, stm_ref12::output1|}|]
										(
											(
												let
													const_CleanSM_voltage = const_Module_PathPlanningController_stm_ref4_voltage
												within 
												stm_ref4::O__(id__,
														    const_CleanSM_voltage)[[
													stm_ref4::terminate <- terminate,
													stm_ref4::clean.in <- stm_ref0::clean.out,
													stm_ref4::clean.out <- stm_ref0::clean.in,
													stm_ref4::vacuumCall <- vacuumCall,
													stm_ref4::brushCall <- brushCall
												]]
											)
												[|{|terminate|}|]
											(
												(
													let
														const_AngularSpeedSM_t = const_Module_PathPlanningController_stm_ref5_t
														const_AngularSpeedSM_acc_distance = const_Module_PathPlanningController_stm_ref5_acc_distance
													within 
													stm_ref5::O__(id__,
															    const_AngularSpeedSM_t,
															    const_AngularSpeedSM_acc_distance)[[
														stm_ref5::terminate <- terminate,
														stm_ref5::acc_l.in <- stm_ref10::output2.out,
														stm_ref5::acc_l.out <- stm_ref10::output2.in,
														stm_ref5::acc_r.in <- stm_ref11::output2.out,
														stm_ref5::acc_r.out <- stm_ref11::output2.in
													]]
												)
													[|{|terminate, stm_ref5::angle, stm_ref10::output2, stm_ref11::output2|}|]
												(
													(
														let
															const_PID_kp = const_Module_PathPlanningController_stm_ref6_kp
															const_PID_ki = const_Module_PathPlanningController_stm_ref6_ki
															const_PID_kd = const_Module_PathPlanningController_stm_ref6_kd
															const_PID_step = const_Module_PathPlanningController_stm_ref6_step
														within 
														stm_ref6::O__(id__,
																    const_PID_kp,
																    const_PID_ki,
																    const_PID_kd,
																    const_PID_step)[[
															stm_ref6::terminate <- terminate,
															stm_ref6::target.in <- stm_ref8::target_angle.out,
															stm_ref6::target.out <- stm_ref8::target_angle.in,
															stm_ref6::actual.in <- stm_ref5::angle.out,
															stm_ref6::actual.out <- stm_ref5::angle.in
														]]
													)
														[|{|terminate, stm_ref8::target_angle, stm_ref6::err_output|}|]
													(
														(
															let
																const_PID_kp = const_Module_PathPlanningController_stm_ref7_kp
																const_PID_ki = const_Module_PathPlanningController_stm_ref7_ki
																const_PID_kd = const_Module_PathPlanningController_stm_ref7_kd
																const_PID_step = const_Module_PathPlanningController_stm_ref7_step
															within 
															stm_ref7::O__(id__,
																	    const_PID_kp,
																	    const_PID_ki,
																	    const_PID_kd,
																	    const_PID_step)[[
																stm_ref7::terminate <- terminate,
																stm_ref7::target.in <- stm_ref8::target_speed.out,
																stm_ref7::target.out <- stm_ref8::target_speed.in,
																stm_ref7::actual.in <- stm_ref9::linear_speed.out,
																stm_ref7::actual.out <- stm_ref9::linear_speed.in
															]]
														)
															[|{|terminate, stm_ref8::target_speed, stm_ref7::err_output, stm_ref9::linear_speed|}|]
														(
															(
																let
																	const_MidLevelSM_step = const_Module_PathPlanningController_stm_ref8_step
																	const_MidLevelSM_climb_speed = const_Module_PathPlanningController_stm_ref8_climb_speed
																	const_MidLevelSM_descent_speed = const_Module_PathPlanningController_stm_ref8_descent_speed
																	const_MidLevelSM_side_speed = const_Module_PathPlanningController_stm_ref8_side_speed
																	const_MidLevelSM_forward_angle = const_Module_PathPlanningController_stm_ref8_forward_angle
																	const_MidLevelSM_left_angle = const_Module_PathPlanningController_stm_ref8_left_angle
																	const_MidLevelSM_right_angle = const_Module_PathPlanningController_stm_ref8_right_angle
																	const_MidLevelSM_turn_speed = const_Module_PathPlanningController_stm_ref8_turn_speed
																	const_MidLevelSM_movesp = const_Module_PathPlanningController_stm_ref8_movesp
																	const_MidLevelSM_stopsp = const_Module_PathPlanningController_stm_ref8_stopsp
																within 
																stm_ref8::O__(id__,
																		    const_MidLevelSM_step,
																		    const_MidLevelSM_climb_speed,
																		    const_MidLevelSM_descent_speed,
																		    const_MidLevelSM_side_speed,
																		    const_MidLevelSM_forward_angle,
																		    const_MidLevelSM_left_angle,
																		    const_MidLevelSM_right_angle,
																		    const_MidLevelSM_turn_speed,
																		    const_MidLevelSM_movesp,
																		    const_MidLevelSM_stopsp)[[
																	stm_ref8::terminate <- terminate,
																	stm_ref8::speed_adjustment.in <- stm_ref7::err_output.out,
																	stm_ref8::speed_adjustment.out <- stm_ref7::err_output.in,
																	stm_ref8::angle_adjustment.in <- stm_ref6::err_output.out,
																	stm_ref8::angle_adjustment.out <- stm_ref6::err_output.in,
																	stm_ref8::move_forward.in <- stm_ref0::move_forward.out,
																	stm_ref8::move_forward.out <- stm_ref0::move_forward.in,
																	stm_ref8::turn.in <- stm_ref0::turn.out,
																	stm_ref8::turn.out <- stm_ref0::turn.in,
																	stm_ref8::stop.in <- stm_ref0::stop.out,
																	stm_ref8::stop.out <- stm_ref0::stop.in,
																	stm_ref8::output_right_motorCall <- output_right_motorCall,
																	stm_ref8::output_left_motorCall <- output_left_motorCall
																]]
															)
																[|{|terminate|}|]
															(
																(
																	stm_ref9::O__(id__)[[
																		stm_ref9::terminate <- terminate,
																		stm_ref9::speed_l.in <- stm_ref1::sp.out,
																		stm_ref9::speed_l.out <- stm_ref1::sp.in,
																		stm_ref9::speed_r.in <- stm_ref12::output2.out,
																		stm_ref9::speed_r.out <- stm_ref12::output2.in
																	]]
																)
																	[|{|terminate, stm_ref12::output2|}|]
																(
																	(
																		stm_ref10::O__(id__)[[
																			stm_ref10::terminate <- terminate,
																			stm_ref10::input <- acc_l
																		]]
																	)
																		[|{|terminate|}|]
																	(
																		(
																			stm_ref11::O__(id__)[[
																				stm_ref11::terminate <- terminate,
																				stm_ref11::input <- acc_r
																			]]
																		)
																			[|{|terminate|}|]
																		(
																			stm_ref12::O__(id__)[[
																				stm_ref12::terminate <- terminate,
																				stm_ref12::input.in <- stm_ref2::sp.out,
																				stm_ref12::input.out <- stm_ref2::sp.in
																			]]
																		)
																	)
																	\diff(
																		{|terminate|},
																		{|terminate|}
																	)
																)
																\diff(
																	{|terminate|},
																	{|terminate|}
																)
															)
															\diff(
																{|terminate, stm_ref12::output2|},
																{|terminate|}
															)
														)
														\diff(
															{|terminate|},
															{|terminate|}
														)
													)
													\diff(
														{|terminate, stm_ref8::target_speed, stm_ref7::err_output, stm_ref9::linear_speed|},
														{|terminate|}
													)
												)
												\diff(
													{|terminate, stm_ref8::target_angle, stm_ref6::err_output|},
													{|terminate|}
												)
											)
											\diff(
												{|terminate, stm_ref5::angle, stm_ref10::output2, stm_ref11::output2|},
												{|terminate|}
											)
										)
										\diff(
											{|terminate|},
											{|terminate|}
										)
									)
									\diff(
										{|terminate, stm_ref12::output1|},
										{|terminate|}
									)
								)
								\diff(
									{|terminate, stm_ref11::output1, stm_ref2::sp|},
									{|terminate|}
								)
							)
							\diff(
								{|terminate, stm_ref1::sp, stm_ref10::output1|},
								{|terminate|}
							)
						)
						\diff(
							{|terminate, stm_ref0::clean, stm_ref3::displacement, stm_ref0::move_forward, stm_ref0::turn, stm_ref0::stop|},
							{|terminate|}
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<union(visibleMemoryEvents,{terminate}),{tock}>))
									
					-- VS_O version
					VS_O__(id__,
							    const_Module_PathPlanningController_stm_ref0_cliff,
							    const_Module_PathPlanningController_stm_ref0_nozzle,
							    const_Module_PathPlanningController_stm_ref0_battery_low,
							    const_Module_PathPlanningController_stm_ref0_sleep_time,
							    const_Module_PathPlanningController_stm_ref0_acc_distance,
							    const_Module_PathPlanningController_stm_ref1_t,
							    const_Module_PathPlanningController_stm_ref2_t,
							    const_Module_PathPlanningController_stm_ref3_t,
							    const_Module_PathPlanningController_stm_ref4_voltage,
							    const_Module_PathPlanningController_stm_ref5_t,
							    const_Module_PathPlanningController_stm_ref5_acc_distance,
							    const_Module_PathPlanningController_stm_ref6_kp,
							    const_Module_PathPlanningController_stm_ref6_ki,
							    const_Module_PathPlanningController_stm_ref6_kd,
							    const_Module_PathPlanningController_stm_ref6_step,
							    const_Module_PathPlanningController_stm_ref7_kp,
							    const_Module_PathPlanningController_stm_ref7_ki,
							    const_Module_PathPlanningController_stm_ref7_kd,
							    const_Module_PathPlanningController_stm_ref7_step,
							    const_Module_PathPlanningController_stm_ref8_step,
							    const_Module_PathPlanningController_stm_ref8_climb_speed,
							    const_Module_PathPlanningController_stm_ref8_descent_speed,
							    const_Module_PathPlanningController_stm_ref8_side_speed,
							    const_Module_PathPlanningController_stm_ref8_forward_angle,
							    const_Module_PathPlanningController_stm_ref8_left_angle,
							    const_Module_PathPlanningController_stm_ref8_right_angle,
							    const_Module_PathPlanningController_stm_ref8_turn_speed,
							    const_Module_PathPlanningController_stm_ref8_movesp,
							    const_Module_PathPlanningController_stm_ref8_stopsp) = dbisim(prioritise(	((
							(
								let
									const_PathPlanningSM_cliff = const_Module_PathPlanningController_stm_ref0_cliff
									const_PathPlanningSM_nozzle = const_Module_PathPlanningController_stm_ref0_nozzle
									const_PathPlanningSM_battery_low = const_Module_PathPlanningController_stm_ref0_battery_low
									const_PathPlanningSM_sleep_time = const_Module_PathPlanningController_stm_ref0_sleep_time
									const_PathPlanningSM_acc_distance = const_Module_PathPlanningController_stm_ref0_acc_distance
								within 
								stm_ref0::VS_O__(id__,
										    const_PathPlanningSM_cliff,
										    const_PathPlanningSM_nozzle,
										    const_PathPlanningSM_battery_low,
										    const_PathPlanningSM_sleep_time,
										    const_PathPlanningSM_acc_distance)[[
									stm_ref0::terminate <- terminate,
									stm_ref0::displacement.in <- stm_ref3::displacement.out,
									stm_ref0::displacement.out <- stm_ref3::displacement.in,
									stm_ref0::ultrasonic <- ultrasonic,
									stm_ref0::battery_level <- battery_level,
									stm_ref0::charging <- charging
								]]
							)
								[|{|terminate, stm_ref0::clean, stm_ref3::displacement, stm_ref0::move_forward, stm_ref0::turn, stm_ref0::stop|}|]
							(
								(
									let
										const_SpeedSM_t = const_Module_PathPlanningController_stm_ref1_t
									within 
									stm_ref1::VS_O__(id__,
											    const_SpeedSM_t)[[
										stm_ref1::terminate <- terminate,
										stm_ref1::acc.in <- stm_ref10::output1.out,
										stm_ref1::acc.out <- stm_ref10::output1.in
									]]
								)
									[|{|terminate, stm_ref1::sp, stm_ref10::output1|}|]
								(
									(
										let
											const_SpeedSM_t = const_Module_PathPlanningController_stm_ref2_t
										within 
										stm_ref2::VS_O__(id__,
												    const_SpeedSM_t)[[
											stm_ref2::terminate <- terminate,
											stm_ref2::acc.in <- stm_ref11::output1.out,
											stm_ref2::acc.out <- stm_ref11::output1.in
										]]
									)
										[|{|terminate, stm_ref11::output1, stm_ref2::sp|}|]
									(
										(
											let
												const_DisplacementSM_t = const_Module_PathPlanningController_stm_ref3_t
											within 
											stm_ref3::VS_O__(id__,
													    const_DisplacementSM_t)[[
												stm_ref3::terminate <- terminate,
												stm_ref3::sp.in <- stm_ref12::output1.out,
												stm_ref3::sp.out <- stm_ref12::output1.in
											]]
										)
											[|{|terminate, stm_ref12::output1|}|]
										(
											(
												let
													const_CleanSM_voltage = const_Module_PathPlanningController_stm_ref4_voltage
												within 
												stm_ref4::VS_O__(id__,
														    const_CleanSM_voltage)[[
													stm_ref4::terminate <- terminate,
													stm_ref4::clean.in <- stm_ref0::clean.out,
													stm_ref4::clean.out <- stm_ref0::clean.in,
													stm_ref4::vacuumCall <- vacuumCall,
													stm_ref4::brushCall <- brushCall
												]]
											)
												[|{|terminate|}|]
											(
												(
													let
														const_AngularSpeedSM_t = const_Module_PathPlanningController_stm_ref5_t
														const_AngularSpeedSM_acc_distance = const_Module_PathPlanningController_stm_ref5_acc_distance
													within 
													stm_ref5::VS_O__(id__,
															    const_AngularSpeedSM_t,
															    const_AngularSpeedSM_acc_distance)[[
														stm_ref5::terminate <- terminate,
														stm_ref5::acc_l.in <- stm_ref10::output2.out,
														stm_ref5::acc_l.out <- stm_ref10::output2.in,
														stm_ref5::acc_r.in <- stm_ref11::output2.out,
														stm_ref5::acc_r.out <- stm_ref11::output2.in
													]]
												)
													[|{|terminate, stm_ref5::angle, stm_ref10::output2, stm_ref11::output2|}|]
												(
													(
														let
															const_PID_kp = const_Module_PathPlanningController_stm_ref6_kp
															const_PID_ki = const_Module_PathPlanningController_stm_ref6_ki
															const_PID_kd = const_Module_PathPlanningController_stm_ref6_kd
															const_PID_step = const_Module_PathPlanningController_stm_ref6_step
														within 
														stm_ref6::VS_O__(id__,
																    const_PID_kp,
																    const_PID_ki,
																    const_PID_kd,
																    const_PID_step)[[
															stm_ref6::terminate <- terminate,
															stm_ref6::target.in <- stm_ref8::target_angle.out,
															stm_ref6::target.out <- stm_ref8::target_angle.in,
															stm_ref6::actual.in <- stm_ref5::angle.out,
															stm_ref6::actual.out <- stm_ref5::angle.in
														]]
													)
														[|{|terminate, stm_ref8::target_angle, stm_ref6::err_output|}|]
													(
														(
															let
																const_PID_kp = const_Module_PathPlanningController_stm_ref7_kp
																const_PID_ki = const_Module_PathPlanningController_stm_ref7_ki
																const_PID_kd = const_Module_PathPlanningController_stm_ref7_kd
																const_PID_step = const_Module_PathPlanningController_stm_ref7_step
															within 
															stm_ref7::VS_O__(id__,
																	    const_PID_kp,
																	    const_PID_ki,
																	    const_PID_kd,
																	    const_PID_step)[[
																stm_ref7::terminate <- terminate,
																stm_ref7::target.in <- stm_ref8::target_speed.out,
																stm_ref7::target.out <- stm_ref8::target_speed.in,
																stm_ref7::actual.in <- stm_ref9::linear_speed.out,
																stm_ref7::actual.out <- stm_ref9::linear_speed.in
															]]
														)
															[|{|terminate, stm_ref8::target_speed, stm_ref7::err_output, stm_ref9::linear_speed|}|]
														(
															(
																let
																	const_MidLevelSM_step = const_Module_PathPlanningController_stm_ref8_step
																	const_MidLevelSM_climb_speed = const_Module_PathPlanningController_stm_ref8_climb_speed
																	const_MidLevelSM_descent_speed = const_Module_PathPlanningController_stm_ref8_descent_speed
																	const_MidLevelSM_side_speed = const_Module_PathPlanningController_stm_ref8_side_speed
																	const_MidLevelSM_forward_angle = const_Module_PathPlanningController_stm_ref8_forward_angle
																	const_MidLevelSM_left_angle = const_Module_PathPlanningController_stm_ref8_left_angle
																	const_MidLevelSM_right_angle = const_Module_PathPlanningController_stm_ref8_right_angle
																	const_MidLevelSM_turn_speed = const_Module_PathPlanningController_stm_ref8_turn_speed
																	const_MidLevelSM_movesp = const_Module_PathPlanningController_stm_ref8_movesp
																	const_MidLevelSM_stopsp = const_Module_PathPlanningController_stm_ref8_stopsp
																within 
																stm_ref8::VS_O__(id__,
																		    const_MidLevelSM_step,
																		    const_MidLevelSM_climb_speed,
																		    const_MidLevelSM_descent_speed,
																		    const_MidLevelSM_side_speed,
																		    const_MidLevelSM_forward_angle,
																		    const_MidLevelSM_left_angle,
																		    const_MidLevelSM_right_angle,
																		    const_MidLevelSM_turn_speed,
																		    const_MidLevelSM_movesp,
																		    const_MidLevelSM_stopsp)[[
																	stm_ref8::terminate <- terminate,
																	stm_ref8::speed_adjustment.in <- stm_ref7::err_output.out,
																	stm_ref8::speed_adjustment.out <- stm_ref7::err_output.in,
																	stm_ref8::angle_adjustment.in <- stm_ref6::err_output.out,
																	stm_ref8::angle_adjustment.out <- stm_ref6::err_output.in,
																	stm_ref8::move_forward.in <- stm_ref0::move_forward.out,
																	stm_ref8::move_forward.out <- stm_ref0::move_forward.in,
																	stm_ref8::turn.in <- stm_ref0::turn.out,
																	stm_ref8::turn.out <- stm_ref0::turn.in,
																	stm_ref8::stop.in <- stm_ref0::stop.out,
																	stm_ref8::stop.out <- stm_ref0::stop.in,
																	stm_ref8::output_right_motorCall <- output_right_motorCall,
																	stm_ref8::output_left_motorCall <- output_left_motorCall
																]]
															)
																[|{|terminate|}|]
															(
																(
																	stm_ref9::VS_O__(id__)[[
																		stm_ref9::terminate <- terminate,
																		stm_ref9::speed_l.in <- stm_ref1::sp.out,
																		stm_ref9::speed_l.out <- stm_ref1::sp.in,
																		stm_ref9::speed_r.in <- stm_ref12::output2.out,
																		stm_ref9::speed_r.out <- stm_ref12::output2.in
																	]]
																)
																	[|{|terminate, stm_ref12::output2|}|]
																(
																	(
																		stm_ref10::VS_O__(id__)[[
																			stm_ref10::terminate <- terminate,
																			stm_ref10::input <- acc_l
																		]]
																	)
																		[|{|terminate|}|]
																	(
																		(
																			stm_ref11::VS_O__(id__)[[
																				stm_ref11::terminate <- terminate,
																				stm_ref11::input <- acc_r
																			]]
																		)
																			[|{|terminate|}|]
																		(
																			stm_ref12::VS_O__(id__)[[
																				stm_ref12::terminate <- terminate,
																				stm_ref12::input.in <- stm_ref2::sp.out,
																				stm_ref12::input.out <- stm_ref2::sp.in
																			]]
																		)
																	)
																	\diff(
																		{|terminate|},
																		{|terminate|}
																	)
																)
																\diff(
																	{|terminate|},
																	{|terminate|}
																)
															)
															\diff(
																{|terminate, stm_ref12::output2|},
																{|terminate|}
															)
														)
														\diff(
															{|terminate|},
															{|terminate|}
														)
													)
													\diff(
														{|terminate, stm_ref8::target_speed, stm_ref7::err_output, stm_ref9::linear_speed|},
														{|terminate|}
													)
												)
												\diff(
													{|terminate, stm_ref8::target_angle, stm_ref6::err_output|},
													{|terminate|}
												)
											)
											\diff(
												{|terminate, stm_ref5::angle, stm_ref10::output2, stm_ref11::output2|},
												{|terminate|}
											)
										)
										\diff(
											{|terminate|},
											{|terminate|}
										)
									)
									\diff(
										{|terminate, stm_ref12::output1|},
										{|terminate|}
									)
								)
								\diff(
									{|terminate, stm_ref11::output1, stm_ref2::sp|},
									{|terminate|}
								)
							)
							\diff(
								{|terminate, stm_ref1::sp, stm_ref10::output1|},
								{|terminate|}
							)
						)
						\diff(
							{|terminate, stm_ref0::clean, stm_ref3::displacement, stm_ref0::move_forward, stm_ref0::turn, stm_ref0::stop|},
							{|terminate|}
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<union(visibleMemoryEvents,{terminate}),{tock}>))
				
					HEXT(id__,
							    const_Module_PathPlanningController_stm_ref0_cliff,
							    const_Module_PathPlanningController_stm_ref0_nozzle,
							    const_Module_PathPlanningController_stm_ref0_battery_low,
							    const_Module_PathPlanningController_stm_ref0_sleep_time,
							    const_Module_PathPlanningController_stm_ref0_acc_distance,
							    const_Module_PathPlanningController_stm_ref1_t,
							    const_Module_PathPlanningController_stm_ref2_t,
							    const_Module_PathPlanningController_stm_ref3_t,
							    const_Module_PathPlanningController_stm_ref4_voltage,
							    const_Module_PathPlanningController_stm_ref5_t,
							    const_Module_PathPlanningController_stm_ref5_acc_distance,
							    const_Module_PathPlanningController_stm_ref6_kp,
							    const_Module_PathPlanningController_stm_ref6_ki,
							    const_Module_PathPlanningController_stm_ref6_kd,
							    const_Module_PathPlanningController_stm_ref6_step,
							    const_Module_PathPlanningController_stm_ref7_kp,
							    const_Module_PathPlanningController_stm_ref7_ki,
							    const_Module_PathPlanningController_stm_ref7_kd,
							    const_Module_PathPlanningController_stm_ref7_step,
							    const_Module_PathPlanningController_stm_ref8_step,
							    const_Module_PathPlanningController_stm_ref8_climb_speed,
							    const_Module_PathPlanningController_stm_ref8_descent_speed,
							    const_Module_PathPlanningController_stm_ref8_side_speed,
							    const_Module_PathPlanningController_stm_ref8_forward_angle,
							    const_Module_PathPlanningController_stm_ref8_left_angle,
							    const_Module_PathPlanningController_stm_ref8_right_angle,
							    const_Module_PathPlanningController_stm_ref8_turn_speed,
							    const_Module_PathPlanningController_stm_ref8_movesp,
							    const_Module_PathPlanningController_stm_ref8_stopsp) = O__(id__,
							    const_Module_PathPlanningController_stm_ref0_cliff,
							    const_Module_PathPlanningController_stm_ref0_nozzle,
							    const_Module_PathPlanningController_stm_ref0_battery_low,
							    const_Module_PathPlanningController_stm_ref0_sleep_time,
							    const_Module_PathPlanningController_stm_ref0_acc_distance,
							    const_Module_PathPlanningController_stm_ref1_t,
							    const_Module_PathPlanningController_stm_ref2_t,
							    const_Module_PathPlanningController_stm_ref3_t,
							    const_Module_PathPlanningController_stm_ref4_voltage,
							    const_Module_PathPlanningController_stm_ref5_t,
							    const_Module_PathPlanningController_stm_ref5_acc_distance,
							    const_Module_PathPlanningController_stm_ref6_kp,
							    const_Module_PathPlanningController_stm_ref6_ki,
							    const_Module_PathPlanningController_stm_ref6_kd,
							    const_Module_PathPlanningController_stm_ref6_step,
							    const_Module_PathPlanningController_stm_ref7_kp,
							    const_Module_PathPlanningController_stm_ref7_ki,
							    const_Module_PathPlanningController_stm_ref7_kd,
							    const_Module_PathPlanningController_stm_ref7_step,
							    const_Module_PathPlanningController_stm_ref8_step,
							    const_Module_PathPlanningController_stm_ref8_climb_speed,
							    const_Module_PathPlanningController_stm_ref8_descent_speed,
							    const_Module_PathPlanningController_stm_ref8_side_speed,
							    const_Module_PathPlanningController_stm_ref8_forward_angle,
							    const_Module_PathPlanningController_stm_ref8_left_angle,
							    const_Module_PathPlanningController_stm_ref8_right_angle,
							    const_Module_PathPlanningController_stm_ref8_turn_speed,
							    const_Module_PathPlanningController_stm_ref8_movesp,
							    const_Module_PathPlanningController_stm_ref8_stopsp) [|shared_variable_events|] SKIP			
			}
	
		endmodule
	
	Timed(OneStep) {
		visibleMemoryEvents = {||}
		
		-- declaring module memory
		Memory(id__) = SKIP
		
		D__(id__,
				    const_Module_PathPlanningController_stm_ref0_cliff,
				    const_Module_PathPlanningController_stm_ref0_nozzle,
				    const_Module_PathPlanningController_stm_ref0_battery_low,
				    const_Module_PathPlanningController_stm_ref0_sleep_time,
				    const_Module_PathPlanningController_stm_ref0_acc_distance,
				    const_Module_PathPlanningController_stm_ref1_t,
				    const_Module_PathPlanningController_stm_ref2_t,
				    const_Module_PathPlanningController_stm_ref3_t,
				    const_Module_PathPlanningController_stm_ref4_voltage,
				    const_Module_PathPlanningController_stm_ref5_t,
				    const_Module_PathPlanningController_stm_ref5_acc_distance,
				    const_Module_PathPlanningController_stm_ref6_kp,
				    const_Module_PathPlanningController_stm_ref6_ki,
				    const_Module_PathPlanningController_stm_ref6_kd,
				    const_Module_PathPlanningController_stm_ref6_step,
				    const_Module_PathPlanningController_stm_ref7_kp,
				    const_Module_PathPlanningController_stm_ref7_ki,
				    const_Module_PathPlanningController_stm_ref7_kd,
				    const_Module_PathPlanningController_stm_ref7_step,
				    const_Module_PathPlanningController_stm_ref8_step,
				    const_Module_PathPlanningController_stm_ref8_climb_speed,
				    const_Module_PathPlanningController_stm_ref8_descent_speed,
				    const_Module_PathPlanningController_stm_ref8_side_speed,
				    const_Module_PathPlanningController_stm_ref8_forward_angle,
				    const_Module_PathPlanningController_stm_ref8_left_angle,
				    const_Module_PathPlanningController_stm_ref8_right_angle,
				    const_Module_PathPlanningController_stm_ref8_turn_speed,
				    const_Module_PathPlanningController_stm_ref8_movesp,
				    const_Module_PathPlanningController_stm_ref8_stopsp) = prioritise(	(
				(
					(SKIP)
						[|{||}|]
					(
						(
							PathPlanningController::D__(id__,
									    const_Module_PathPlanningController_stm_ref0_cliff,
									    const_Module_PathPlanningController_stm_ref0_nozzle,
									    const_Module_PathPlanningController_stm_ref0_battery_low,
									    const_Module_PathPlanningController_stm_ref0_sleep_time,
									    const_Module_PathPlanningController_stm_ref0_acc_distance,
									    const_Module_PathPlanningController_stm_ref1_t,
									    const_Module_PathPlanningController_stm_ref2_t,
									    const_Module_PathPlanningController_stm_ref3_t,
									    const_Module_PathPlanningController_stm_ref4_voltage,
									    const_Module_PathPlanningController_stm_ref5_t,
									    const_Module_PathPlanningController_stm_ref5_acc_distance,
									    const_Module_PathPlanningController_stm_ref6_kp,
									    const_Module_PathPlanningController_stm_ref6_ki,
									    const_Module_PathPlanningController_stm_ref6_kd,
									    const_Module_PathPlanningController_stm_ref6_step,
									    const_Module_PathPlanningController_stm_ref7_kp,
									    const_Module_PathPlanningController_stm_ref7_ki,
									    const_Module_PathPlanningController_stm_ref7_kd,
									    const_Module_PathPlanningController_stm_ref7_step,
									    const_Module_PathPlanningController_stm_ref8_step,
									    const_Module_PathPlanningController_stm_ref8_climb_speed,
									    const_Module_PathPlanningController_stm_ref8_descent_speed,
									    const_Module_PathPlanningController_stm_ref8_side_speed,
									    const_Module_PathPlanningController_stm_ref8_forward_angle,
									    const_Module_PathPlanningController_stm_ref8_left_angle,
									    const_Module_PathPlanningController_stm_ref8_right_angle,
									    const_Module_PathPlanningController_stm_ref8_turn_speed,
									    const_Module_PathPlanningController_stm_ref8_movesp,
									    const_Module_PathPlanningController_stm_ref8_stopsp)[[
								PathPlanningController::terminate <- terminate,
								PathPlanningController::acc_l <- acc_l,
								PathPlanningController::acc_r <- acc_r,
								PathPlanningController::battery_level <- battery_level,
								PathPlanningController::charging <- charging,
								PathPlanningController::ultrasonic <- ultrasonic,
								PathPlanningController::output_right_motorCall <- output_right_motorCall,
								PathPlanningController::vacuumCall <- vacuumCall,
								PathPlanningController::brushCall <- brushCall,
								PathPlanningController::output_left_motorCall <- output_left_motorCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						Memory(id__)
					)
				)
				\ Union({
					{|
					|},
					{|
					|},
					{|
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		,<visibleMemoryEvents,{tock}>)
		
		-- visible state equivalent
		
		VS__(id__,
				    const_Module_PathPlanningController_stm_ref0_cliff,
				    const_Module_PathPlanningController_stm_ref0_nozzle,
				    const_Module_PathPlanningController_stm_ref0_battery_low,
				    const_Module_PathPlanningController_stm_ref0_sleep_time,
				    const_Module_PathPlanningController_stm_ref0_acc_distance,
				    const_Module_PathPlanningController_stm_ref1_t,
				    const_Module_PathPlanningController_stm_ref2_t,
				    const_Module_PathPlanningController_stm_ref3_t,
				    const_Module_PathPlanningController_stm_ref4_voltage,
				    const_Module_PathPlanningController_stm_ref5_t,
				    const_Module_PathPlanningController_stm_ref5_acc_distance,
				    const_Module_PathPlanningController_stm_ref6_kp,
				    const_Module_PathPlanningController_stm_ref6_ki,
				    const_Module_PathPlanningController_stm_ref6_kd,
				    const_Module_PathPlanningController_stm_ref6_step,
				    const_Module_PathPlanningController_stm_ref7_kp,
				    const_Module_PathPlanningController_stm_ref7_ki,
				    const_Module_PathPlanningController_stm_ref7_kd,
				    const_Module_PathPlanningController_stm_ref7_step,
				    const_Module_PathPlanningController_stm_ref8_step,
				    const_Module_PathPlanningController_stm_ref8_climb_speed,
				    const_Module_PathPlanningController_stm_ref8_descent_speed,
				    const_Module_PathPlanningController_stm_ref8_side_speed,
				    const_Module_PathPlanningController_stm_ref8_forward_angle,
				    const_Module_PathPlanningController_stm_ref8_left_angle,
				    const_Module_PathPlanningController_stm_ref8_right_angle,
				    const_Module_PathPlanningController_stm_ref8_turn_speed,
				    const_Module_PathPlanningController_stm_ref8_movesp,
				    const_Module_PathPlanningController_stm_ref8_stopsp) = prioritise(	(
				(
					(SKIP)
						[|{||}|]
					(
						(
							PathPlanningController::VS__(id__,
									    const_Module_PathPlanningController_stm_ref0_cliff,
									    const_Module_PathPlanningController_stm_ref0_nozzle,
									    const_Module_PathPlanningController_stm_ref0_battery_low,
									    const_Module_PathPlanningController_stm_ref0_sleep_time,
									    const_Module_PathPlanningController_stm_ref0_acc_distance,
									    const_Module_PathPlanningController_stm_ref1_t,
									    const_Module_PathPlanningController_stm_ref2_t,
									    const_Module_PathPlanningController_stm_ref3_t,
									    const_Module_PathPlanningController_stm_ref4_voltage,
									    const_Module_PathPlanningController_stm_ref5_t,
									    const_Module_PathPlanningController_stm_ref5_acc_distance,
									    const_Module_PathPlanningController_stm_ref6_kp,
									    const_Module_PathPlanningController_stm_ref6_ki,
									    const_Module_PathPlanningController_stm_ref6_kd,
									    const_Module_PathPlanningController_stm_ref6_step,
									    const_Module_PathPlanningController_stm_ref7_kp,
									    const_Module_PathPlanningController_stm_ref7_ki,
									    const_Module_PathPlanningController_stm_ref7_kd,
									    const_Module_PathPlanningController_stm_ref7_step,
									    const_Module_PathPlanningController_stm_ref8_step,
									    const_Module_PathPlanningController_stm_ref8_climb_speed,
									    const_Module_PathPlanningController_stm_ref8_descent_speed,
									    const_Module_PathPlanningController_stm_ref8_side_speed,
									    const_Module_PathPlanningController_stm_ref8_forward_angle,
									    const_Module_PathPlanningController_stm_ref8_left_angle,
									    const_Module_PathPlanningController_stm_ref8_right_angle,
									    const_Module_PathPlanningController_stm_ref8_turn_speed,
									    const_Module_PathPlanningController_stm_ref8_movesp,
									    const_Module_PathPlanningController_stm_ref8_stopsp)[[
								PathPlanningController::terminate <- terminate,
								PathPlanningController::acc_l <- acc_l,
								PathPlanningController::acc_r <- acc_r,
								PathPlanningController::battery_level <- battery_level,
								PathPlanningController::charging <- charging,
								PathPlanningController::ultrasonic <- ultrasonic,
								PathPlanningController::output_right_motorCall <- output_right_motorCall,
								PathPlanningController::vacuumCall <- vacuumCall,
								PathPlanningController::brushCall <- brushCall,
								PathPlanningController::output_left_motorCall <- output_left_motorCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						Memory(id__)
					)
				)
				\ Union({
					{|
					|},
					{|
					|},
					{|
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		,<visibleMemoryEvents,{tock}>)
		
		-- O version (optimised)
		
		O__(id__,
				    const_Module_PathPlanningController_stm_ref0_cliff,
				    const_Module_PathPlanningController_stm_ref0_nozzle,
				    const_Module_PathPlanningController_stm_ref0_battery_low,
				    const_Module_PathPlanningController_stm_ref0_sleep_time,
				    const_Module_PathPlanningController_stm_ref0_acc_distance,
				    const_Module_PathPlanningController_stm_ref1_t,
				    const_Module_PathPlanningController_stm_ref2_t,
				    const_Module_PathPlanningController_stm_ref3_t,
				    const_Module_PathPlanningController_stm_ref4_voltage,
				    const_Module_PathPlanningController_stm_ref5_t,
				    const_Module_PathPlanningController_stm_ref5_acc_distance,
				    const_Module_PathPlanningController_stm_ref6_kp,
				    const_Module_PathPlanningController_stm_ref6_ki,
				    const_Module_PathPlanningController_stm_ref6_kd,
				    const_Module_PathPlanningController_stm_ref6_step,
				    const_Module_PathPlanningController_stm_ref7_kp,
				    const_Module_PathPlanningController_stm_ref7_ki,
				    const_Module_PathPlanningController_stm_ref7_kd,
				    const_Module_PathPlanningController_stm_ref7_step,
				    const_Module_PathPlanningController_stm_ref8_step,
				    const_Module_PathPlanningController_stm_ref8_climb_speed,
				    const_Module_PathPlanningController_stm_ref8_descent_speed,
				    const_Module_PathPlanningController_stm_ref8_side_speed,
				    const_Module_PathPlanningController_stm_ref8_forward_angle,
				    const_Module_PathPlanningController_stm_ref8_left_angle,
				    const_Module_PathPlanningController_stm_ref8_right_angle,
				    const_Module_PathPlanningController_stm_ref8_turn_speed,
				    const_Module_PathPlanningController_stm_ref8_movesp,
				    const_Module_PathPlanningController_stm_ref8_stopsp) = dbisim(prioritise(	(
				(
					(SKIP)
						[|{||}|]
					(
						(
							PathPlanningController::O__(id__,
									    const_Module_PathPlanningController_stm_ref0_cliff,
									    const_Module_PathPlanningController_stm_ref0_nozzle,
									    const_Module_PathPlanningController_stm_ref0_battery_low,
									    const_Module_PathPlanningController_stm_ref0_sleep_time,
									    const_Module_PathPlanningController_stm_ref0_acc_distance,
									    const_Module_PathPlanningController_stm_ref1_t,
									    const_Module_PathPlanningController_stm_ref2_t,
									    const_Module_PathPlanningController_stm_ref3_t,
									    const_Module_PathPlanningController_stm_ref4_voltage,
									    const_Module_PathPlanningController_stm_ref5_t,
									    const_Module_PathPlanningController_stm_ref5_acc_distance,
									    const_Module_PathPlanningController_stm_ref6_kp,
									    const_Module_PathPlanningController_stm_ref6_ki,
									    const_Module_PathPlanningController_stm_ref6_kd,
									    const_Module_PathPlanningController_stm_ref6_step,
									    const_Module_PathPlanningController_stm_ref7_kp,
									    const_Module_PathPlanningController_stm_ref7_ki,
									    const_Module_PathPlanningController_stm_ref7_kd,
									    const_Module_PathPlanningController_stm_ref7_step,
									    const_Module_PathPlanningController_stm_ref8_step,
									    const_Module_PathPlanningController_stm_ref8_climb_speed,
									    const_Module_PathPlanningController_stm_ref8_descent_speed,
									    const_Module_PathPlanningController_stm_ref8_side_speed,
									    const_Module_PathPlanningController_stm_ref8_forward_angle,
									    const_Module_PathPlanningController_stm_ref8_left_angle,
									    const_Module_PathPlanningController_stm_ref8_right_angle,
									    const_Module_PathPlanningController_stm_ref8_turn_speed,
									    const_Module_PathPlanningController_stm_ref8_movesp,
									    const_Module_PathPlanningController_stm_ref8_stopsp)[[
								PathPlanningController::terminate <- terminate,
								PathPlanningController::acc_l <- acc_l,
								PathPlanningController::acc_r <- acc_r,
								PathPlanningController::battery_level <- battery_level,
								PathPlanningController::charging <- charging,
								PathPlanningController::ultrasonic <- ultrasonic,
								PathPlanningController::output_right_motorCall <- output_right_motorCall,
								PathPlanningController::vacuumCall <- vacuumCall,
								PathPlanningController::brushCall <- brushCall,
								PathPlanningController::output_left_motorCall <- output_left_motorCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
				)
				\ Union({
					{|
					|},
					{|
					|},
					{|
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		,<visibleMemoryEvents,{tock}>))
		
		-- visible state optimised equivalent
		
		VS_O__(id__,
				    const_Module_PathPlanningController_stm_ref0_cliff,
				    const_Module_PathPlanningController_stm_ref0_nozzle,
				    const_Module_PathPlanningController_stm_ref0_battery_low,
				    const_Module_PathPlanningController_stm_ref0_sleep_time,
				    const_Module_PathPlanningController_stm_ref0_acc_distance,
				    const_Module_PathPlanningController_stm_ref1_t,
				    const_Module_PathPlanningController_stm_ref2_t,
				    const_Module_PathPlanningController_stm_ref3_t,
				    const_Module_PathPlanningController_stm_ref4_voltage,
				    const_Module_PathPlanningController_stm_ref5_t,
				    const_Module_PathPlanningController_stm_ref5_acc_distance,
				    const_Module_PathPlanningController_stm_ref6_kp,
				    const_Module_PathPlanningController_stm_ref6_ki,
				    const_Module_PathPlanningController_stm_ref6_kd,
				    const_Module_PathPlanningController_stm_ref6_step,
				    const_Module_PathPlanningController_stm_ref7_kp,
				    const_Module_PathPlanningController_stm_ref7_ki,
				    const_Module_PathPlanningController_stm_ref7_kd,
				    const_Module_PathPlanningController_stm_ref7_step,
				    const_Module_PathPlanningController_stm_ref8_step,
				    const_Module_PathPlanningController_stm_ref8_climb_speed,
				    const_Module_PathPlanningController_stm_ref8_descent_speed,
				    const_Module_PathPlanningController_stm_ref8_side_speed,
				    const_Module_PathPlanningController_stm_ref8_forward_angle,
				    const_Module_PathPlanningController_stm_ref8_left_angle,
				    const_Module_PathPlanningController_stm_ref8_right_angle,
				    const_Module_PathPlanningController_stm_ref8_turn_speed,
				    const_Module_PathPlanningController_stm_ref8_movesp,
				    const_Module_PathPlanningController_stm_ref8_stopsp) = dbisim(prioritise(	(
				(
					(SKIP)
						[|{||}|]
					(
						(
							PathPlanningController::VS_O__(id__,
									    const_Module_PathPlanningController_stm_ref0_cliff,
									    const_Module_PathPlanningController_stm_ref0_nozzle,
									    const_Module_PathPlanningController_stm_ref0_battery_low,
									    const_Module_PathPlanningController_stm_ref0_sleep_time,
									    const_Module_PathPlanningController_stm_ref0_acc_distance,
									    const_Module_PathPlanningController_stm_ref1_t,
									    const_Module_PathPlanningController_stm_ref2_t,
									    const_Module_PathPlanningController_stm_ref3_t,
									    const_Module_PathPlanningController_stm_ref4_voltage,
									    const_Module_PathPlanningController_stm_ref5_t,
									    const_Module_PathPlanningController_stm_ref5_acc_distance,
									    const_Module_PathPlanningController_stm_ref6_kp,
									    const_Module_PathPlanningController_stm_ref6_ki,
									    const_Module_PathPlanningController_stm_ref6_kd,
									    const_Module_PathPlanningController_stm_ref6_step,
									    const_Module_PathPlanningController_stm_ref7_kp,
									    const_Module_PathPlanningController_stm_ref7_ki,
									    const_Module_PathPlanningController_stm_ref7_kd,
									    const_Module_PathPlanningController_stm_ref7_step,
									    const_Module_PathPlanningController_stm_ref8_step,
									    const_Module_PathPlanningController_stm_ref8_climb_speed,
									    const_Module_PathPlanningController_stm_ref8_descent_speed,
									    const_Module_PathPlanningController_stm_ref8_side_speed,
									    const_Module_PathPlanningController_stm_ref8_forward_angle,
									    const_Module_PathPlanningController_stm_ref8_left_angle,
									    const_Module_PathPlanningController_stm_ref8_right_angle,
									    const_Module_PathPlanningController_stm_ref8_turn_speed,
									    const_Module_PathPlanningController_stm_ref8_movesp,
									    const_Module_PathPlanningController_stm_ref8_stopsp)[[
								PathPlanningController::terminate <- terminate,
								PathPlanningController::acc_l <- acc_l,
								PathPlanningController::acc_r <- acc_r,
								PathPlanningController::battery_level <- battery_level,
								PathPlanningController::charging <- charging,
								PathPlanningController::ultrasonic <- ultrasonic,
								PathPlanningController::output_right_motorCall <- output_right_motorCall,
								PathPlanningController::vacuumCall <- vacuumCall,
								PathPlanningController::brushCall <- brushCall,
								PathPlanningController::output_left_motorCall <- output_left_motorCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
				)
				\ Union({
					{|
					|},
					{|
					|},
					{|
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		,<visibleMemoryEvents,{tock}>))
		
		-- O version (optimised) with visible assignments
		
		AS_O__(id__,
				    const_Module_PathPlanningController_stm_ref0_cliff,
				    const_Module_PathPlanningController_stm_ref0_nozzle,
				    const_Module_PathPlanningController_stm_ref0_battery_low,
				    const_Module_PathPlanningController_stm_ref0_sleep_time,
				    const_Module_PathPlanningController_stm_ref0_acc_distance,
				    const_Module_PathPlanningController_stm_ref1_t,
				    const_Module_PathPlanningController_stm_ref2_t,
				    const_Module_PathPlanningController_stm_ref3_t,
				    const_Module_PathPlanningController_stm_ref4_voltage,
				    const_Module_PathPlanningController_stm_ref5_t,
				    const_Module_PathPlanningController_stm_ref5_acc_distance,
				    const_Module_PathPlanningController_stm_ref6_kp,
				    const_Module_PathPlanningController_stm_ref6_ki,
				    const_Module_PathPlanningController_stm_ref6_kd,
				    const_Module_PathPlanningController_stm_ref6_step,
				    const_Module_PathPlanningController_stm_ref7_kp,
				    const_Module_PathPlanningController_stm_ref7_ki,
				    const_Module_PathPlanningController_stm_ref7_kd,
				    const_Module_PathPlanningController_stm_ref7_step,
				    const_Module_PathPlanningController_stm_ref8_step,
				    const_Module_PathPlanningController_stm_ref8_climb_speed,
				    const_Module_PathPlanningController_stm_ref8_descent_speed,
				    const_Module_PathPlanningController_stm_ref8_side_speed,
				    const_Module_PathPlanningController_stm_ref8_forward_angle,
				    const_Module_PathPlanningController_stm_ref8_left_angle,
				    const_Module_PathPlanningController_stm_ref8_right_angle,
				    const_Module_PathPlanningController_stm_ref8_turn_speed,
				    const_Module_PathPlanningController_stm_ref8_movesp,
				    const_Module_PathPlanningController_stm_ref8_stopsp) = dbisim(	(
				(
					(SKIP)
						[|{||}|]
					(
						(
							PathPlanningController::O__(id__,
									    const_Module_PathPlanningController_stm_ref0_cliff,
									    const_Module_PathPlanningController_stm_ref0_nozzle,
									    const_Module_PathPlanningController_stm_ref0_battery_low,
									    const_Module_PathPlanningController_stm_ref0_sleep_time,
									    const_Module_PathPlanningController_stm_ref0_acc_distance,
									    const_Module_PathPlanningController_stm_ref1_t,
									    const_Module_PathPlanningController_stm_ref2_t,
									    const_Module_PathPlanningController_stm_ref3_t,
									    const_Module_PathPlanningController_stm_ref4_voltage,
									    const_Module_PathPlanningController_stm_ref5_t,
									    const_Module_PathPlanningController_stm_ref5_acc_distance,
									    const_Module_PathPlanningController_stm_ref6_kp,
									    const_Module_PathPlanningController_stm_ref6_ki,
									    const_Module_PathPlanningController_stm_ref6_kd,
									    const_Module_PathPlanningController_stm_ref6_step,
									    const_Module_PathPlanningController_stm_ref7_kp,
									    const_Module_PathPlanningController_stm_ref7_ki,
									    const_Module_PathPlanningController_stm_ref7_kd,
									    const_Module_PathPlanningController_stm_ref7_step,
									    const_Module_PathPlanningController_stm_ref8_step,
									    const_Module_PathPlanningController_stm_ref8_climb_speed,
									    const_Module_PathPlanningController_stm_ref8_descent_speed,
									    const_Module_PathPlanningController_stm_ref8_side_speed,
									    const_Module_PathPlanningController_stm_ref8_forward_angle,
									    const_Module_PathPlanningController_stm_ref8_left_angle,
									    const_Module_PathPlanningController_stm_ref8_right_angle,
									    const_Module_PathPlanningController_stm_ref8_turn_speed,
									    const_Module_PathPlanningController_stm_ref8_movesp,
									    const_Module_PathPlanningController_stm_ref8_stopsp)[[
								PathPlanningController::terminate <- terminate,
								PathPlanningController::acc_l <- acc_l,
								PathPlanningController::acc_r <- acc_r,
								PathPlanningController::battery_level <- battery_level,
								PathPlanningController::charging <- charging,
								PathPlanningController::ultrasonic <- ultrasonic,
								PathPlanningController::output_right_motorCall <- output_right_motorCall,
								PathPlanningController::vacuumCall <- vacuumCall,
								PathPlanningController::brushCall <- brushCall,
								PathPlanningController::output_left_motorCall <- output_left_motorCall
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
				)
				\ Union({
					{|
					|},
					{|
					|},
					{|
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		)
	}
	
endmodule




