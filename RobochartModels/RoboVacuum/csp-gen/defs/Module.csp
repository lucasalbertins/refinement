
--
-- RoboChart generator version 3.0.0.202112100958
-- Automatically generated on 08-03-2022 18:58:33
--
-- Iterated compression status: true
-- Assertions compression status: true
--

module Module
	exports
	
	transparent diamond
	transparent sbisim
	transparent dbisim
	transparent chase
	
	-- declaring channels
	-- declaring robotic platform events
	channel acc_l: InOut.TripleAxis
	channel acc_r: InOut.TripleAxis
	channel ultrasonic: InOut.core_int
	channel battery_level: InOut.core_int
	channel charging: InOut
	
	channel output_left_motorCall: core_int
	channel output_right_motorCall: core_int
	channel vacuumCall: core_int
	channel brushCall: core_int
	
	-- declaring module termination channel
	channel terminate
	
	-- declaring robotic platform variables
	
	-- channel set with all visible events
	sem__events = {|
		acc_l,
		acc_r,
		ultrasonic,
		battery_level,
		charging
	,	output_left_motorCall,
		output_right_motorCall,
		vacuumCall,
		brushCall
	|}
	
	-- declaring controller
		module PathPlanningController
			shared_variable_events = {|
			|}
			
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
	
			-- declaring controller events
			channel acc_l: InOut.TripleAxis
			channel acc_r: InOut.TripleAxis
			channel ultrasonic: InOut.core_int
			channel battery_level: InOut.core_int
			channel charging: InOut
			
			
			
			-- declaring call and ret events for undefined operations
			channel brushCall: core_int
			channel vacuumCall: core_int
			channel output_left_motorCall: core_int
			channel output_right_motorCall: core_int
			
			-- declaring controller termination channel
			channel terminate
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	acc_l,
				acc_r,
				ultrasonic,
				battery_level,
				charging
			,	brushCall,
				vacuumCall,
				output_left_motorCall,
				output_right_motorCall
			|}
	
			-- defined operations
		
			-- declaring machines
			module stm_ref0
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_Go_up|
				              NID_Go_right|
				              NID_Go_down|
				              NID_Go_right_again|
				              NID_Return|
				              NID_Dock|
				              NID_Sleep|
				              NID_Check_end|
				              NID_Check_battery|
				              NID_Resume
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_cycles, set_cycles, setL_cycles, setR_cycles: core_int
				channel get_u, set_u, setL_u, setR_u: core_int
				channel get_d, set_d, setL_d, setR_d: core_int
				channel get_b, set_b, setL_b, setR_b: core_int
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel move_forward__: NIDS.InOut
				channel move_forward: InOut
				channel turn__: NIDS.InOut.Direction
				channel turn: InOut.Direction
				channel stop__: NIDS.InOut
				channel stop: InOut
				channel ultrasonic__: NIDS.InOut.core_int
				channel ultrasonic: InOut.core_int
				channel battery_level__: NIDS.InOut.core_int
				channel battery_level: InOut.core_int
				channel charging__: NIDS.InOut
				channel charging: InOut
				channel clean__: NIDS.InOut.core_boolean
				channel clean: InOut.core_boolean
				channel displacement__: NIDS.InOut.core_int
				channel displacement: InOut.core_int
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				Go_up::enter,
				Go_right::enter,
				Go_down::enter,
				Go_right_again::enter,
				Return::enter,
				Dock::enter,
				Sleep::enter,
				Check_end::enter,
				Check_battery::enter,
				Resume::enter
				|}
				
				enteredSS = 	{|
				Go_up::entered,
				Go_right::entered,
				Go_down::entered,
				Go_right_again::entered,
				Return::entered,
				Dock::entered,
				Sleep::entered,
				Check_end::entered,
				Check_battery::entered,
				Resume::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	move_forward,
					turn,
					stop,
					ultrasonic,
					battery_level,
					charging,
					clean,
					displacement
					|}
			
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, interrupt
					
					D__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
					
					VS_O__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = D__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Go_up
				module Go_up
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(move_forward.out -> SKIP)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(move_forward.out -> SKIP)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Go_right
				module Go_right
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(turn.out!Direction_right -> SKIP));true&(share__choice(move_forward.out -> SKIP));true&(share__choice(displacement.out!0 -> SKIP)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(turn.out!Direction_right -> SKIP));true&(share__choice(move_forward.out -> SKIP));true&(share__choice(displacement.out!0 -> SKIP)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Go_down
				module Go_down
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(turn.out!Direction_right -> SKIP));true&(share__choice(move_forward.out -> SKIP)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(turn.out!Direction_right -> SKIP));true&(share__choice(move_forward.out -> SKIP)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Go_right_again
				module Go_right_again
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Return
				module Return
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(turn.out!Direction_left -> SKIP));true&(share__choice(turn.out!Direction_left -> SKIP));true&(share__choice(move_forward.out -> SKIP));true&(share__choice(clean.out!false -> SKIP)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(turn.out!Direction_left -> SKIP));true&(share__choice(turn.out!Direction_left -> SKIP));true&(share__choice(move_forward.out -> SKIP));true&(share__choice(clean.out!false -> SKIP)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Dock
				module Dock
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(turn.out!Direction_left -> SKIP));true&(share__choice(move_forward.out -> SKIP)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(turn.out!Direction_left -> SKIP));true&(share__choice(move_forward.out -> SKIP)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Sleep
				module Sleep
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(stop.out -> SKIP));SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(stop.out -> SKIP));SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Check_end
				module Check_end
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Check_battery
				module Check_battery
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Resume
				module Resume
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(turn.out!Direction_right -> SKIP));true&(share__choice(move_forward.out -> SKIP));true&(share__choice(displacement.out!0 -> SKIP)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; true&(share__choice(turn.out!Direction_left -> SKIP)) ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(turn.out!Direction_right -> SKIP));true&(share__choice(move_forward.out -> SKIP));true&(share__choice(displacement.out!0 -> SKIP)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; true&(share__choice(turn.out!Direction_left -> SKIP)) ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				-- END of Operation calls --
				
				-- STM processes
				STM(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance))
				)\sharedVarHide
				
				STM_VS_O(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful_VS_O(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance))
				)\sharedVarHide
				
				-- Transitions
				Transitions(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance) = ((let
					Trans = share__choice(get_d?d -> get_u?u -> get_cycles?cycles -> get_b?b -> (
						((share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((share__choice(true & (share__choice(set_cycles!0 -> SKIP))) ; Resume::enter -> SKIP))))
						 	 [] dbisim((ultrasonic__!NID_Go_up.in?u:{u|u <- core_int, (u>=const_PathPlanningSM_cliff)} -> share__choice(set_u!u -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Go_right::enter -> SKIP)))
						 	 [] dbisim((displacement__!NID_Go_right.in?d:{d|d <- core_int, (d>=const_PathPlanningSM_nozzle)} -> share__choice(set_d!d -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Go_down::enter -> SKIP)))
						 	 [] dbisim((ultrasonic__!NID_Go_down.in?u:{u|u <- core_int, (u>=const_PathPlanningSM_cliff)} -> share__choice(set_u!u -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(turn.out!Direction_left -> SKIP));true&(share__choice(move_forward.out -> SKIP));true&(share__choice(displacement.out!0 -> SKIP)) ; Go_right_again::enter -> SKIP)))
						 	 [] dbisim((ultrasonic__!NID_Go_right_again.in?u:{u|u <- core_int, (u<const_PathPlanningSM_cliff)} -> share__choice(set_u!u -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Check_end::enter -> SKIP)))
						 	 [] dbisim((ultrasonic__!NID_Go_right_again.in?u:{u|u <- core_int, (u>=const_PathPlanningSM_cliff)} -> share__choice(set_u!u -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_cycles!0 -> SKIP))) ; Return::enter -> SKIP)))
						 	 [] dbisim((displacement__!NID_Check_end.in?d:{d|d <- core_int, (d<const_PathPlanningSM_nozzle)} -> share__choice(set_d!d -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Go_right_again::enter -> SKIP)))
						 	 [] dbisim((displacement__!NID_Check_end.in?d:{d|d <- core_int, (d>=const_PathPlanningSM_nozzle)} -> share__choice(set_d!d -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_cycles?cycles -> true & (share__choice(set_cycles!Plus(cycles, 1, core_int) -> SKIP)))) ; Check_battery::enter -> SKIP)))
						 	 [] dbisim((battery_level__!NID_Check_battery.in?b:{b|b <- core_int, (b>const_PathPlanningSM_battery_low)} -> share__choice(set_b!b -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(turn.out!Direction_left -> SKIP)) ; Go_up::enter -> SKIP)))
						 	 [] dbisim((battery_level__!NID_Check_battery.in?b:{b|b <- core_int, (b<=const_PathPlanningSM_battery_low)} -> share__choice(set_b!b -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Return::enter -> SKIP)))
						 	 [] dbisim((ultrasonic__!NID_Return.in?u:{u|u <- core_int, (u>=const_PathPlanningSM_cliff)} -> share__choice(set_u!u -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Dock::enter -> SKIP)))
						 	 [] dbisim((true)&(charging__!NID_Dock.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Sleep::enter -> SKIP)))
						 	 [] dbisim((true)&(internal__!NID_Sleep -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(turn.out!Direction_left -> SKIP));true&(share__choice(turn.out!Direction_left -> SKIP));true&(share__choice(move_forward.out -> SKIP)) ; Resume::enter -> SKIP)))
						 	 [] dbisim((displacement__!NID_Resume.in?d:{d|d <- core_int, (d>=Mult(Mult(cycles, 2, core_int), const_PathPlanningSM_nozzle, core_int))} -> share__choice(set_d!d -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(clean.out!true -> SKIP)) ; Go_up::enter -> SKIP)))
						 	 [] dbisim((ultrasonic__!NID_Go_right.in?u:{u|u <- core_int, (u>=const_PathPlanningSM_cliff)} -> share__choice(set_u!u -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Go_down::enter -> SKIP)))
						 ) ; Trans)
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
					)
					)
				within
					Trans
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							Go_up::enter,
							Go_right::enter,
							Go_down::enter,
							Go_right_again::enter,
							Return::enter,
							Dock::enter,
							Sleep::enter,
							Check_end::enter,
							Check_battery::enter,
							Resume::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0,ultrasonic__.NID_Go_up.in,displacement__.NID_Go_right.in,ultrasonic__.NID_Go_down.in,ultrasonic__.NID_Go_right_again.in,ultrasonic__.NID_Go_right_again.in,displacement__.NID_Check_end.in,displacement__.NID_Check_end.in,battery_level__.NID_Check_battery.in,battery_level__.NID_Check_battery.in,ultrasonic__.NID_Return.in,charging__.NID_Dock.in,internal__.NID_Sleep,displacement__.NID_Resume.in,ultrasonic__.NID_Go_right.in|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::D__(id__,
								   		    const_PathPlanningSM_cliff,
								   		    const_PathPlanningSM_nozzle,
								   		    const_PathPlanningSM_battery_low,
								   		    const_PathPlanningSM_sleep_time,
								   		    const_PathPlanningSM_acc_distance)
								   [| { share__, terminate } |] (
								   Go_up::D__(id__,
								   		    const_PathPlanningSM_cliff,
								   		    const_PathPlanningSM_nozzle,
								   		    const_PathPlanningSM_battery_low,
								   		    const_PathPlanningSM_sleep_time,
								   		    const_PathPlanningSM_acc_distance)
								   [| { share__, terminate } |] (
								   Go_right::D__(id__,
								   		    const_PathPlanningSM_cliff,
								   		    const_PathPlanningSM_nozzle,
								   		    const_PathPlanningSM_battery_low,
								   		    const_PathPlanningSM_sleep_time,
								   		    const_PathPlanningSM_acc_distance)
								   [| { share__, terminate } |] (
								   Go_down::D__(id__,
								   		    const_PathPlanningSM_cliff,
								   		    const_PathPlanningSM_nozzle,
								   		    const_PathPlanningSM_battery_low,
								   		    const_PathPlanningSM_sleep_time,
								   		    const_PathPlanningSM_acc_distance)
								   [| { share__, terminate } |] (
								   Go_right_again::D__(id__,
								   		    const_PathPlanningSM_cliff,
								   		    const_PathPlanningSM_nozzle,
								   		    const_PathPlanningSM_battery_low,
								   		    const_PathPlanningSM_sleep_time,
								   		    const_PathPlanningSM_acc_distance)
								   [| { share__, terminate } |] (
								   Return::D__(id__,
								   		    const_PathPlanningSM_cliff,
								   		    const_PathPlanningSM_nozzle,
								   		    const_PathPlanningSM_battery_low,
								   		    const_PathPlanningSM_sleep_time,
								   		    const_PathPlanningSM_acc_distance)
								   [| { share__, terminate } |] (
								   Dock::D__(id__,
								   		    const_PathPlanningSM_cliff,
								   		    const_PathPlanningSM_nozzle,
								   		    const_PathPlanningSM_battery_low,
								   		    const_PathPlanningSM_sleep_time,
								   		    const_PathPlanningSM_acc_distance)
								   [| { share__, terminate } |] (
								   Sleep::D__(id__,
								   		    const_PathPlanningSM_cliff,
								   		    const_PathPlanningSM_nozzle,
								   		    const_PathPlanningSM_battery_low,
								   		    const_PathPlanningSM_sleep_time,
								   		    const_PathPlanningSM_acc_distance)
								   [| { share__, terminate } |] (
								   Check_end::D__(id__,
								   		    const_PathPlanningSM_cliff,
								   		    const_PathPlanningSM_nozzle,
								   		    const_PathPlanningSM_battery_low,
								   		    const_PathPlanningSM_sleep_time,
								   		    const_PathPlanningSM_acc_distance)
								   [| { share__, terminate } |] (
								   Check_battery::D__(id__,
								   		    const_PathPlanningSM_cliff,
								   		    const_PathPlanningSM_nozzle,
								   		    const_PathPlanningSM_battery_low,
								   		    const_PathPlanningSM_sleep_time,
								   		    const_PathPlanningSM_acc_distance)
								   [| { share__, terminate } |] (
								   Resume::D__(id__,
								   		    const_PathPlanningSM_cliff,
								   		    const_PathPlanningSM_nozzle,
								   		    const_PathPlanningSM_battery_low,
								   		    const_PathPlanningSM_sleep_time,
								   		    const_PathPlanningSM_acc_distance)
								   )
								   )
								   )
								   )
								   )
								   )
								   )
								   )
								   )
								   )
								 )
								 [[Go_up::interrupt <- x__ | x__ <- {|interrupt,ultrasonic__.NID_Go_up.in|}]]
								 [[Go_right::interrupt <- x__ | x__ <- {|interrupt,displacement__.NID_Go_right.in,ultrasonic__.NID_Go_right.in|}]]
								 [[Go_down::interrupt <- x__ | x__ <- {|interrupt,ultrasonic__.NID_Go_down.in|}]]
								 [[Go_right_again::interrupt <- x__ | x__ <- {|interrupt,ultrasonic__.NID_Go_right_again.in,ultrasonic__.NID_Go_right_again.in|}]]
								 [[Return::interrupt <- x__ | x__ <- {|interrupt,ultrasonic__.NID_Return.in|}]]
								 [[Dock::interrupt <- x__ | x__ <- {|interrupt,charging__.NID_Dock.in|}]]
								 [[Sleep::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Sleep|}]]
								 [[Check_end::interrupt <- x__ | x__ <- {|interrupt,displacement__.NID_Check_end.in,displacement__.NID_Check_end.in|}]]
								 [[Check_battery::interrupt <- x__ | x__ <- {|interrupt,battery_level__.NID_Check_battery.in,battery_level__.NID_Check_battery.in|}]]
								 [[Resume::interrupt <- x__ | x__ <- {|interrupt,displacement__.NID_Resume.in|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_d,setR_u,setR_b |} ]] 
								  [[set_d <- setL_d,set_u <- setL_u,set_cycles <- setL_cycles,set_b <- setL_b]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_d
								 			,setL_u
								 			,setL_cycles
								 			,setL_b
								 			,setR_d
								 			 			,setR_u
								 			 			,setR_b
								 			|}) |]
								 ((i0::enter -> Transitions(id__,
								 		    const_PathPlanningSM_cliff,
								 		    const_PathPlanningSM_nozzle,
								 		    const_PathPlanningSM_battery_low,
								 		    const_PathPlanningSM_sleep_time,
								 		    const_PathPlanningSM_acc_distance))
								  [[ share__ <- x__ | x__ <- {| share__,setL_d,setL_u,setL_cycles,setL_b |} ]]
								  [[set_d <- setR_d,set_u <- setR_u,set_b <- setR_b]]
								 )
								)[[setL_d <- set_d,setL_u <- set_u,setL_cycles <- set_cycles,setL_b <- set_b]]
								 [[setR_d <- set_d,setR_u <- set_u,setR_b <- set_b]]
								)
							)
							 \ hideSet)
							[[
								move_forward__.x____ <- move_forward,
								turn__.x____ <- turn,
								stop__.x____ <- stop,
								ultrasonic__.x____ <- ultrasonic,
								battery_level__.x____ <- battery_level,
								charging__.x____ <- charging,
								clean__.x____ <- clean,
								displacement__.x____ <- displacement
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance) = 
					dbisim((MachineBody(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance)\ enteredSS)
					)
				
				IteratedBehaviour(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance) = 
					dbisim((MachineBody(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance)\ enteredSS)
					)
				
				Stateful(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance) = 
					((
						(Behaviour(id__,
								    const_PathPlanningSM_cliff,
								    const_PathPlanningSM_nozzle,
								    const_PathPlanningSM_battery_low,
								    const_PathPlanningSM_sleep_time,
								    const_PathPlanningSM_acc_distance) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
								    const_PathPlanningSM_cliff,
								    const_PathPlanningSM_nozzle,
								    const_PathPlanningSM_battery_low,
								    const_PathPlanningSM_sleep_time,
								    const_PathPlanningSM_acc_distance))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													Behaviour(id__,
															    const_PathPlanningSM_cliff,
															    const_PathPlanningSM_nozzle,
															    const_PathPlanningSM_battery_low,
															    const_PathPlanningSM_sleep_time,
															    const_PathPlanningSM_acc_distance)
													[| {|get_b,set_b,terminate|} |]
													Memory_b(0)
												)\{|get_b,set_b|}
											)
											[| {|get_d,set_d,terminate|} |]
											Memory_d(0)
										)\{|get_d,set_d|}
									)
									[| {|get_u,set_u,terminate|} |]
									Memory_u(0)
								)\{|get_u,set_u|}
							)
							[| {|get_cycles,set_cycles,terminate|} |]
							Memory_cycles(0)
						)\{|get_cycles,set_cycles|}
					)
					)
				
				-- Visible counterparts
				MachineBody_VS_O(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							Go_up::enter,
							Go_right::enter,
							Go_down::enter,
							Go_right_again::enter,
							Return::enter,
							Dock::enter,
							Sleep::enter,
							Check_end::enter,
							Check_battery::enter,
							Resume::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0,ultrasonic__.NID_Go_up.in,displacement__.NID_Go_right.in,ultrasonic__.NID_Go_down.in,ultrasonic__.NID_Go_right_again.in,ultrasonic__.NID_Go_right_again.in,displacement__.NID_Check_end.in,displacement__.NID_Check_end.in,battery_level__.NID_Check_battery.in,battery_level__.NID_Check_battery.in,ultrasonic__.NID_Return.in,charging__.NID_Dock.in,internal__.NID_Sleep,displacement__.NID_Resume.in,ultrasonic__.NID_Go_right.in|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::VS_O__(id__,
								   		    const_PathPlanningSM_cliff,
								   		    const_PathPlanningSM_nozzle,
								   		    const_PathPlanningSM_battery_low,
								   		    const_PathPlanningSM_sleep_time,
								   		    const_PathPlanningSM_acc_distance)
								   [| { share__, terminate } |] (
								   Go_up::VS_O__(id__,
								   		    const_PathPlanningSM_cliff,
								   		    const_PathPlanningSM_nozzle,
								   		    const_PathPlanningSM_battery_low,
								   		    const_PathPlanningSM_sleep_time,
								   		    const_PathPlanningSM_acc_distance)
								   [| { share__, terminate } |] (
								   Go_right::VS_O__(id__,
								   		    const_PathPlanningSM_cliff,
								   		    const_PathPlanningSM_nozzle,
								   		    const_PathPlanningSM_battery_low,
								   		    const_PathPlanningSM_sleep_time,
								   		    const_PathPlanningSM_acc_distance)
								   [| { share__, terminate } |] (
								   Go_down::VS_O__(id__,
								   		    const_PathPlanningSM_cliff,
								   		    const_PathPlanningSM_nozzle,
								   		    const_PathPlanningSM_battery_low,
								   		    const_PathPlanningSM_sleep_time,
								   		    const_PathPlanningSM_acc_distance)
								   [| { share__, terminate } |] (
								   Go_right_again::VS_O__(id__,
								   		    const_PathPlanningSM_cliff,
								   		    const_PathPlanningSM_nozzle,
								   		    const_PathPlanningSM_battery_low,
								   		    const_PathPlanningSM_sleep_time,
								   		    const_PathPlanningSM_acc_distance)
								   [| { share__, terminate } |] (
								   Return::VS_O__(id__,
								   		    const_PathPlanningSM_cliff,
								   		    const_PathPlanningSM_nozzle,
								   		    const_PathPlanningSM_battery_low,
								   		    const_PathPlanningSM_sleep_time,
								   		    const_PathPlanningSM_acc_distance)
								   [| { share__, terminate } |] (
								   Dock::VS_O__(id__,
								   		    const_PathPlanningSM_cliff,
								   		    const_PathPlanningSM_nozzle,
								   		    const_PathPlanningSM_battery_low,
								   		    const_PathPlanningSM_sleep_time,
								   		    const_PathPlanningSM_acc_distance)
								   [| { share__, terminate } |] (
								   Sleep::VS_O__(id__,
								   		    const_PathPlanningSM_cliff,
								   		    const_PathPlanningSM_nozzle,
								   		    const_PathPlanningSM_battery_low,
								   		    const_PathPlanningSM_sleep_time,
								   		    const_PathPlanningSM_acc_distance)
								   [| { share__, terminate } |] (
								   Check_end::VS_O__(id__,
								   		    const_PathPlanningSM_cliff,
								   		    const_PathPlanningSM_nozzle,
								   		    const_PathPlanningSM_battery_low,
								   		    const_PathPlanningSM_sleep_time,
								   		    const_PathPlanningSM_acc_distance)
								   [| { share__, terminate } |] (
								   Check_battery::VS_O__(id__,
								   		    const_PathPlanningSM_cliff,
								   		    const_PathPlanningSM_nozzle,
								   		    const_PathPlanningSM_battery_low,
								   		    const_PathPlanningSM_sleep_time,
								   		    const_PathPlanningSM_acc_distance)
								   [| { share__, terminate } |] (
								   Resume::VS_O__(id__,
								   		    const_PathPlanningSM_cliff,
								   		    const_PathPlanningSM_nozzle,
								   		    const_PathPlanningSM_battery_low,
								   		    const_PathPlanningSM_sleep_time,
								   		    const_PathPlanningSM_acc_distance)
								   )
								   )
								   )
								   )
								   )
								   )
								   )
								   )
								   )
								   )
								 )
								 [[Go_up::interrupt <- x__ | x__ <- {|interrupt,ultrasonic__.NID_Go_up.in|}]]
								 [[Go_right::interrupt <- x__ | x__ <- {|interrupt,displacement__.NID_Go_right.in,ultrasonic__.NID_Go_right.in|}]]
								 [[Go_down::interrupt <- x__ | x__ <- {|interrupt,ultrasonic__.NID_Go_down.in|}]]
								 [[Go_right_again::interrupt <- x__ | x__ <- {|interrupt,ultrasonic__.NID_Go_right_again.in,ultrasonic__.NID_Go_right_again.in|}]]
								 [[Return::interrupt <- x__ | x__ <- {|interrupt,ultrasonic__.NID_Return.in|}]]
								 [[Dock::interrupt <- x__ | x__ <- {|interrupt,charging__.NID_Dock.in|}]]
								 [[Sleep::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Sleep|}]]
								 [[Check_end::interrupt <- x__ | x__ <- {|interrupt,displacement__.NID_Check_end.in,displacement__.NID_Check_end.in|}]]
								 [[Check_battery::interrupt <- x__ | x__ <- {|interrupt,battery_level__.NID_Check_battery.in,battery_level__.NID_Check_battery.in|}]]
								 [[Resume::interrupt <- x__ | x__ <- {|interrupt,displacement__.NID_Resume.in|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_d,setR_u,setR_b |} ]] 
								  [[set_d <- setL_d,set_u <- setL_u,set_cycles <- setL_cycles,set_b <- setL_b]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_d
								 			,setL_u
								 			,setL_cycles
								 			,setL_b
								 			,setR_d
								 			 			,setR_u
								 			 			,setR_b
								 			|}) |]
								 ((i0::enter -> Transitions(id__,
								 		    const_PathPlanningSM_cliff,
								 		    const_PathPlanningSM_nozzle,
								 		    const_PathPlanningSM_battery_low,
								 		    const_PathPlanningSM_sleep_time,
								 		    const_PathPlanningSM_acc_distance))
								  [[ share__ <- x__ | x__ <- {| share__,setL_d,setL_u,setL_cycles,setL_b |} ]]
								  [[set_d <- setR_d,set_u <- setR_u,set_b <- setR_b]]
								 )
								)[[setL_d <- set_d,setL_u <- set_u,setL_cycles <- set_cycles,setL_b <- set_b]]
								 [[setR_d <- set_d,setR_u <- set_u,setR_b <- set_b]]
								)
							)
							 \ hideSet)
							[[
								move_forward__.x____ <- move_forward,
								turn__.x____ <- turn,
								stop__.x____ <- stop,
								ultrasonic__.x____ <- ultrasonic,
								battery_level__.x____ <- battery_level,
								charging__.x____ <- charging,
								clean__.x____ <- clean,
								displacement__.x____ <- displacement
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance) = 
					dbisim((MachineBody_VS_O(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance))
					)
				
				IteratedBehaviour_VS_O(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance) = 
					dbisim((MachineBody_VS_O(id__,
							    const_PathPlanningSM_cliff,
							    const_PathPlanningSM_nozzle,
							    const_PathPlanningSM_battery_low,
							    const_PathPlanningSM_sleep_time,
							    const_PathPlanningSM_acc_distance))
					)
				
				Stateful_VS_O(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance) = 
					dbisim((
						(Behaviour_VS_O(id__,
								    const_PathPlanningSM_cliff,
								    const_PathPlanningSM_nozzle,
								    const_PathPlanningSM_battery_low,
								    const_PathPlanningSM_sleep_time,
								    const_PathPlanningSM_acc_distance) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
								    const_PathPlanningSM_cliff,
								    const_PathPlanningSM_nozzle,
								    const_PathPlanningSM_battery_low,
								    const_PathPlanningSM_sleep_time,
								    const_PathPlanningSM_acc_distance))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful_VS_O(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													Behaviour_VS_O(id__,
															    const_PathPlanningSM_cliff,
															    const_PathPlanningSM_nozzle,
															    const_PathPlanningSM_battery_low,
															    const_PathPlanningSM_sleep_time,
															    const_PathPlanningSM_acc_distance)
													[| {|get_b,set_b,terminate|} |]
													Memory_b(0)
												)\{|get_b,set_b|}
											)
											[| {|get_d,set_d,terminate|} |]
											Memory_d(0)
										)\{|get_d,set_d|}
									)
									[| {|get_u,set_u,terminate|} |]
									Memory_u(0)
								)\{|get_u,set_u|}
							)
							[| {|get_cycles,set_cycles,terminate|} |]
							Memory_cycles(0)
						)\{|get_cycles,set_cycles|}
					)
					)
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_cycles(cycles) =
					get_cycles!cycles -> Memory_cycles(cycles)
					[]
					set_cycles?x__ -> Memory_cycles(x__)
					[]
					terminate -> SKIP
				Memory_u(u) =
					get_u!u -> Memory_u(u)
					[]
					set_u?x__ -> Memory_u(x__)
					[]
					terminate -> SKIP
				Memory_d(d) =
					get_d!d -> Memory_d(d)
					[]
					set_d?x__ -> Memory_d(x__)
					[]
					terminate -> SKIP
				Memory_b(b) =
					get_b!b -> Memory_b(b)
					[]
					set_b?x__ -> Memory_b(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance) = Memory_cycles(0)
				[| { terminate } |] (
				Memory_u(0)
				[| { terminate } |] (
				Memory_d(0)
				[| { terminate } |] (
				Memory_b(0)
				)
				)
				)
				
				getsetLocalChannels = {|get_cycles,set_cycles,get_u,set_u,get_d,set_d,get_b,set_b|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance) = STM_VS_O(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance)
				
				D__(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance) = STM(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance) \ internal_events
				O__(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance) = sbisim(diamond(D__(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance)))
				VS__(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance) = FVS__(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance)
				VS_O__(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance) = sbisim(diamond(FVS__(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance)))
				HEXT__(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance) = O__(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance) [|shared_variable_events|] SKIP
				HUP__(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance) = O__(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance) [|{share__}|] SKIP
				
				-- Shared memory
				-- Shared memory variables
				
				-- sharedVarMemory process
				sharedVarMemory(id__,
						    const_PathPlanningSM_cliff,
						    const_PathPlanningSM_nozzle,
						    const_PathPlanningSM_battery_low,
						    const_PathPlanningSM_sleep_time,
						    const_PathPlanningSM_acc_distance) = terminate -> SKIP
				
				sharedVarSync = {||}
				
				sharedVarHide = {||}
			endmodule
			module stm_ref1
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_wait_input|
				              NID_update_speed
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_acceleration, set_acceleration, setL_acceleration, setR_acceleration: TripleAxis
				channel get_speed, set_speed, setL_speed, setR_speed: TripleAxis
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel acc__: NIDS.InOut.TripleAxis
				channel acc: InOut.TripleAxis
				channel sp__: NIDS.InOut.TripleAxis
				channel sp: InOut.TripleAxis
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				wait_input::enter,
				update_speed::enter
				|}
				
				enteredSS = 	{|
				wait_input::entered,
				update_speed::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	acc,
					sp
					|}
			
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, interrupt
					
					D__(id__,
							    const_SpeedSM_t) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
					
					VS_O__(id__,
							    const_SpeedSM_t) = D__(id__,
							    const_SpeedSM_t)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: wait_input
				module wait_input
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_SpeedSM_t) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_SpeedSM_t) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: update_speed
				module update_speed
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_SpeedSM_t) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(share__choice(get_speed?speed -> share__choice(get_acceleration?acceleration -> true & (share__choice(set_speed!update_TripleAxis_X(speed,Plus(TripleAxis_X(speed), Mult(TripleAxis_X(acceleration), const_SpeedSM_t, core_int), core_int)) -> SKIP)))));share__choice(share__choice(get_speed?speed -> share__choice(get_acceleration?acceleration -> true & (share__choice(set_speed!update_TripleAxis_Y(speed,Plus(TripleAxis_Y(speed), Mult(TripleAxis_Y(acceleration), const_SpeedSM_t, core_int), core_int)) -> SKIP)))));share__choice(share__choice(get_speed?speed -> share__choice(get_acceleration?acceleration -> true & (share__choice(set_speed!update_TripleAxis_Z(speed,Plus(TripleAxis_Z(speed), Mult(TripleAxis_Z(acceleration), const_SpeedSM_t, core_int), core_int)) -> SKIP))))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_SpeedSM_t) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(share__choice(get_speed?speed -> share__choice(get_acceleration?acceleration -> true & (share__choice(set_speed!update_TripleAxis_X(speed,Plus(TripleAxis_X(speed), Mult(TripleAxis_X(acceleration), const_SpeedSM_t, core_int), core_int)) -> SKIP)))));share__choice(share__choice(get_speed?speed -> share__choice(get_acceleration?acceleration -> true & (share__choice(set_speed!update_TripleAxis_Y(speed,Plus(TripleAxis_Y(speed), Mult(TripleAxis_Y(acceleration), const_SpeedSM_t, core_int), core_int)) -> SKIP)))));share__choice(share__choice(get_speed?speed -> share__choice(get_acceleration?acceleration -> true & (share__choice(set_speed!update_TripleAxis_Z(speed,Plus(TripleAxis_Z(speed), Mult(TripleAxis_Z(acceleration), const_SpeedSM_t, core_int), core_int)) -> SKIP))))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				-- END of Operation calls --
				
				-- STM processes
				STM(id__,
						    const_SpeedSM_t) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful(id__,
									    const_SpeedSM_t) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,
							    const_SpeedSM_t))
				)\sharedVarHide
				
				STM_VS_O(id__,
						    const_SpeedSM_t) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful_VS_O(id__,
									    const_SpeedSM_t) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,
							    const_SpeedSM_t))
				)\sharedVarHide
				
				-- Transitions
				Transitions(id__,
						    const_SpeedSM_t) = ((let
					Trans = (
						((share__ -> SKIP
						 [] dbisim((true)&(acc__!NID_wait_input.in?acceleration:{acceleration|acceleration <- TripleAxis, true} -> share__choice(set_acceleration!acceleration -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; update_speed::enter -> SKIP)))
						 	 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((share__choice(share__choice(get_speed?speed -> true & (share__choice(set_speed!update_TripleAxis_X(speed,0) -> SKIP))));share__choice(share__choice(get_speed?speed -> true & (share__choice(set_speed!update_TripleAxis_Y(speed,0) -> SKIP))));share__choice(share__choice(get_speed?speed -> true & (share__choice(set_speed!update_TripleAxis_Z(speed,0) -> SKIP)))) ; wait_input::enter -> SKIP))))
						 	 [] dbisim((true)&(internal__!NID_update_speed -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_speed?speed -> true&(share__choice(sp.out!speed -> SKIP)));SKIP ; wait_input::enter -> SKIP)))
						 ) ; Trans)
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
					)
				within
					Trans
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__,
						    const_SpeedSM_t) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							wait_input::enter,
							update_speed::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|acc__.NID_wait_input.in,internal__.NID_i0,internal__.NID_update_speed|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::D__(id__,
								   		    const_SpeedSM_t)
								   [| { share__, terminate } |] (
								   wait_input::D__(id__,
								   		    const_SpeedSM_t)
								   [| { share__, terminate } |] (
								   update_speed::D__(id__,
								   		    const_SpeedSM_t)
								   )
								   )
								 )
								 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,acc__.NID_wait_input.in|}]]
								 [[update_speed::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_update_speed|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_acceleration |} ]] 
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setR_acceleration
								 			|}) |]
								 ((i0::enter -> Transitions(id__,
								 		    const_SpeedSM_t))
								  [[ share__ <- x__ | x__ <- {| share__ |} ]]
								  [[set_acceleration <- setR_acceleration]]
								 )
								)
								 [[setR_acceleration <- set_acceleration]]
								)
							)
							 \ hideSet)
							[[
								acc__.x____ <- acc,
								sp__.x____ <- sp
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__,
						    const_SpeedSM_t) = 
					dbisim((MachineBody(id__,
							    const_SpeedSM_t)\ enteredSS)
					)
				
				IteratedBehaviour(id__,
						    const_SpeedSM_t) = 
					dbisim((MachineBody(id__,
							    const_SpeedSM_t)\ enteredSS)
					)
				
				Stateful(id__,
						    const_SpeedSM_t) = 
					((
						(Behaviour(id__,
								    const_SpeedSM_t) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
								    const_SpeedSM_t))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful(id__,
						    const_SpeedSM_t) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									Behaviour(id__,
											    const_SpeedSM_t)
									[| {|get_speed,set_speed,terminate|} |]
									Memory_speed((0,0,0))
								)\{|get_speed,set_speed|}
							)
							[| {|get_acceleration,set_acceleration,terminate|} |]
							Memory_acceleration((0,0,0))
						)\{|get_acceleration,set_acceleration|}
					)
					)
				
				-- Visible counterparts
				MachineBody_VS_O(id__,
						    const_SpeedSM_t) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							wait_input::enter,
							update_speed::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|acc__.NID_wait_input.in,internal__.NID_i0,internal__.NID_update_speed|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::VS_O__(id__,
								   		    const_SpeedSM_t)
								   [| { share__, terminate } |] (
								   wait_input::VS_O__(id__,
								   		    const_SpeedSM_t)
								   [| { share__, terminate } |] (
								   update_speed::VS_O__(id__,
								   		    const_SpeedSM_t)
								   )
								   )
								 )
								 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,acc__.NID_wait_input.in|}]]
								 [[update_speed::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_update_speed|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_acceleration |} ]] 
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setR_acceleration
								 			|}) |]
								 ((i0::enter -> Transitions(id__,
								 		    const_SpeedSM_t))
								  [[ share__ <- x__ | x__ <- {| share__ |} ]]
								  [[set_acceleration <- setR_acceleration]]
								 )
								)
								 [[setR_acceleration <- set_acceleration]]
								)
							)
							 \ hideSet)
							[[
								acc__.x____ <- acc,
								sp__.x____ <- sp
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__,
						    const_SpeedSM_t) = 
					dbisim((MachineBody_VS_O(id__,
							    const_SpeedSM_t))
					)
				
				IteratedBehaviour_VS_O(id__,
						    const_SpeedSM_t) = 
					dbisim((MachineBody_VS_O(id__,
							    const_SpeedSM_t))
					)
				
				Stateful_VS_O(id__,
						    const_SpeedSM_t) = 
					dbisim((
						(Behaviour_VS_O(id__,
								    const_SpeedSM_t) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
								    const_SpeedSM_t))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful_VS_O(id__,
						    const_SpeedSM_t) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									Behaviour_VS_O(id__,
											    const_SpeedSM_t)
									[| {|get_speed,set_speed,terminate|} |]
									Memory_speed((0,0,0))
								)\{|get_speed,set_speed|}
							)
							[| {|get_acceleration,set_acceleration,terminate|} |]
							Memory_acceleration((0,0,0))
						)\{|get_acceleration,set_acceleration|}
					)
					)
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_acceleration(acceleration) =
					get_acceleration!acceleration -> Memory_acceleration(acceleration)
					[]
					set_acceleration?x__ -> Memory_acceleration(x__)
					[]
					terminate -> SKIP
				Memory_speed(speed) =
					get_speed!speed -> Memory_speed(speed)
					[]
					set_speed?x__ -> Memory_speed(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__,
						    const_SpeedSM_t) = Memory_acceleration((0,0,0))
				[| { terminate } |] (
				Memory_speed((0,0,0))
				)
				
				getsetLocalChannels = {|get_acceleration,set_acceleration,get_speed,set_speed|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__,
						    const_SpeedSM_t) = STM_VS_O(id__,
						    const_SpeedSM_t)
				
				D__(id__,
						    const_SpeedSM_t) = STM(id__,
						    const_SpeedSM_t) \ internal_events
				O__(id__,
						    const_SpeedSM_t) = sbisim(diamond(D__(id__,
						    const_SpeedSM_t)))
				VS__(id__,
						    const_SpeedSM_t) = FVS__(id__,
						    const_SpeedSM_t)
				VS_O__(id__,
						    const_SpeedSM_t) = sbisim(diamond(FVS__(id__,
						    const_SpeedSM_t)))
				HEXT__(id__,
						    const_SpeedSM_t) = O__(id__,
						    const_SpeedSM_t) [|shared_variable_events|] SKIP
				HUP__(id__,
						    const_SpeedSM_t) = O__(id__,
						    const_SpeedSM_t) [|{share__}|] SKIP
				
				-- Shared memory
				-- Shared memory variables
				
				-- sharedVarMemory process
				sharedVarMemory(id__,
						    const_SpeedSM_t) = terminate -> SKIP
				
				sharedVarSync = {||}
				
				sharedVarHide = {||}
			endmodule
			module stm_ref2
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_wait_input|
				              NID_update_speed
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_acceleration, set_acceleration, setL_acceleration, setR_acceleration: TripleAxis
				channel get_speed, set_speed, setL_speed, setR_speed: TripleAxis
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel acc__: NIDS.InOut.TripleAxis
				channel acc: InOut.TripleAxis
				channel sp__: NIDS.InOut.TripleAxis
				channel sp: InOut.TripleAxis
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				wait_input::enter,
				update_speed::enter
				|}
				
				enteredSS = 	{|
				wait_input::entered,
				update_speed::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	acc,
					sp
					|}
			
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, interrupt
					
					D__(id__,
							    const_SpeedSM_t) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
					
					VS_O__(id__,
							    const_SpeedSM_t) = D__(id__,
							    const_SpeedSM_t)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: wait_input
				module wait_input
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_SpeedSM_t) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_SpeedSM_t) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: update_speed
				module update_speed
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_SpeedSM_t) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(share__choice(get_speed?speed -> share__choice(get_acceleration?acceleration -> true & (share__choice(set_speed!update_TripleAxis_X(speed,Plus(TripleAxis_X(speed), Mult(TripleAxis_X(acceleration), const_SpeedSM_t, core_int), core_int)) -> SKIP)))));share__choice(share__choice(get_speed?speed -> share__choice(get_acceleration?acceleration -> true & (share__choice(set_speed!update_TripleAxis_Y(speed,Plus(TripleAxis_Y(speed), Mult(TripleAxis_Y(acceleration), const_SpeedSM_t, core_int), core_int)) -> SKIP)))));share__choice(share__choice(get_speed?speed -> share__choice(get_acceleration?acceleration -> true & (share__choice(set_speed!update_TripleAxis_Z(speed,Plus(TripleAxis_Z(speed), Mult(TripleAxis_Z(acceleration), const_SpeedSM_t, core_int), core_int)) -> SKIP))))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_SpeedSM_t) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(share__choice(get_speed?speed -> share__choice(get_acceleration?acceleration -> true & (share__choice(set_speed!update_TripleAxis_X(speed,Plus(TripleAxis_X(speed), Mult(TripleAxis_X(acceleration), const_SpeedSM_t, core_int), core_int)) -> SKIP)))));share__choice(share__choice(get_speed?speed -> share__choice(get_acceleration?acceleration -> true & (share__choice(set_speed!update_TripleAxis_Y(speed,Plus(TripleAxis_Y(speed), Mult(TripleAxis_Y(acceleration), const_SpeedSM_t, core_int), core_int)) -> SKIP)))));share__choice(share__choice(get_speed?speed -> share__choice(get_acceleration?acceleration -> true & (share__choice(set_speed!update_TripleAxis_Z(speed,Plus(TripleAxis_Z(speed), Mult(TripleAxis_Z(acceleration), const_SpeedSM_t, core_int), core_int)) -> SKIP))))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				-- END of Operation calls --
				
				-- STM processes
				STM(id__,
						    const_SpeedSM_t) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful(id__,
									    const_SpeedSM_t) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,
							    const_SpeedSM_t))
				)\sharedVarHide
				
				STM_VS_O(id__,
						    const_SpeedSM_t) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful_VS_O(id__,
									    const_SpeedSM_t) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,
							    const_SpeedSM_t))
				)\sharedVarHide
				
				-- Transitions
				Transitions(id__,
						    const_SpeedSM_t) = ((let
					Trans = (
						((share__ -> SKIP
						 [] dbisim((true)&(acc__!NID_wait_input.in?acceleration:{acceleration|acceleration <- TripleAxis, true} -> share__choice(set_acceleration!acceleration -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; update_speed::enter -> SKIP)))
						 	 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((share__choice(share__choice(get_speed?speed -> true & (share__choice(set_speed!update_TripleAxis_X(speed,0) -> SKIP))));share__choice(share__choice(get_speed?speed -> true & (share__choice(set_speed!update_TripleAxis_Y(speed,0) -> SKIP))));share__choice(share__choice(get_speed?speed -> true & (share__choice(set_speed!update_TripleAxis_Z(speed,0) -> SKIP)))) ; wait_input::enter -> SKIP))))
						 	 [] dbisim((true)&(internal__!NID_update_speed -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_speed?speed -> true&(share__choice(sp.out!speed -> SKIP)));SKIP ; wait_input::enter -> SKIP)))
						 ) ; Trans)
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
					)
				within
					Trans
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__,
						    const_SpeedSM_t) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							wait_input::enter,
							update_speed::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|acc__.NID_wait_input.in,internal__.NID_i0,internal__.NID_update_speed|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::D__(id__,
								   		    const_SpeedSM_t)
								   [| { share__, terminate } |] (
								   wait_input::D__(id__,
								   		    const_SpeedSM_t)
								   [| { share__, terminate } |] (
								   update_speed::D__(id__,
								   		    const_SpeedSM_t)
								   )
								   )
								 )
								 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,acc__.NID_wait_input.in|}]]
								 [[update_speed::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_update_speed|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_acceleration |} ]] 
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setR_acceleration
								 			|}) |]
								 ((i0::enter -> Transitions(id__,
								 		    const_SpeedSM_t))
								  [[ share__ <- x__ | x__ <- {| share__ |} ]]
								  [[set_acceleration <- setR_acceleration]]
								 )
								)
								 [[setR_acceleration <- set_acceleration]]
								)
							)
							 \ hideSet)
							[[
								acc__.x____ <- acc,
								sp__.x____ <- sp
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__,
						    const_SpeedSM_t) = 
					dbisim((MachineBody(id__,
							    const_SpeedSM_t)\ enteredSS)
					)
				
				IteratedBehaviour(id__,
						    const_SpeedSM_t) = 
					dbisim((MachineBody(id__,
							    const_SpeedSM_t)\ enteredSS)
					)
				
				Stateful(id__,
						    const_SpeedSM_t) = 
					((
						(Behaviour(id__,
								    const_SpeedSM_t) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
								    const_SpeedSM_t))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful(id__,
						    const_SpeedSM_t) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									Behaviour(id__,
											    const_SpeedSM_t)
									[| {|get_speed,set_speed,terminate|} |]
									Memory_speed((0,0,0))
								)\{|get_speed,set_speed|}
							)
							[| {|get_acceleration,set_acceleration,terminate|} |]
							Memory_acceleration((0,0,0))
						)\{|get_acceleration,set_acceleration|}
					)
					)
				
				-- Visible counterparts
				MachineBody_VS_O(id__,
						    const_SpeedSM_t) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							wait_input::enter,
							update_speed::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|acc__.NID_wait_input.in,internal__.NID_i0,internal__.NID_update_speed|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::VS_O__(id__,
								   		    const_SpeedSM_t)
								   [| { share__, terminate } |] (
								   wait_input::VS_O__(id__,
								   		    const_SpeedSM_t)
								   [| { share__, terminate } |] (
								   update_speed::VS_O__(id__,
								   		    const_SpeedSM_t)
								   )
								   )
								 )
								 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,acc__.NID_wait_input.in|}]]
								 [[update_speed::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_update_speed|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_acceleration |} ]] 
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setR_acceleration
								 			|}) |]
								 ((i0::enter -> Transitions(id__,
								 		    const_SpeedSM_t))
								  [[ share__ <- x__ | x__ <- {| share__ |} ]]
								  [[set_acceleration <- setR_acceleration]]
								 )
								)
								 [[setR_acceleration <- set_acceleration]]
								)
							)
							 \ hideSet)
							[[
								acc__.x____ <- acc,
								sp__.x____ <- sp
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__,
						    const_SpeedSM_t) = 
					dbisim((MachineBody_VS_O(id__,
							    const_SpeedSM_t))
					)
				
				IteratedBehaviour_VS_O(id__,
						    const_SpeedSM_t) = 
					dbisim((MachineBody_VS_O(id__,
							    const_SpeedSM_t))
					)
				
				Stateful_VS_O(id__,
						    const_SpeedSM_t) = 
					dbisim((
						(Behaviour_VS_O(id__,
								    const_SpeedSM_t) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
								    const_SpeedSM_t))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful_VS_O(id__,
						    const_SpeedSM_t) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									Behaviour_VS_O(id__,
											    const_SpeedSM_t)
									[| {|get_speed,set_speed,terminate|} |]
									Memory_speed((0,0,0))
								)\{|get_speed,set_speed|}
							)
							[| {|get_acceleration,set_acceleration,terminate|} |]
							Memory_acceleration((0,0,0))
						)\{|get_acceleration,set_acceleration|}
					)
					)
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_acceleration(acceleration) =
					get_acceleration!acceleration -> Memory_acceleration(acceleration)
					[]
					set_acceleration?x__ -> Memory_acceleration(x__)
					[]
					terminate -> SKIP
				Memory_speed(speed) =
					get_speed!speed -> Memory_speed(speed)
					[]
					set_speed?x__ -> Memory_speed(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__,
						    const_SpeedSM_t) = Memory_acceleration((0,0,0))
				[| { terminate } |] (
				Memory_speed((0,0,0))
				)
				
				getsetLocalChannels = {|get_acceleration,set_acceleration,get_speed,set_speed|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__,
						    const_SpeedSM_t) = STM_VS_O(id__,
						    const_SpeedSM_t)
				
				D__(id__,
						    const_SpeedSM_t) = STM(id__,
						    const_SpeedSM_t) \ internal_events
				O__(id__,
						    const_SpeedSM_t) = sbisim(diamond(D__(id__,
						    const_SpeedSM_t)))
				VS__(id__,
						    const_SpeedSM_t) = FVS__(id__,
						    const_SpeedSM_t)
				VS_O__(id__,
						    const_SpeedSM_t) = sbisim(diamond(FVS__(id__,
						    const_SpeedSM_t)))
				HEXT__(id__,
						    const_SpeedSM_t) = O__(id__,
						    const_SpeedSM_t) [|shared_variable_events|] SKIP
				HUP__(id__,
						    const_SpeedSM_t) = O__(id__,
						    const_SpeedSM_t) [|{share__}|] SKIP
				
				-- Shared memory
				-- Shared memory variables
				
				-- sharedVarMemory process
				sharedVarMemory(id__,
						    const_SpeedSM_t) = terminate -> SKIP
				
				sharedVarSync = {||}
				
				sharedVarHide = {||}
			endmodule
			module stm_ref3
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_wait_input|
				              NID_update_displacement|
				              NID_j0
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_d, set_d, setL_d, setR_d: core_int
				channel get_speed, set_speed, setL_speed, setR_speed: TripleAxis
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel sp__: NIDS.InOut.TripleAxis
				channel sp: InOut.TripleAxis
				channel displacement__: NIDS.InOut.core_int
				channel displacement: InOut.core_int
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				wait_input::enter,
				update_displacement::enter,
				j0::enter
				|}
				
				enteredSS = 	{|
				wait_input::entered,
				update_displacement::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	sp,
					displacement
					|}
			
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, interrupt
					
					D__(id__,
							    const_DisplacementSM_t) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
					
					VS_O__(id__,
							    const_DisplacementSM_t) = D__(id__,
							    const_DisplacementSM_t)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: wait_input
				module wait_input
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_DisplacementSM_t) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_DisplacementSM_t) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: update_displacement
				module update_displacement
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_DisplacementSM_t) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(share__choice(get_d?d -> share__choice(get_speed?speed -> true & (share__choice(set_d!Plus(d, Mult(TripleAxis_X(speed), const_DisplacementSM_t, core_int), core_int) -> SKIP))))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_DisplacementSM_t) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(share__choice(get_d?d -> share__choice(get_speed?speed -> true & (share__choice(set_d!Plus(d, Mult(TripleAxis_X(speed), const_DisplacementSM_t, core_int), core_int) -> SKIP))))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Junction: j0
				module j0
				exports
				
					channel enter, interrupt
					
					D__(id__,
							    const_DisplacementSM_t) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_DisplacementSM_t) = D__(id__,
							    const_DisplacementSM_t)
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				-- END of Operation calls --
				
				-- STM processes
				STM(id__,
						    const_DisplacementSM_t) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful(id__,
									    const_DisplacementSM_t) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,
							    const_DisplacementSM_t))
				)\sharedVarHide
				
				STM_VS_O(id__,
						    const_DisplacementSM_t) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful_VS_O(id__,
									    const_DisplacementSM_t) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,
							    const_DisplacementSM_t))
				)\sharedVarHide
				
				-- Transitions
				Transitions(id__,
						    const_DisplacementSM_t) = ((let
					Trans = share__choice(get_d?d -> (
						((share__ -> SKIP
						 [] dbisim((true)&(sp__!NID_wait_input.in?speed:{speed|speed <- TripleAxis, true} -> share__choice(set_speed!speed -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; update_displacement::enter -> SKIP)))
						 	 [] dbisim((true)&(internal__!NID_update_displacement -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_d?d -> true&(share__choice(displacement.out!d -> SKIP)));SKIP ; wait_input::enter -> SKIP)))
						 	 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((share__choice(true & (share__choice(set_d!0 -> SKIP))) ; j0::enter -> SKIP))))
						 	 [] dbisim((true)&(internal__!NID_j0 -> SKIP ;  ((SKIP ; wait_input::enter -> SKIP))))
						 	 [] dbisim((displacement__!NID_wait_input.in?d:{d|d <- core_int, (d==0)} -> share__choice(set_d!d -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; j0::enter -> SKIP)))
						 ) ; Trans)
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
					)
					)
				within
					Trans
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__,
						    const_DisplacementSM_t) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							wait_input::enter,
							update_displacement::enter,
							j0::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|sp__.NID_wait_input.in,internal__.NID_update_displacement,internal__.NID_i0,internal__.NID_j0,displacement__.NID_wait_input.in|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::D__(id__,
								   		    const_DisplacementSM_t)
								   [| { share__, terminate } |] (
								   wait_input::D__(id__,
								   		    const_DisplacementSM_t)
								   [| { share__, terminate } |] (
								   update_displacement::D__(id__,
								   		    const_DisplacementSM_t)
								   [| { share__, terminate } |] (
								   j0::D__(id__,
								   		    const_DisplacementSM_t)
								   )
								   )
								   )
								 )
								 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,sp__.NID_wait_input.in,displacement__.NID_wait_input.in|}]]
								 [[update_displacement::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_update_displacement|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 [[j0::interrupt <- x__ | x__ <- {|internal__.NID_j0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_d,setR_speed |} ]] 
								  [[set_d <- setL_d]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_d
								 			,setR_d
								 			 			,setR_speed
								 			|}) |]
								 ((i0::enter -> Transitions(id__,
								 		    const_DisplacementSM_t))
								  [[ share__ <- x__ | x__ <- {| share__,setL_d |} ]]
								  [[set_d <- setR_d,set_speed <- setR_speed]]
								 )
								)[[setL_d <- set_d]]
								 [[setR_d <- set_d,setR_speed <- set_speed]]
								)
							)
							 \ hideSet)
							[[
								sp__.x____ <- sp,
								displacement__.x____ <- displacement
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__,
						    const_DisplacementSM_t) = 
					dbisim((MachineBody(id__,
							    const_DisplacementSM_t)\ enteredSS)
					)
				
				IteratedBehaviour(id__,
						    const_DisplacementSM_t) = 
					dbisim((MachineBody(id__,
							    const_DisplacementSM_t)\ enteredSS)
					)
				
				Stateful(id__,
						    const_DisplacementSM_t) = 
					((
						(Behaviour(id__,
								    const_DisplacementSM_t) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
								    const_DisplacementSM_t))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful(id__,
						    const_DisplacementSM_t) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									Behaviour(id__,
											    const_DisplacementSM_t)
									[| {|get_speed,set_speed,terminate|} |]
									Memory_speed((0,0,0))
								)\{|get_speed,set_speed|}
							)
							[| {|get_d,set_d,terminate|} |]
							Memory_d(0)
						)\{|get_d,set_d|}
					)
					)
				
				-- Visible counterparts
				MachineBody_VS_O(id__,
						    const_DisplacementSM_t) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							wait_input::enter,
							update_displacement::enter,
							j0::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|sp__.NID_wait_input.in,internal__.NID_update_displacement,internal__.NID_i0,internal__.NID_j0,displacement__.NID_wait_input.in|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::VS_O__(id__,
								   		    const_DisplacementSM_t)
								   [| { share__, terminate } |] (
								   wait_input::VS_O__(id__,
								   		    const_DisplacementSM_t)
								   [| { share__, terminate } |] (
								   update_displacement::VS_O__(id__,
								   		    const_DisplacementSM_t)
								   [| { share__, terminate } |] (
								   j0::VS_O__(id__,
								   		    const_DisplacementSM_t)
								   )
								   )
								   )
								 )
								 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,sp__.NID_wait_input.in,displacement__.NID_wait_input.in|}]]
								 [[update_displacement::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_update_displacement|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 [[j0::interrupt <- x__ | x__ <- {|internal__.NID_j0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_d,setR_speed |} ]] 
								  [[set_d <- setL_d]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_d
								 			,setR_d
								 			 			,setR_speed
								 			|}) |]
								 ((i0::enter -> Transitions(id__,
								 		    const_DisplacementSM_t))
								  [[ share__ <- x__ | x__ <- {| share__,setL_d |} ]]
								  [[set_d <- setR_d,set_speed <- setR_speed]]
								 )
								)[[setL_d <- set_d]]
								 [[setR_d <- set_d,setR_speed <- set_speed]]
								)
							)
							 \ hideSet)
							[[
								sp__.x____ <- sp,
								displacement__.x____ <- displacement
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__,
						    const_DisplacementSM_t) = 
					dbisim((MachineBody_VS_O(id__,
							    const_DisplacementSM_t))
					)
				
				IteratedBehaviour_VS_O(id__,
						    const_DisplacementSM_t) = 
					dbisim((MachineBody_VS_O(id__,
							    const_DisplacementSM_t))
					)
				
				Stateful_VS_O(id__,
						    const_DisplacementSM_t) = 
					dbisim((
						(Behaviour_VS_O(id__,
								    const_DisplacementSM_t) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
								    const_DisplacementSM_t))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful_VS_O(id__,
						    const_DisplacementSM_t) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									Behaviour_VS_O(id__,
											    const_DisplacementSM_t)
									[| {|get_speed,set_speed,terminate|} |]
									Memory_speed((0,0,0))
								)\{|get_speed,set_speed|}
							)
							[| {|get_d,set_d,terminate|} |]
							Memory_d(0)
						)\{|get_d,set_d|}
					)
					)
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_d(d) =
					get_d!d -> Memory_d(d)
					[]
					set_d?x__ -> Memory_d(x__)
					[]
					terminate -> SKIP
				Memory_speed(speed) =
					get_speed!speed -> Memory_speed(speed)
					[]
					set_speed?x__ -> Memory_speed(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__,
						    const_DisplacementSM_t) = Memory_d(0)
				[| { terminate } |] (
				Memory_speed((0,0,0))
				)
				
				getsetLocalChannels = {|get_d,set_d,get_speed,set_speed|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__,
						    const_DisplacementSM_t) = STM_VS_O(id__,
						    const_DisplacementSM_t)
				
				D__(id__,
						    const_DisplacementSM_t) = STM(id__,
						    const_DisplacementSM_t) \ internal_events
				O__(id__,
						    const_DisplacementSM_t) = sbisim(diamond(D__(id__,
						    const_DisplacementSM_t)))
				VS__(id__,
						    const_DisplacementSM_t) = FVS__(id__,
						    const_DisplacementSM_t)
				VS_O__(id__,
						    const_DisplacementSM_t) = sbisim(diamond(FVS__(id__,
						    const_DisplacementSM_t)))
				HEXT__(id__,
						    const_DisplacementSM_t) = O__(id__,
						    const_DisplacementSM_t) [|shared_variable_events|] SKIP
				HUP__(id__,
						    const_DisplacementSM_t) = O__(id__,
						    const_DisplacementSM_t) [|{share__}|] SKIP
				
				-- Shared memory
				-- Shared memory variables
				
				-- sharedVarMemory process
				sharedVarMemory(id__,
						    const_DisplacementSM_t) = terminate -> SKIP
				
				sharedVarSync = {||}
				
				sharedVarHide = {||}
			endmodule
			module stm_ref4
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_clean|
				              NID_dont_clean
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_clean_var, set_clean_var, setL_clean_var, setR_clean_var: core_boolean
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel clean__: NIDS.InOut.core_boolean
				channel clean: InOut.core_boolean
				
				-- Declaring call and ret events for undefined operations
				channel brushCall: core_int
				channel vacuumCall: core_int
				
				enterSS = {|
				i0::enter,
				clean::enter,
				dont_clean::enter
				|}
				
				enteredSS = 	{|
				clean::entered,
				dont_clean::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	clean
				,	brushCall,
					vacuumCall
					|}
			
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, interrupt
					
					D__(id__,
							    const_CleanSM_voltage) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
					
					VS_O__(id__,
							    const_CleanSM_voltage) = D__(id__,
							    const_CleanSM_voltage)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: clean
				module clean
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_CleanSM_voltage) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&CALL__brush(
									id__,
								    const_CleanSM_voltage,
									const_CleanSM_voltage
								);true&CALL__vacuum(
									id__,
								    const_CleanSM_voltage,
									const_CleanSM_voltage
								) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_CleanSM_voltage) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&CALL__brush(
									id__,
								    const_CleanSM_voltage,
									const_CleanSM_voltage
								);true&CALL__vacuum(
									id__,
								    const_CleanSM_voltage,
									const_CleanSM_voltage
								) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: dont_clean
				module dont_clean
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_CleanSM_voltage) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&CALL__brush(
									id__,
								    const_CleanSM_voltage,
									0
								);true&CALL__vacuum(
									id__,
								    const_CleanSM_voltage,
									0
								) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_CleanSM_voltage) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&CALL__brush(
									id__,
								    const_CleanSM_voltage,
									0
								);true&CALL__vacuum(
									id__,
								    const_CleanSM_voltage,
									0
								) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				CALL__brush(id__,
						    const_CleanSM_voltage,
							param_x) 	= brushCall.param_x -> SKIP
				CALL__vacuum(id__,
						    const_CleanSM_voltage,
							param_x) 	= vacuumCall.param_x -> SKIP
				
				-- END of Operation calls --
				
				-- STM processes
				STM(id__,
						    const_CleanSM_voltage) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful(id__,
									    const_CleanSM_voltage) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,
							    const_CleanSM_voltage))
				)\sharedVarHide
				
				STM_VS_O(id__,
						    const_CleanSM_voltage) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful_VS_O(id__,
									    const_CleanSM_voltage) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,
							    const_CleanSM_voltage))
				)\sharedVarHide
				
				-- Transitions
				Transitions(id__,
						    const_CleanSM_voltage) = ((let
					Trans = share__choice(get_clean_var?clean_var -> (
						((share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; dont_clean::enter -> SKIP))))
						 	 [] dbisim((clean__!NID_dont_clean.in?clean_var:{clean_var|clean_var <- core_boolean, (clean_var==true)} -> share__choice(set_clean_var!clean_var -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; clean::enter -> SKIP)))
						 	 [] dbisim((clean__!NID_clean.in?clean_var:{clean_var|clean_var <- core_boolean, (clean_var==false)} -> share__choice(set_clean_var!clean_var -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; dont_clean::enter -> SKIP)))
						 ) ; Trans)
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
					)
					)
				within
					Trans
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__,
						    const_CleanSM_voltage) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							clean::enter,
							dont_clean::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0,clean__.NID_dont_clean.in,clean__.NID_clean.in|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::D__(id__,
								   		    const_CleanSM_voltage)
								   [| { share__, terminate } |] (
								   clean::D__(id__,
								   		    const_CleanSM_voltage)
								   [| { share__, terminate } |] (
								   dont_clean::D__(id__,
								   		    const_CleanSM_voltage)
								   )
								   )
								 )
								 [[clean::interrupt <- x__ | x__ <- {|interrupt,clean__.NID_clean.in|}]]
								 [[dont_clean::interrupt <- x__ | x__ <- {|interrupt,clean__.NID_dont_clean.in|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_clean_var |} ]] 
								  [[set_clean_var <- setL_clean_var]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_clean_var
								 			,setR_clean_var
								 			|}) |]
								 ((i0::enter -> Transitions(id__,
								 		    const_CleanSM_voltage))
								  [[ share__ <- x__ | x__ <- {| share__,setL_clean_var |} ]]
								  [[set_clean_var <- setR_clean_var]]
								 )
								)[[setL_clean_var <- set_clean_var]]
								 [[setR_clean_var <- set_clean_var]]
								)
							)
							 \ hideSet)
							[[
								clean__.x____ <- clean
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__,
						    const_CleanSM_voltage) = 
					dbisim((MachineBody(id__,
							    const_CleanSM_voltage)\ enteredSS)
					)
				
				IteratedBehaviour(id__,
						    const_CleanSM_voltage) = 
					dbisim((MachineBody(id__,
							    const_CleanSM_voltage)\ enteredSS)
					)
				
				Stateful(id__,
						    const_CleanSM_voltage) = 
					((
						(Behaviour(id__,
								    const_CleanSM_voltage) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
								    const_CleanSM_voltage))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful(id__,
						    const_CleanSM_voltage) =
					(dbisim(
						sbisim(
							Behaviour(id__,
									    const_CleanSM_voltage)
							[| {|get_clean_var,set_clean_var,terminate|} |]
							Memory_clean_var(true)
						)\{|get_clean_var,set_clean_var|}
					)
					)
				
				-- Visible counterparts
				MachineBody_VS_O(id__,
						    const_CleanSM_voltage) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							clean::enter,
							dont_clean::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0,clean__.NID_dont_clean.in,clean__.NID_clean.in|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::VS_O__(id__,
								   		    const_CleanSM_voltage)
								   [| { share__, terminate } |] (
								   clean::VS_O__(id__,
								   		    const_CleanSM_voltage)
								   [| { share__, terminate } |] (
								   dont_clean::VS_O__(id__,
								   		    const_CleanSM_voltage)
								   )
								   )
								 )
								 [[clean::interrupt <- x__ | x__ <- {|interrupt,clean__.NID_clean.in|}]]
								 [[dont_clean::interrupt <- x__ | x__ <- {|interrupt,clean__.NID_dont_clean.in|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_clean_var |} ]] 
								  [[set_clean_var <- setL_clean_var]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_clean_var
								 			,setR_clean_var
								 			|}) |]
								 ((i0::enter -> Transitions(id__,
								 		    const_CleanSM_voltage))
								  [[ share__ <- x__ | x__ <- {| share__,setL_clean_var |} ]]
								  [[set_clean_var <- setR_clean_var]]
								 )
								)[[setL_clean_var <- set_clean_var]]
								 [[setR_clean_var <- set_clean_var]]
								)
							)
							 \ hideSet)
							[[
								clean__.x____ <- clean
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__,
						    const_CleanSM_voltage) = 
					dbisim((MachineBody_VS_O(id__,
							    const_CleanSM_voltage))
					)
				
				IteratedBehaviour_VS_O(id__,
						    const_CleanSM_voltage) = 
					dbisim((MachineBody_VS_O(id__,
							    const_CleanSM_voltage))
					)
				
				Stateful_VS_O(id__,
						    const_CleanSM_voltage) = 
					dbisim((
						(Behaviour_VS_O(id__,
								    const_CleanSM_voltage) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
								    const_CleanSM_voltage))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful_VS_O(id__,
						    const_CleanSM_voltage) =
					(dbisim(
						sbisim(
							Behaviour_VS_O(id__,
									    const_CleanSM_voltage)
							[| {|get_clean_var,set_clean_var,terminate|} |]
							Memory_clean_var(true)
						)\{|get_clean_var,set_clean_var|}
					)
					)
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_clean_var(clean_var) =
					get_clean_var!clean_var -> Memory_clean_var(clean_var)
					[]
					set_clean_var?x__ -> Memory_clean_var(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__,
						    const_CleanSM_voltage) = Memory_clean_var(true)
				
				getsetLocalChannels = {|get_clean_var,set_clean_var|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__,
						    const_CleanSM_voltage) = STM_VS_O(id__,
						    const_CleanSM_voltage)
				
				D__(id__,
						    const_CleanSM_voltage) = STM(id__,
						    const_CleanSM_voltage) \ internal_events
				O__(id__,
						    const_CleanSM_voltage) = sbisim(diamond(D__(id__,
						    const_CleanSM_voltage)))
				VS__(id__,
						    const_CleanSM_voltage) = FVS__(id__,
						    const_CleanSM_voltage)
				VS_O__(id__,
						    const_CleanSM_voltage) = sbisim(diamond(FVS__(id__,
						    const_CleanSM_voltage)))
				HEXT__(id__,
						    const_CleanSM_voltage) = O__(id__,
						    const_CleanSM_voltage) [|shared_variable_events|] SKIP
				HUP__(id__,
						    const_CleanSM_voltage) = O__(id__,
						    const_CleanSM_voltage) [|{share__}|] SKIP
				
				-- Shared memory
				-- Shared memory variables
				
				-- sharedVarMemory process
				sharedVarMemory(id__,
						    const_CleanSM_voltage) = terminate -> SKIP
				
				sharedVarSync = {||}
				
				sharedVarHide = {||}
			endmodule
			module stm_ref5
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_wait_input|
				              NID_wait_ar|
				              NID_wait_al|
				              NID_update_value
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_speed, set_speed, setL_speed, setR_speed: core_int
				channel get_turn_angle, set_turn_angle, setL_turn_angle, setR_turn_angle: core_real
				channel get_direction, set_direction, setL_direction, setR_direction: Direction
				channel get_al, set_al, setL_al, setR_al: TripleAxis
				channel get_ar, set_ar, setL_ar, setR_ar: TripleAxis
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel acc_l__: NIDS.InOut.TripleAxis
				channel acc_l: InOut.TripleAxis
				channel acc_r__: NIDS.InOut.TripleAxis
				channel acc_r: InOut.TripleAxis
				channel angle__: NIDS.InOut.core_int
				channel angle: InOut.core_int
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				wait_input::enter,
				wait_ar::enter,
				wait_al::enter,
				update_value::enter
				|}
				
				enteredSS = 	{|
				wait_input::entered,
				wait_ar::entered,
				wait_al::entered,
				update_value::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	acc_l,
					acc_r,
					angle
					|}
			
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, interrupt
					
					D__(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
					
					VS_O__(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = D__(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: wait_input
				module wait_input
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: wait_ar
				module wait_ar
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: wait_al
				module wait_al
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: update_value
				module update_value
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(share__choice(get_turn_angle?turn_angle -> share__choice(get_al?al -> share__choice(get_ar?ar -> true & (share__choice(set_turn_angle!Plus(turn_angle, Mult(sqrt(Div(abs(Minus(TripleAxis_Y(al), TripleAxis_Y(ar), core_int)), const_AngularSpeedSM_acc_distance, core_real)), const_AngularSpeedSM_t, core_real), core_real) -> SKIP)))))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(share__choice(get_turn_angle?turn_angle -> share__choice(get_al?al -> share__choice(get_ar?ar -> true & (share__choice(set_turn_angle!Plus(turn_angle, Mult(sqrt(Div(abs(Minus(TripleAxis_Y(al), TripleAxis_Y(ar), core_int)), const_AngularSpeedSM_acc_distance, core_real)), const_AngularSpeedSM_t, core_real), core_real) -> SKIP)))))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				-- END of Operation calls --
				
				-- STM processes
				STM(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful(id__,
									    const_AngularSpeedSM_t,
									    const_AngularSpeedSM_acc_distance) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance))
				)\sharedVarHide
				
				STM_VS_O(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful_VS_O(id__,
									    const_AngularSpeedSM_t,
									    const_AngularSpeedSM_acc_distance) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance))
				)\sharedVarHide
				
				-- Transitions
				Transitions(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance) = ((let
					Trans = (
						((share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((share__choice(true & (share__choice(set_turn_angle!0 -> SKIP))) ; wait_input::enter -> SKIP))))
						 	 [] dbisim((true)&(acc_l__!NID_wait_input.in?al:{al|al <- TripleAxis, true} -> share__choice(set_al!al -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; wait_ar::enter -> SKIP)))
						 	 [] dbisim((true)&(acc_r__!NID_wait_input.in?ar:{ar|ar <- TripleAxis, true} -> share__choice(set_ar!ar -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; wait_al::enter -> SKIP)))
						 	 [] dbisim((true)&(acc_r__!NID_wait_ar.in?ar:{ar|ar <- TripleAxis, true} -> share__choice(set_ar!ar -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; update_value::enter -> SKIP)))
						 	 [] dbisim((true)&(acc_l__!NID_wait_al.in?al:{al|al <- TripleAxis, true} -> share__choice(set_al!al -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; update_value::enter -> SKIP)))
						 	 [] dbisim((true)&(internal__!NID_update_value -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_turn_angle?turn_angle -> share__choice(get_al?al -> true&(share__choice(angle.out!(Mult(get_sign(TripleAxis_Y(al)), floor(turn_angle), core_int)) -> SKIP))));SKIP ; wait_input::enter -> SKIP)))
						 ) ; Trans)
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
					)
				within
					Trans
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							wait_input::enter,
							wait_ar::enter,
							wait_al::enter,
							update_value::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0,acc_l__.NID_wait_input.in,acc_r__.NID_wait_input.in,acc_r__.NID_wait_ar.in,acc_l__.NID_wait_al.in,internal__.NID_update_value|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::D__(id__,
								   		    const_AngularSpeedSM_t,
								   		    const_AngularSpeedSM_acc_distance)
								   [| { share__, terminate } |] (
								   wait_input::D__(id__,
								   		    const_AngularSpeedSM_t,
								   		    const_AngularSpeedSM_acc_distance)
								   [| { share__, terminate } |] (
								   wait_ar::D__(id__,
								   		    const_AngularSpeedSM_t,
								   		    const_AngularSpeedSM_acc_distance)
								   [| { share__, terminate } |] (
								   wait_al::D__(id__,
								   		    const_AngularSpeedSM_t,
								   		    const_AngularSpeedSM_acc_distance)
								   [| { share__, terminate } |] (
								   update_value::D__(id__,
								   		    const_AngularSpeedSM_t,
								   		    const_AngularSpeedSM_acc_distance)
								   )
								   )
								   )
								   )
								 )
								 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,acc_l__.NID_wait_input.in,acc_r__.NID_wait_input.in|}]]
								 [[wait_ar::interrupt <- x__ | x__ <- {|interrupt,acc_r__.NID_wait_ar.in|}]]
								 [[wait_al::interrupt <- x__ | x__ <- {|interrupt,acc_l__.NID_wait_al.in|}]]
								 [[update_value::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_update_value|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_al,setR_ar |} ]] 
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setR_al
								 			 			,setR_ar
								 			|}) |]
								 ((i0::enter -> Transitions(id__,
								 		    const_AngularSpeedSM_t,
								 		    const_AngularSpeedSM_acc_distance))
								  [[ share__ <- x__ | x__ <- {| share__ |} ]]
								  [[set_al <- setR_al,set_ar <- setR_ar]]
								 )
								)
								 [[setR_al <- set_al,setR_ar <- set_ar]]
								)
							)
							 \ hideSet)
							[[
								acc_l__.x____ <- acc_l,
								acc_r__.x____ <- acc_r,
								angle__.x____ <- angle
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance) = 
					dbisim((MachineBody(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance)\ enteredSS)
					)
				
				IteratedBehaviour(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance) = 
					dbisim((MachineBody(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance)\ enteredSS)
					)
				
				Stateful(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance) = 
					((
						(Behaviour(id__,
								    const_AngularSpeedSM_t,
								    const_AngularSpeedSM_acc_distance) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
								    const_AngularSpeedSM_t,
								    const_AngularSpeedSM_acc_distance))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															Behaviour(id__,
																	    const_AngularSpeedSM_t,
																	    const_AngularSpeedSM_acc_distance)
															[| {|get_ar,set_ar,terminate|} |]
															Memory_ar((0,0,0))
														)\{|get_ar,set_ar|}
													)
													[| {|get_al,set_al,terminate|} |]
													Memory_al((0,0,0))
												)\{|get_al,set_al|}
											)
											[| {|get_direction,set_direction,terminate|} |]
											Memory_direction(Direction_left)
										)\{|get_direction,set_direction|}
									)
									[| {|get_turn_angle,set_turn_angle,terminate|} |]
									Memory_turn_angle(0)
								)\{|get_turn_angle,set_turn_angle|}
							)
							[| {|get_speed,set_speed,terminate|} |]
							Memory_speed(0)
						)\{|get_speed,set_speed|}
					)
					)
				
				-- Visible counterparts
				MachineBody_VS_O(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							wait_input::enter,
							wait_ar::enter,
							wait_al::enter,
							update_value::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0,acc_l__.NID_wait_input.in,acc_r__.NID_wait_input.in,acc_r__.NID_wait_ar.in,acc_l__.NID_wait_al.in,internal__.NID_update_value|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::VS_O__(id__,
								   		    const_AngularSpeedSM_t,
								   		    const_AngularSpeedSM_acc_distance)
								   [| { share__, terminate } |] (
								   wait_input::VS_O__(id__,
								   		    const_AngularSpeedSM_t,
								   		    const_AngularSpeedSM_acc_distance)
								   [| { share__, terminate } |] (
								   wait_ar::VS_O__(id__,
								   		    const_AngularSpeedSM_t,
								   		    const_AngularSpeedSM_acc_distance)
								   [| { share__, terminate } |] (
								   wait_al::VS_O__(id__,
								   		    const_AngularSpeedSM_t,
								   		    const_AngularSpeedSM_acc_distance)
								   [| { share__, terminate } |] (
								   update_value::VS_O__(id__,
								   		    const_AngularSpeedSM_t,
								   		    const_AngularSpeedSM_acc_distance)
								   )
								   )
								   )
								   )
								 )
								 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,acc_l__.NID_wait_input.in,acc_r__.NID_wait_input.in|}]]
								 [[wait_ar::interrupt <- x__ | x__ <- {|interrupt,acc_r__.NID_wait_ar.in|}]]
								 [[wait_al::interrupt <- x__ | x__ <- {|interrupt,acc_l__.NID_wait_al.in|}]]
								 [[update_value::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_update_value|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_al,setR_ar |} ]] 
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setR_al
								 			 			,setR_ar
								 			|}) |]
								 ((i0::enter -> Transitions(id__,
								 		    const_AngularSpeedSM_t,
								 		    const_AngularSpeedSM_acc_distance))
								  [[ share__ <- x__ | x__ <- {| share__ |} ]]
								  [[set_al <- setR_al,set_ar <- setR_ar]]
								 )
								)
								 [[setR_al <- set_al,setR_ar <- set_ar]]
								)
							)
							 \ hideSet)
							[[
								acc_l__.x____ <- acc_l,
								acc_r__.x____ <- acc_r,
								angle__.x____ <- angle
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance) = 
					dbisim((MachineBody_VS_O(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance))
					)
				
				IteratedBehaviour_VS_O(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance) = 
					dbisim((MachineBody_VS_O(id__,
							    const_AngularSpeedSM_t,
							    const_AngularSpeedSM_acc_distance))
					)
				
				Stateful_VS_O(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance) = 
					dbisim((
						(Behaviour_VS_O(id__,
								    const_AngularSpeedSM_t,
								    const_AngularSpeedSM_acc_distance) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
								    const_AngularSpeedSM_t,
								    const_AngularSpeedSM_acc_distance))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful_VS_O(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															Behaviour_VS_O(id__,
																	    const_AngularSpeedSM_t,
																	    const_AngularSpeedSM_acc_distance)
															[| {|get_ar,set_ar,terminate|} |]
															Memory_ar((0,0,0))
														)\{|get_ar,set_ar|}
													)
													[| {|get_al,set_al,terminate|} |]
													Memory_al((0,0,0))
												)\{|get_al,set_al|}
											)
											[| {|get_direction,set_direction,terminate|} |]
											Memory_direction(Direction_left)
										)\{|get_direction,set_direction|}
									)
									[| {|get_turn_angle,set_turn_angle,terminate|} |]
									Memory_turn_angle(0)
								)\{|get_turn_angle,set_turn_angle|}
							)
							[| {|get_speed,set_speed,terminate|} |]
							Memory_speed(0)
						)\{|get_speed,set_speed|}
					)
					)
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_speed(speed) =
					get_speed!speed -> Memory_speed(speed)
					[]
					set_speed?x__ -> Memory_speed(x__)
					[]
					terminate -> SKIP
				Memory_turn_angle(turn_angle) =
					get_turn_angle!turn_angle -> Memory_turn_angle(turn_angle)
					[]
					set_turn_angle?x__ -> Memory_turn_angle(x__)
					[]
					terminate -> SKIP
				Memory_direction(direction) =
					get_direction!direction -> Memory_direction(direction)
					[]
					set_direction?x__ -> Memory_direction(x__)
					[]
					terminate -> SKIP
				Memory_al(al) =
					get_al!al -> Memory_al(al)
					[]
					set_al?x__ -> Memory_al(x__)
					[]
					terminate -> SKIP
				Memory_ar(ar) =
					get_ar!ar -> Memory_ar(ar)
					[]
					set_ar?x__ -> Memory_ar(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance) = Memory_speed(0)
				[| { terminate } |] (
				Memory_turn_angle(0)
				[| { terminate } |] (
				Memory_direction(Direction_left)
				[| { terminate } |] (
				Memory_al((0,0,0))
				[| { terminate } |] (
				Memory_ar((0,0,0))
				)
				)
				)
				)
				
				getsetLocalChannels = {|get_speed,set_speed,get_turn_angle,set_turn_angle,get_direction,set_direction,get_al,set_al,get_ar,set_ar|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance) = STM_VS_O(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance)
				
				D__(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance) = STM(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance) \ internal_events
				O__(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance) = sbisim(diamond(D__(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance)))
				VS__(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance) = FVS__(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance)
				VS_O__(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance) = sbisim(diamond(FVS__(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance)))
				HEXT__(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance) = O__(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance) [|shared_variable_events|] SKIP
				HUP__(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance) = O__(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance) [|{share__}|] SKIP
				
				-- Shared memory
				-- Shared memory variables
				
				-- sharedVarMemory process
				sharedVarMemory(id__,
						    const_AngularSpeedSM_t,
						    const_AngularSpeedSM_acc_distance) = terminate -> SKIP
				
				sharedVarSync = {||}
				
				sharedVarHide = {||}
			endmodule
			module stm_ref6
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_Update|
				              NID_Wait_target|
				              NID_Wait_actual|
				              NID_Reset
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_prior_error, set_prior_error, setL_prior_error, setR_prior_error: core_int
				channel get_integral, set_integral, setL_integral, setR_integral: core_int
				channel get_error, set_error, setL_error, setR_error: core_int
				channel get_derivative, set_derivative, setL_derivative, setR_derivative: core_int
				channel get_output, set_output, setL_output, setR_output: core_int
				channel get_target_value, set_target_value, setL_target_value, setR_target_value: core_int
				channel get_actual_value, set_actual_value, setL_actual_value, setR_actual_value: core_int
				channel get_old_target, set_old_target, setL_old_target, setR_old_target: core_int
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel err_output__: NIDS.InOut.core_int
				channel err_output: InOut.core_int
				channel actual__: NIDS.InOut.core_int
				channel actual: InOut.core_int
				channel target__: NIDS.InOut.core_int
				channel target: InOut.core_int
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				Update::enter,
				Wait_target::enter,
				Wait_actual::enter,
				Reset::enter
				|}
				
				enteredSS = 	{|
				Update::entered,
				Wait_target::entered,
				Wait_actual::entered,
				Reset::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	err_output,
					actual,
					target
					|}
			
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, interrupt
					
					D__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
					
					VS_O__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = D__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Update
				module Update
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(share__choice(get_target_value?target_value -> share__choice(get_actual_value?actual_value -> true & (share__choice(set_error!Minus(actual_value, target_value, core_int) -> SKIP)))));share__choice(share__choice(get_integral?integral -> share__choice(get_error?error -> true & (share__choice(set_integral!Plus(integral, (Mult(error, const_PID_step, core_int)), core_int) -> SKIP)))));share__choice(share__choice(get_error?error -> share__choice(get_prior_error?prior_error -> const_PID_step != 0 & (share__choice(set_derivative!floor(Div((Minus(error, prior_error, core_int)), const_PID_step, core_real)) -> SKIP)))));share__choice(share__choice(get_error?error -> share__choice(get_integral?integral -> share__choice(get_derivative?derivative -> true & (share__choice(set_output!Plus(Plus(Mult(const_PID_kp, error, core_int), Mult(const_PID_ki, integral, core_int), core_int), Mult(const_PID_kd, derivative, core_int), core_int) -> SKIP))))));share__choice(share__choice(get_error?error -> true & (share__choice(set_prior_error!error -> SKIP))));share__choice(get_output?output -> true&(share__choice(err_output.out!output -> SKIP)));share__choice(share__choice(get_target_value?target_value -> true & (share__choice(set_old_target!target_value -> SKIP)))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(share__choice(get_target_value?target_value -> share__choice(get_actual_value?actual_value -> true & (share__choice(set_error!Minus(actual_value, target_value, core_int) -> SKIP)))));share__choice(share__choice(get_integral?integral -> share__choice(get_error?error -> true & (share__choice(set_integral!Plus(integral, (Mult(error, const_PID_step, core_int)), core_int) -> SKIP)))));share__choice(share__choice(get_error?error -> share__choice(get_prior_error?prior_error -> const_PID_step != 0 & (share__choice(set_derivative!floor(Div((Minus(error, prior_error, core_int)), const_PID_step, core_real)) -> SKIP)))));share__choice(share__choice(get_error?error -> share__choice(get_integral?integral -> share__choice(get_derivative?derivative -> true & (share__choice(set_output!Plus(Plus(Mult(const_PID_kp, error, core_int), Mult(const_PID_ki, integral, core_int), core_int), Mult(const_PID_kd, derivative, core_int), core_int) -> SKIP))))));share__choice(share__choice(get_error?error -> true & (share__choice(set_prior_error!error -> SKIP))));share__choice(get_output?output -> true&(share__choice(err_output.out!output -> SKIP)));share__choice(share__choice(get_target_value?target_value -> true & (share__choice(set_old_target!target_value -> SKIP)))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Wait_target
				module Wait_target
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Wait_actual
				module Wait_actual
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Reset
				module Reset
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_prior_error!0 -> SKIP)));share__choice(true & (share__choice(set_integral!0 -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_prior_error!0 -> SKIP)));share__choice(true & (share__choice(set_integral!0 -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				-- END of Operation calls --
				
				-- STM processes
				STM(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step))
				)\sharedVarHide
				
				STM_VS_O(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful_VS_O(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step))
				)\sharedVarHide
				
				-- Transitions
				Transitions(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = ((let
					Trans = share__choice(get_target_value?target_value -> get_old_target?old_target -> (
						((share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((share__choice(true & (share__choice(set_prior_error!0 -> SKIP)));share__choice(true & (share__choice(set_integral!0 -> SKIP))) ; Wait_target::enter -> SKIP))))
						 	 [] dbisim((true)&(internal__!NID_Update -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Wait_target::enter -> SKIP)))
						 	 [] dbisim((target__!NID_Wait_target.in?target_value:{target_value|target_value <- core_int, (target_value==old_target)} -> share__choice(set_target_value!target_value -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Wait_actual::enter -> SKIP)))
						 	 [] dbisim((true)&(actual__!NID_Wait_actual.in?actual_value:{actual_value|actual_value <- core_int, true} -> share__choice(set_actual_value!actual_value -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Update::enter -> SKIP)))
						 	 [] dbisim((target__!NID_Wait_target.in?target_value:{target_value|target_value <- core_int, (target_value!=old_target)} -> share__choice(set_target_value!target_value -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Reset::enter -> SKIP)))
						 	 [] dbisim((true)&(actual__!NID_Reset.in?actual_value:{actual_value|actual_value <- core_int, true} -> share__choice(set_actual_value!actual_value -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Update::enter -> SKIP)))
						 ) ; Trans)
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
					)
					)
				within
					Trans
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							Update::enter,
							Wait_target::enter,
							Wait_actual::enter,
							Reset::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0,internal__.NID_Update,target__.NID_Wait_target.in,actual__.NID_Wait_actual.in,target__.NID_Wait_target.in,actual__.NID_Reset.in|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::D__(id__,
								   		    const_PID_kp,
								   		    const_PID_ki,
								   		    const_PID_kd,
								   		    const_PID_step)
								   [| { share__, terminate } |] (
								   Update::D__(id__,
								   		    const_PID_kp,
								   		    const_PID_ki,
								   		    const_PID_kd,
								   		    const_PID_step)
								   [| { share__, terminate } |] (
								   Wait_target::D__(id__,
								   		    const_PID_kp,
								   		    const_PID_ki,
								   		    const_PID_kd,
								   		    const_PID_step)
								   [| { share__, terminate } |] (
								   Wait_actual::D__(id__,
								   		    const_PID_kp,
								   		    const_PID_ki,
								   		    const_PID_kd,
								   		    const_PID_step)
								   [| { share__, terminate } |] (
								   Reset::D__(id__,
								   		    const_PID_kp,
								   		    const_PID_ki,
								   		    const_PID_kd,
								   		    const_PID_step)
								   )
								   )
								   )
								   )
								 )
								 [[Update::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Update|}]]
								 [[Wait_target::interrupt <- x__ | x__ <- {|interrupt,target__.NID_Wait_target.in,target__.NID_Wait_target.in|}]]
								 [[Wait_actual::interrupt <- x__ | x__ <- {|interrupt,actual__.NID_Wait_actual.in|}]]
								 [[Reset::interrupt <- x__ | x__ <- {|interrupt,actual__.NID_Reset.in|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_target_value,setR_actual_value |} ]] 
								  [[set_target_value <- setL_target_value,set_old_target <- setL_old_target]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_target_value
								 			,setL_old_target
								 			,setR_target_value
								 			 			,setR_actual_value
								 			|}) |]
								 ((i0::enter -> Transitions(id__,
								 		    const_PID_kp,
								 		    const_PID_ki,
								 		    const_PID_kd,
								 		    const_PID_step))
								  [[ share__ <- x__ | x__ <- {| share__,setL_target_value,setL_old_target |} ]]
								  [[set_target_value <- setR_target_value,set_actual_value <- setR_actual_value]]
								 )
								)[[setL_target_value <- set_target_value,setL_old_target <- set_old_target]]
								 [[setR_target_value <- set_target_value,setR_actual_value <- set_actual_value]]
								)
							)
							 \ hideSet)
							[[
								err_output__.x____ <- err_output,
								actual__.x____ <- actual,
								target__.x____ <- target
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = 
					dbisim((MachineBody(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step)\ enteredSS)
					)
				
				IteratedBehaviour(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = 
					dbisim((MachineBody(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step)\ enteredSS)
					)
				
				Stateful(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = 
					((
						(Behaviour(id__,
								    const_PID_kp,
								    const_PID_ki,
								    const_PID_kd,
								    const_PID_step) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
								    const_PID_kp,
								    const_PID_ki,
								    const_PID_kd,
								    const_PID_step))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															dbisim(
																sbisim(
																	dbisim(
																		sbisim(
																			dbisim(
																				sbisim(
																					Behaviour(id__,
																							    const_PID_kp,
																							    const_PID_ki,
																							    const_PID_kd,
																							    const_PID_step)
																					[| {|get_old_target,set_old_target,terminate|} |]
																					Memory_old_target(0)
																				)\{|get_old_target,set_old_target|}
																			)
																			[| {|get_actual_value,set_actual_value,terminate|} |]
																			Memory_actual_value(0)
																		)\{|get_actual_value,set_actual_value|}
																	)
																	[| {|get_target_value,set_target_value,terminate|} |]
																	Memory_target_value(0)
																)\{|get_target_value,set_target_value|}
															)
															[| {|get_output,set_output,terminate|} |]
															Memory_output(0)
														)\{|get_output,set_output|}
													)
													[| {|get_derivative,set_derivative,terminate|} |]
													Memory_derivative(0)
												)\{|get_derivative,set_derivative|}
											)
											[| {|get_error,set_error,terminate|} |]
											Memory_error(0)
										)\{|get_error,set_error|}
									)
									[| {|get_integral,set_integral,terminate|} |]
									Memory_integral(0)
								)\{|get_integral,set_integral|}
							)
							[| {|get_prior_error,set_prior_error,terminate|} |]
							Memory_prior_error(0)
						)\{|get_prior_error,set_prior_error|}
					)
					)
				
				-- Visible counterparts
				MachineBody_VS_O(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							Update::enter,
							Wait_target::enter,
							Wait_actual::enter,
							Reset::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0,internal__.NID_Update,target__.NID_Wait_target.in,actual__.NID_Wait_actual.in,target__.NID_Wait_target.in,actual__.NID_Reset.in|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::VS_O__(id__,
								   		    const_PID_kp,
								   		    const_PID_ki,
								   		    const_PID_kd,
								   		    const_PID_step)
								   [| { share__, terminate } |] (
								   Update::VS_O__(id__,
								   		    const_PID_kp,
								   		    const_PID_ki,
								   		    const_PID_kd,
								   		    const_PID_step)
								   [| { share__, terminate } |] (
								   Wait_target::VS_O__(id__,
								   		    const_PID_kp,
								   		    const_PID_ki,
								   		    const_PID_kd,
								   		    const_PID_step)
								   [| { share__, terminate } |] (
								   Wait_actual::VS_O__(id__,
								   		    const_PID_kp,
								   		    const_PID_ki,
								   		    const_PID_kd,
								   		    const_PID_step)
								   [| { share__, terminate } |] (
								   Reset::VS_O__(id__,
								   		    const_PID_kp,
								   		    const_PID_ki,
								   		    const_PID_kd,
								   		    const_PID_step)
								   )
								   )
								   )
								   )
								 )
								 [[Update::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Update|}]]
								 [[Wait_target::interrupt <- x__ | x__ <- {|interrupt,target__.NID_Wait_target.in,target__.NID_Wait_target.in|}]]
								 [[Wait_actual::interrupt <- x__ | x__ <- {|interrupt,actual__.NID_Wait_actual.in|}]]
								 [[Reset::interrupt <- x__ | x__ <- {|interrupt,actual__.NID_Reset.in|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_target_value,setR_actual_value |} ]] 
								  [[set_target_value <- setL_target_value,set_old_target <- setL_old_target]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_target_value
								 			,setL_old_target
								 			,setR_target_value
								 			 			,setR_actual_value
								 			|}) |]
								 ((i0::enter -> Transitions(id__,
								 		    const_PID_kp,
								 		    const_PID_ki,
								 		    const_PID_kd,
								 		    const_PID_step))
								  [[ share__ <- x__ | x__ <- {| share__,setL_target_value,setL_old_target |} ]]
								  [[set_target_value <- setR_target_value,set_actual_value <- setR_actual_value]]
								 )
								)[[setL_target_value <- set_target_value,setL_old_target <- set_old_target]]
								 [[setR_target_value <- set_target_value,setR_actual_value <- set_actual_value]]
								)
							)
							 \ hideSet)
							[[
								err_output__.x____ <- err_output,
								actual__.x____ <- actual,
								target__.x____ <- target
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = 
					dbisim((MachineBody_VS_O(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step))
					)
				
				IteratedBehaviour_VS_O(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = 
					dbisim((MachineBody_VS_O(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step))
					)
				
				Stateful_VS_O(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = 
					dbisim((
						(Behaviour_VS_O(id__,
								    const_PID_kp,
								    const_PID_ki,
								    const_PID_kd,
								    const_PID_step) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
								    const_PID_kp,
								    const_PID_ki,
								    const_PID_kd,
								    const_PID_step))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful_VS_O(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															dbisim(
																sbisim(
																	dbisim(
																		sbisim(
																			dbisim(
																				sbisim(
																					Behaviour_VS_O(id__,
																							    const_PID_kp,
																							    const_PID_ki,
																							    const_PID_kd,
																							    const_PID_step)
																					[| {|get_old_target,set_old_target,terminate|} |]
																					Memory_old_target(0)
																				)\{|get_old_target,set_old_target|}
																			)
																			[| {|get_actual_value,set_actual_value,terminate|} |]
																			Memory_actual_value(0)
																		)\{|get_actual_value,set_actual_value|}
																	)
																	[| {|get_target_value,set_target_value,terminate|} |]
																	Memory_target_value(0)
																)\{|get_target_value,set_target_value|}
															)
															[| {|get_output,set_output,terminate|} |]
															Memory_output(0)
														)\{|get_output,set_output|}
													)
													[| {|get_derivative,set_derivative,terminate|} |]
													Memory_derivative(0)
												)\{|get_derivative,set_derivative|}
											)
											[| {|get_error,set_error,terminate|} |]
											Memory_error(0)
										)\{|get_error,set_error|}
									)
									[| {|get_integral,set_integral,terminate|} |]
									Memory_integral(0)
								)\{|get_integral,set_integral|}
							)
							[| {|get_prior_error,set_prior_error,terminate|} |]
							Memory_prior_error(0)
						)\{|get_prior_error,set_prior_error|}
					)
					)
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_prior_error(prior_error) =
					get_prior_error!prior_error -> Memory_prior_error(prior_error)
					[]
					set_prior_error?x__ -> Memory_prior_error(x__)
					[]
					terminate -> SKIP
				Memory_integral(integral) =
					get_integral!integral -> Memory_integral(integral)
					[]
					set_integral?x__ -> Memory_integral(x__)
					[]
					terminate -> SKIP
				Memory_error(error) =
					get_error!error -> Memory_error(error)
					[]
					set_error?x__ -> Memory_error(x__)
					[]
					terminate -> SKIP
				Memory_derivative(derivative) =
					get_derivative!derivative -> Memory_derivative(derivative)
					[]
					set_derivative?x__ -> Memory_derivative(x__)
					[]
					terminate -> SKIP
				Memory_output(output) =
					get_output!output -> Memory_output(output)
					[]
					set_output?x__ -> Memory_output(x__)
					[]
					terminate -> SKIP
				Memory_target_value(target_value) =
					get_target_value!target_value -> Memory_target_value(target_value)
					[]
					set_target_value?x__ -> Memory_target_value(x__)
					[]
					terminate -> SKIP
				Memory_actual_value(actual_value) =
					get_actual_value!actual_value -> Memory_actual_value(actual_value)
					[]
					set_actual_value?x__ -> Memory_actual_value(x__)
					[]
					terminate -> SKIP
				Memory_old_target(old_target) =
					get_old_target!old_target -> Memory_old_target(old_target)
					[]
					set_old_target?x__ -> Memory_old_target(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = Memory_prior_error(0)
				[| { terminate } |] (
				Memory_integral(0)
				[| { terminate } |] (
				Memory_error(0)
				[| { terminate } |] (
				Memory_derivative(0)
				[| { terminate } |] (
				Memory_output(0)
				[| { terminate } |] (
				Memory_target_value(0)
				[| { terminate } |] (
				Memory_actual_value(0)
				[| { terminate } |] (
				Memory_old_target(0)
				)
				)
				)
				)
				)
				)
				)
				
				getsetLocalChannels = {|get_prior_error,set_prior_error,get_integral,set_integral,get_error,set_error,get_derivative,set_derivative,get_output,set_output,get_target_value,set_target_value,get_actual_value,set_actual_value,get_old_target,set_old_target|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = STM_VS_O(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step)
				
				D__(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = STM(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) \ internal_events
				O__(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = sbisim(diamond(D__(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step)))
				VS__(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = FVS__(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step)
				VS_O__(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = sbisim(diamond(FVS__(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step)))
				HEXT__(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = O__(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) [|shared_variable_events|] SKIP
				HUP__(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = O__(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) [|{share__}|] SKIP
				
				-- Shared memory
				-- Shared memory variables
				
				-- sharedVarMemory process
				sharedVarMemory(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = terminate -> SKIP
				
				sharedVarSync = {||}
				
				sharedVarHide = {||}
			endmodule
			module stm_ref7
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_Update|
				              NID_Wait_target|
				              NID_Wait_actual|
				              NID_Reset
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_prior_error, set_prior_error, setL_prior_error, setR_prior_error: core_int
				channel get_integral, set_integral, setL_integral, setR_integral: core_int
				channel get_error, set_error, setL_error, setR_error: core_int
				channel get_derivative, set_derivative, setL_derivative, setR_derivative: core_int
				channel get_output, set_output, setL_output, setR_output: core_int
				channel get_target_value, set_target_value, setL_target_value, setR_target_value: core_int
				channel get_actual_value, set_actual_value, setL_actual_value, setR_actual_value: core_int
				channel get_old_target, set_old_target, setL_old_target, setR_old_target: core_int
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel err_output__: NIDS.InOut.core_int
				channel err_output: InOut.core_int
				channel actual__: NIDS.InOut.core_int
				channel actual: InOut.core_int
				channel target__: NIDS.InOut.core_int
				channel target: InOut.core_int
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				Update::enter,
				Wait_target::enter,
				Wait_actual::enter,
				Reset::enter
				|}
				
				enteredSS = 	{|
				Update::entered,
				Wait_target::entered,
				Wait_actual::entered,
				Reset::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	err_output,
					actual,
					target
					|}
			
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, interrupt
					
					D__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
					
					VS_O__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = D__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Update
				module Update
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(share__choice(get_target_value?target_value -> share__choice(get_actual_value?actual_value -> true & (share__choice(set_error!Minus(actual_value, target_value, core_int) -> SKIP)))));share__choice(share__choice(get_integral?integral -> share__choice(get_error?error -> true & (share__choice(set_integral!Plus(integral, (Mult(error, const_PID_step, core_int)), core_int) -> SKIP)))));share__choice(share__choice(get_error?error -> share__choice(get_prior_error?prior_error -> const_PID_step != 0 & (share__choice(set_derivative!floor(Div((Minus(error, prior_error, core_int)), const_PID_step, core_real)) -> SKIP)))));share__choice(share__choice(get_error?error -> share__choice(get_integral?integral -> share__choice(get_derivative?derivative -> true & (share__choice(set_output!Plus(Plus(Mult(const_PID_kp, error, core_int), Mult(const_PID_ki, integral, core_int), core_int), Mult(const_PID_kd, derivative, core_int), core_int) -> SKIP))))));share__choice(share__choice(get_error?error -> true & (share__choice(set_prior_error!error -> SKIP))));share__choice(get_output?output -> true&(share__choice(err_output.out!output -> SKIP)));share__choice(share__choice(get_target_value?target_value -> true & (share__choice(set_old_target!target_value -> SKIP)))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(share__choice(get_target_value?target_value -> share__choice(get_actual_value?actual_value -> true & (share__choice(set_error!Minus(actual_value, target_value, core_int) -> SKIP)))));share__choice(share__choice(get_integral?integral -> share__choice(get_error?error -> true & (share__choice(set_integral!Plus(integral, (Mult(error, const_PID_step, core_int)), core_int) -> SKIP)))));share__choice(share__choice(get_error?error -> share__choice(get_prior_error?prior_error -> const_PID_step != 0 & (share__choice(set_derivative!floor(Div((Minus(error, prior_error, core_int)), const_PID_step, core_real)) -> SKIP)))));share__choice(share__choice(get_error?error -> share__choice(get_integral?integral -> share__choice(get_derivative?derivative -> true & (share__choice(set_output!Plus(Plus(Mult(const_PID_kp, error, core_int), Mult(const_PID_ki, integral, core_int), core_int), Mult(const_PID_kd, derivative, core_int), core_int) -> SKIP))))));share__choice(share__choice(get_error?error -> true & (share__choice(set_prior_error!error -> SKIP))));share__choice(get_output?output -> true&(share__choice(err_output.out!output -> SKIP)));share__choice(share__choice(get_target_value?target_value -> true & (share__choice(set_old_target!target_value -> SKIP)))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Wait_target
				module Wait_target
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Wait_actual
				module Wait_actual
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Reset
				module Reset
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_prior_error!0 -> SKIP)));share__choice(true & (share__choice(set_integral!0 -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_prior_error!0 -> SKIP)));share__choice(true & (share__choice(set_integral!0 -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				-- END of Operation calls --
				
				-- STM processes
				STM(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step))
				)\sharedVarHide
				
				STM_VS_O(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful_VS_O(id__,
									    const_PID_kp,
									    const_PID_ki,
									    const_PID_kd,
									    const_PID_step) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step))
				)\sharedVarHide
				
				-- Transitions
				Transitions(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = ((let
					Trans = share__choice(get_target_value?target_value -> get_old_target?old_target -> (
						((share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((share__choice(true & (share__choice(set_prior_error!0 -> SKIP)));share__choice(true & (share__choice(set_integral!0 -> SKIP))) ; Wait_target::enter -> SKIP))))
						 	 [] dbisim((true)&(internal__!NID_Update -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Wait_target::enter -> SKIP)))
						 	 [] dbisim((target__!NID_Wait_target.in?target_value:{target_value|target_value <- core_int, (target_value==old_target)} -> share__choice(set_target_value!target_value -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Wait_actual::enter -> SKIP)))
						 	 [] dbisim((true)&(actual__!NID_Wait_actual.in?actual_value:{actual_value|actual_value <- core_int, true} -> share__choice(set_actual_value!actual_value -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Update::enter -> SKIP)))
						 	 [] dbisim((target__!NID_Wait_target.in?target_value:{target_value|target_value <- core_int, (target_value!=old_target)} -> share__choice(set_target_value!target_value -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Reset::enter -> SKIP)))
						 	 [] dbisim((true)&(actual__!NID_Reset.in?actual_value:{actual_value|actual_value <- core_int, true} -> share__choice(set_actual_value!actual_value -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Update::enter -> SKIP)))
						 ) ; Trans)
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
					)
					)
				within
					Trans
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							Update::enter,
							Wait_target::enter,
							Wait_actual::enter,
							Reset::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0,internal__.NID_Update,target__.NID_Wait_target.in,actual__.NID_Wait_actual.in,target__.NID_Wait_target.in,actual__.NID_Reset.in|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::D__(id__,
								   		    const_PID_kp,
								   		    const_PID_ki,
								   		    const_PID_kd,
								   		    const_PID_step)
								   [| { share__, terminate } |] (
								   Update::D__(id__,
								   		    const_PID_kp,
								   		    const_PID_ki,
								   		    const_PID_kd,
								   		    const_PID_step)
								   [| { share__, terminate } |] (
								   Wait_target::D__(id__,
								   		    const_PID_kp,
								   		    const_PID_ki,
								   		    const_PID_kd,
								   		    const_PID_step)
								   [| { share__, terminate } |] (
								   Wait_actual::D__(id__,
								   		    const_PID_kp,
								   		    const_PID_ki,
								   		    const_PID_kd,
								   		    const_PID_step)
								   [| { share__, terminate } |] (
								   Reset::D__(id__,
								   		    const_PID_kp,
								   		    const_PID_ki,
								   		    const_PID_kd,
								   		    const_PID_step)
								   )
								   )
								   )
								   )
								 )
								 [[Update::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Update|}]]
								 [[Wait_target::interrupt <- x__ | x__ <- {|interrupt,target__.NID_Wait_target.in,target__.NID_Wait_target.in|}]]
								 [[Wait_actual::interrupt <- x__ | x__ <- {|interrupt,actual__.NID_Wait_actual.in|}]]
								 [[Reset::interrupt <- x__ | x__ <- {|interrupt,actual__.NID_Reset.in|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_target_value,setR_actual_value |} ]] 
								  [[set_target_value <- setL_target_value,set_old_target <- setL_old_target]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_target_value
								 			,setL_old_target
								 			,setR_target_value
								 			 			,setR_actual_value
								 			|}) |]
								 ((i0::enter -> Transitions(id__,
								 		    const_PID_kp,
								 		    const_PID_ki,
								 		    const_PID_kd,
								 		    const_PID_step))
								  [[ share__ <- x__ | x__ <- {| share__,setL_target_value,setL_old_target |} ]]
								  [[set_target_value <- setR_target_value,set_actual_value <- setR_actual_value]]
								 )
								)[[setL_target_value <- set_target_value,setL_old_target <- set_old_target]]
								 [[setR_target_value <- set_target_value,setR_actual_value <- set_actual_value]]
								)
							)
							 \ hideSet)
							[[
								err_output__.x____ <- err_output,
								actual__.x____ <- actual,
								target__.x____ <- target
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = 
					dbisim((MachineBody(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step)\ enteredSS)
					)
				
				IteratedBehaviour(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = 
					dbisim((MachineBody(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step)\ enteredSS)
					)
				
				Stateful(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = 
					((
						(Behaviour(id__,
								    const_PID_kp,
								    const_PID_ki,
								    const_PID_kd,
								    const_PID_step) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
								    const_PID_kp,
								    const_PID_ki,
								    const_PID_kd,
								    const_PID_step))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															dbisim(
																sbisim(
																	dbisim(
																		sbisim(
																			dbisim(
																				sbisim(
																					Behaviour(id__,
																							    const_PID_kp,
																							    const_PID_ki,
																							    const_PID_kd,
																							    const_PID_step)
																					[| {|get_old_target,set_old_target,terminate|} |]
																					Memory_old_target(0)
																				)\{|get_old_target,set_old_target|}
																			)
																			[| {|get_actual_value,set_actual_value,terminate|} |]
																			Memory_actual_value(0)
																		)\{|get_actual_value,set_actual_value|}
																	)
																	[| {|get_target_value,set_target_value,terminate|} |]
																	Memory_target_value(0)
																)\{|get_target_value,set_target_value|}
															)
															[| {|get_output,set_output,terminate|} |]
															Memory_output(0)
														)\{|get_output,set_output|}
													)
													[| {|get_derivative,set_derivative,terminate|} |]
													Memory_derivative(0)
												)\{|get_derivative,set_derivative|}
											)
											[| {|get_error,set_error,terminate|} |]
											Memory_error(0)
										)\{|get_error,set_error|}
									)
									[| {|get_integral,set_integral,terminate|} |]
									Memory_integral(0)
								)\{|get_integral,set_integral|}
							)
							[| {|get_prior_error,set_prior_error,terminate|} |]
							Memory_prior_error(0)
						)\{|get_prior_error,set_prior_error|}
					)
					)
				
				-- Visible counterparts
				MachineBody_VS_O(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							Update::enter,
							Wait_target::enter,
							Wait_actual::enter,
							Reset::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0,internal__.NID_Update,target__.NID_Wait_target.in,actual__.NID_Wait_actual.in,target__.NID_Wait_target.in,actual__.NID_Reset.in|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::VS_O__(id__,
								   		    const_PID_kp,
								   		    const_PID_ki,
								   		    const_PID_kd,
								   		    const_PID_step)
								   [| { share__, terminate } |] (
								   Update::VS_O__(id__,
								   		    const_PID_kp,
								   		    const_PID_ki,
								   		    const_PID_kd,
								   		    const_PID_step)
								   [| { share__, terminate } |] (
								   Wait_target::VS_O__(id__,
								   		    const_PID_kp,
								   		    const_PID_ki,
								   		    const_PID_kd,
								   		    const_PID_step)
								   [| { share__, terminate } |] (
								   Wait_actual::VS_O__(id__,
								   		    const_PID_kp,
								   		    const_PID_ki,
								   		    const_PID_kd,
								   		    const_PID_step)
								   [| { share__, terminate } |] (
								   Reset::VS_O__(id__,
								   		    const_PID_kp,
								   		    const_PID_ki,
								   		    const_PID_kd,
								   		    const_PID_step)
								   )
								   )
								   )
								   )
								 )
								 [[Update::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Update|}]]
								 [[Wait_target::interrupt <- x__ | x__ <- {|interrupt,target__.NID_Wait_target.in,target__.NID_Wait_target.in|}]]
								 [[Wait_actual::interrupt <- x__ | x__ <- {|interrupt,actual__.NID_Wait_actual.in|}]]
								 [[Reset::interrupt <- x__ | x__ <- {|interrupt,actual__.NID_Reset.in|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_target_value,setR_actual_value |} ]] 
								  [[set_target_value <- setL_target_value,set_old_target <- setL_old_target]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_target_value
								 			,setL_old_target
								 			,setR_target_value
								 			 			,setR_actual_value
								 			|}) |]
								 ((i0::enter -> Transitions(id__,
								 		    const_PID_kp,
								 		    const_PID_ki,
								 		    const_PID_kd,
								 		    const_PID_step))
								  [[ share__ <- x__ | x__ <- {| share__,setL_target_value,setL_old_target |} ]]
								  [[set_target_value <- setR_target_value,set_actual_value <- setR_actual_value]]
								 )
								)[[setL_target_value <- set_target_value,setL_old_target <- set_old_target]]
								 [[setR_target_value <- set_target_value,setR_actual_value <- set_actual_value]]
								)
							)
							 \ hideSet)
							[[
								err_output__.x____ <- err_output,
								actual__.x____ <- actual,
								target__.x____ <- target
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = 
					dbisim((MachineBody_VS_O(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step))
					)
				
				IteratedBehaviour_VS_O(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = 
					dbisim((MachineBody_VS_O(id__,
							    const_PID_kp,
							    const_PID_ki,
							    const_PID_kd,
							    const_PID_step))
					)
				
				Stateful_VS_O(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = 
					dbisim((
						(Behaviour_VS_O(id__,
								    const_PID_kp,
								    const_PID_ki,
								    const_PID_kd,
								    const_PID_step) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
								    const_PID_kp,
								    const_PID_ki,
								    const_PID_kd,
								    const_PID_step))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful_VS_O(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															dbisim(
																sbisim(
																	dbisim(
																		sbisim(
																			dbisim(
																				sbisim(
																					Behaviour_VS_O(id__,
																							    const_PID_kp,
																							    const_PID_ki,
																							    const_PID_kd,
																							    const_PID_step)
																					[| {|get_old_target,set_old_target,terminate|} |]
																					Memory_old_target(0)
																				)\{|get_old_target,set_old_target|}
																			)
																			[| {|get_actual_value,set_actual_value,terminate|} |]
																			Memory_actual_value(0)
																		)\{|get_actual_value,set_actual_value|}
																	)
																	[| {|get_target_value,set_target_value,terminate|} |]
																	Memory_target_value(0)
																)\{|get_target_value,set_target_value|}
															)
															[| {|get_output,set_output,terminate|} |]
															Memory_output(0)
														)\{|get_output,set_output|}
													)
													[| {|get_derivative,set_derivative,terminate|} |]
													Memory_derivative(0)
												)\{|get_derivative,set_derivative|}
											)
											[| {|get_error,set_error,terminate|} |]
											Memory_error(0)
										)\{|get_error,set_error|}
									)
									[| {|get_integral,set_integral,terminate|} |]
									Memory_integral(0)
								)\{|get_integral,set_integral|}
							)
							[| {|get_prior_error,set_prior_error,terminate|} |]
							Memory_prior_error(0)
						)\{|get_prior_error,set_prior_error|}
					)
					)
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_prior_error(prior_error) =
					get_prior_error!prior_error -> Memory_prior_error(prior_error)
					[]
					set_prior_error?x__ -> Memory_prior_error(x__)
					[]
					terminate -> SKIP
				Memory_integral(integral) =
					get_integral!integral -> Memory_integral(integral)
					[]
					set_integral?x__ -> Memory_integral(x__)
					[]
					terminate -> SKIP
				Memory_error(error) =
					get_error!error -> Memory_error(error)
					[]
					set_error?x__ -> Memory_error(x__)
					[]
					terminate -> SKIP
				Memory_derivative(derivative) =
					get_derivative!derivative -> Memory_derivative(derivative)
					[]
					set_derivative?x__ -> Memory_derivative(x__)
					[]
					terminate -> SKIP
				Memory_output(output) =
					get_output!output -> Memory_output(output)
					[]
					set_output?x__ -> Memory_output(x__)
					[]
					terminate -> SKIP
				Memory_target_value(target_value) =
					get_target_value!target_value -> Memory_target_value(target_value)
					[]
					set_target_value?x__ -> Memory_target_value(x__)
					[]
					terminate -> SKIP
				Memory_actual_value(actual_value) =
					get_actual_value!actual_value -> Memory_actual_value(actual_value)
					[]
					set_actual_value?x__ -> Memory_actual_value(x__)
					[]
					terminate -> SKIP
				Memory_old_target(old_target) =
					get_old_target!old_target -> Memory_old_target(old_target)
					[]
					set_old_target?x__ -> Memory_old_target(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = Memory_prior_error(0)
				[| { terminate } |] (
				Memory_integral(0)
				[| { terminate } |] (
				Memory_error(0)
				[| { terminate } |] (
				Memory_derivative(0)
				[| { terminate } |] (
				Memory_output(0)
				[| { terminate } |] (
				Memory_target_value(0)
				[| { terminate } |] (
				Memory_actual_value(0)
				[| { terminate } |] (
				Memory_old_target(0)
				)
				)
				)
				)
				)
				)
				)
				
				getsetLocalChannels = {|get_prior_error,set_prior_error,get_integral,set_integral,get_error,set_error,get_derivative,set_derivative,get_output,set_output,get_target_value,set_target_value,get_actual_value,set_actual_value,get_old_target,set_old_target|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = STM_VS_O(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step)
				
				D__(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = STM(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) \ internal_events
				O__(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = sbisim(diamond(D__(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step)))
				VS__(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = FVS__(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step)
				VS_O__(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = sbisim(diamond(FVS__(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step)))
				HEXT__(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = O__(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) [|shared_variable_events|] SKIP
				HUP__(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = O__(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) [|{share__}|] SKIP
				
				-- Shared memory
				-- Shared memory variables
				
				-- sharedVarMemory process
				sharedVarMemory(id__,
						    const_PID_kp,
						    const_PID_ki,
						    const_PID_kd,
						    const_PID_step) = terminate -> SKIP
				
				sharedVarSync = {||}
				
				sharedVarHide = {||}
			endmodule
			module stm_ref8
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_Go_up|
				              NID_Turn_right|
				              NID_Go_down|
				              NID_Turn_left|
				              NID_Go_side|
				              NID_Stop
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_lspeed, set_lspeed, setL_lspeed, setR_lspeed: core_int
				channel get_rspeed, set_rspeed, setL_rspeed, setR_rspeed: core_int
				channel get_angle, set_angle, setL_angle, setR_angle: core_int
				channel get_speed_adj, set_speed_adj, setL_speed_adj, setR_speed_adj: core_int
				channel get_angle_adj, set_angle_adj, setL_angle_adj, setR_angle_adj: core_int
				channel get_direction, set_direction, setL_direction, setR_direction: Direction
				channel get_orientation, set_orientation, setL_orientation, setR_orientation: Orientation
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel target_speed__: NIDS.InOut.core_int
				channel target_speed: InOut.core_int
				channel target_angle__: NIDS.InOut.core_int
				channel target_angle: InOut.core_int
				channel speed_adjustment__: NIDS.InOut.core_int
				channel speed_adjustment: InOut.core_int
				channel angle_adjustment__: NIDS.InOut.core_int
				channel angle_adjustment: InOut.core_int
				channel move_forward__: NIDS.InOut
				channel move_forward: InOut
				channel turn__: NIDS.InOut.Direction
				channel turn: InOut.Direction
				channel stop__: NIDS.InOut
				channel stop: InOut
				
				-- Declaring call and ret events for undefined operations
				channel output_left_motorCall: core_int
				channel output_right_motorCall: core_int
				
				enterSS = {|
				i0::enter,
				Go_up::enter,
				Turn_right::enter,
				Go_down::enter,
				Turn_left::enter,
				Go_side::enter,
				Stop::enter
				|}
				
				enteredSS = 	{|
				Go_up::entered,
				Turn_right::entered,
				Go_down::entered,
				Turn_left::entered,
				Go_side::entered,
				Stop::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	target_speed,
					target_angle,
					speed_adjustment,
					angle_adjustment,
					move_forward,
					turn,
					stop
				,	output_left_motorCall,
					output_right_motorCall
					|}
			
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, interrupt
					
					D__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
					
					VS_O__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = D__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Go_up
				module Go_up
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(target_speed.out!const_MidLevelSM_climb_speed -> SKIP));true&(share__choice(speed_adjustment.in?speed_adj -> (SStop /\ set_speed_adj!speed_adj -> SKIP)));true&(share__choice(target_angle.out!const_MidLevelSM_forward_angle -> SKIP));true&(share__choice(angle_adjustment.in?angle_adj -> (SStop /\ set_angle_adj!angle_adj -> SKIP)));share__choice(share__choice(get_speed_adj?speed_adj -> share__choice(get_angle_adj?angle_adj -> share__choice(get_lspeed?lspeed -> true & (share__choice(set_lspeed!Minus(Minus(lspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(share__choice(get_speed_adj?speed_adj -> share__choice(get_rspeed?rspeed -> share__choice(get_angle_adj?angle_adj -> true & (share__choice(set_rspeed!Plus(Minus(rspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(get_lspeed?lspeed -> true&CALL__output_left_motor(
									id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp,
									lspeed
								));share__choice(get_rspeed?rspeed -> true&CALL__output_right_motor(
									id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp,
									rspeed
								)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(target_speed.out!const_MidLevelSM_climb_speed -> SKIP));true&(share__choice(speed_adjustment.in?speed_adj -> (SStop /\ set_speed_adj!speed_adj -> SKIP)));true&(share__choice(target_angle.out!const_MidLevelSM_forward_angle -> SKIP));true&(share__choice(angle_adjustment.in?angle_adj -> (SStop /\ set_angle_adj!angle_adj -> SKIP)));share__choice(share__choice(get_speed_adj?speed_adj -> share__choice(get_angle_adj?angle_adj -> share__choice(get_lspeed?lspeed -> true & (share__choice(set_lspeed!Minus(Minus(lspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(share__choice(get_speed_adj?speed_adj -> share__choice(get_rspeed?rspeed -> share__choice(get_angle_adj?angle_adj -> true & (share__choice(set_rspeed!Plus(Minus(rspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(get_lspeed?lspeed -> true&CALL__output_left_motor(
									id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp,
									lspeed
								));share__choice(get_rspeed?rspeed -> true&CALL__output_right_motor(
									id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp,
									rspeed
								)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Turn_right
				module Turn_right
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(target_speed.out!const_MidLevelSM_turn_speed -> SKIP));true&(share__choice(speed_adjustment.in?speed_adj -> (SStop /\ set_speed_adj!speed_adj -> SKIP)));true&(share__choice(target_angle.out!const_MidLevelSM_right_angle -> SKIP));true&(share__choice(angle_adjustment.in?angle_adj -> (SStop /\ set_angle_adj!angle_adj -> SKIP)));share__choice(share__choice(get_speed_adj?speed_adj -> share__choice(get_angle_adj?angle_adj -> share__choice(get_lspeed?lspeed -> true & (share__choice(set_lspeed!Minus(Minus(lspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(share__choice(get_speed_adj?speed_adj -> share__choice(get_rspeed?rspeed -> share__choice(get_angle_adj?angle_adj -> true & (share__choice(set_rspeed!Plus(Minus(rspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(get_lspeed?lspeed -> true&CALL__output_left_motor(
									id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp,
									lspeed
								));share__choice(get_rspeed?rspeed -> true&CALL__output_right_motor(
									id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp,
									rspeed
								)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(target_speed.out!const_MidLevelSM_turn_speed -> SKIP));true&(share__choice(speed_adjustment.in?speed_adj -> (SStop /\ set_speed_adj!speed_adj -> SKIP)));true&(share__choice(target_angle.out!const_MidLevelSM_right_angle -> SKIP));true&(share__choice(angle_adjustment.in?angle_adj -> (SStop /\ set_angle_adj!angle_adj -> SKIP)));share__choice(share__choice(get_speed_adj?speed_adj -> share__choice(get_angle_adj?angle_adj -> share__choice(get_lspeed?lspeed -> true & (share__choice(set_lspeed!Minus(Minus(lspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(share__choice(get_speed_adj?speed_adj -> share__choice(get_rspeed?rspeed -> share__choice(get_angle_adj?angle_adj -> true & (share__choice(set_rspeed!Plus(Minus(rspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(get_lspeed?lspeed -> true&CALL__output_left_motor(
									id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp,
									lspeed
								));share__choice(get_rspeed?rspeed -> true&CALL__output_right_motor(
									id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp,
									rspeed
								)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Go_down
				module Go_down
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(target_speed.out!const_MidLevelSM_descent_speed -> SKIP));true&(share__choice(speed_adjustment.in?speed_adj -> (SStop /\ set_speed_adj!speed_adj -> SKIP)));true&(share__choice(target_angle.out!const_MidLevelSM_forward_angle -> SKIP));true&(share__choice(angle_adjustment.in?angle_adj -> (SStop /\ set_angle_adj!angle_adj -> SKIP)));share__choice(share__choice(get_speed_adj?speed_adj -> share__choice(get_angle_adj?angle_adj -> share__choice(get_lspeed?lspeed -> true & (share__choice(set_lspeed!Minus(Minus(lspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(share__choice(get_speed_adj?speed_adj -> share__choice(get_rspeed?rspeed -> share__choice(get_angle_adj?angle_adj -> true & (share__choice(set_rspeed!Plus(Minus(rspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(get_lspeed?lspeed -> true&CALL__output_left_motor(
									id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp,
									lspeed
								));share__choice(get_rspeed?rspeed -> true&CALL__output_right_motor(
									id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp,
									rspeed
								)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(target_speed.out!const_MidLevelSM_descent_speed -> SKIP));true&(share__choice(speed_adjustment.in?speed_adj -> (SStop /\ set_speed_adj!speed_adj -> SKIP)));true&(share__choice(target_angle.out!const_MidLevelSM_forward_angle -> SKIP));true&(share__choice(angle_adjustment.in?angle_adj -> (SStop /\ set_angle_adj!angle_adj -> SKIP)));share__choice(share__choice(get_speed_adj?speed_adj -> share__choice(get_angle_adj?angle_adj -> share__choice(get_lspeed?lspeed -> true & (share__choice(set_lspeed!Minus(Minus(lspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(share__choice(get_speed_adj?speed_adj -> share__choice(get_rspeed?rspeed -> share__choice(get_angle_adj?angle_adj -> true & (share__choice(set_rspeed!Plus(Minus(rspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(get_lspeed?lspeed -> true&CALL__output_left_motor(
									id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp,
									lspeed
								));share__choice(get_rspeed?rspeed -> true&CALL__output_right_motor(
									id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp,
									rspeed
								)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Turn_left
				module Turn_left
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(target_speed.out!const_MidLevelSM_turn_speed -> SKIP));true&(share__choice(speed_adjustment.in?speed_adj -> (SStop /\ set_speed_adj!speed_adj -> SKIP)));true&(share__choice(target_angle.out!const_MidLevelSM_left_angle -> SKIP));true&(share__choice(angle_adjustment.in?angle_adj -> (SStop /\ set_angle_adj!angle_adj -> SKIP)));share__choice(share__choice(get_speed_adj?speed_adj -> share__choice(get_angle_adj?angle_adj -> share__choice(get_lspeed?lspeed -> true & (share__choice(set_lspeed!Minus(Minus(lspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(share__choice(get_speed_adj?speed_adj -> share__choice(get_rspeed?rspeed -> share__choice(get_angle_adj?angle_adj -> true & (share__choice(set_rspeed!Plus(Minus(rspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(get_lspeed?lspeed -> true&CALL__output_left_motor(
									id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp,
									lspeed
								));share__choice(get_rspeed?rspeed -> true&CALL__output_right_motor(
									id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp,
									rspeed
								)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(target_speed.out!const_MidLevelSM_turn_speed -> SKIP));true&(share__choice(speed_adjustment.in?speed_adj -> (SStop /\ set_speed_adj!speed_adj -> SKIP)));true&(share__choice(target_angle.out!const_MidLevelSM_left_angle -> SKIP));true&(share__choice(angle_adjustment.in?angle_adj -> (SStop /\ set_angle_adj!angle_adj -> SKIP)));share__choice(share__choice(get_speed_adj?speed_adj -> share__choice(get_angle_adj?angle_adj -> share__choice(get_lspeed?lspeed -> true & (share__choice(set_lspeed!Minus(Minus(lspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(share__choice(get_speed_adj?speed_adj -> share__choice(get_rspeed?rspeed -> share__choice(get_angle_adj?angle_adj -> true & (share__choice(set_rspeed!Plus(Minus(rspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(get_lspeed?lspeed -> true&CALL__output_left_motor(
									id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp,
									lspeed
								));share__choice(get_rspeed?rspeed -> true&CALL__output_right_motor(
									id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp,
									rspeed
								)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Go_side
				module Go_side
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(target_speed.out!const_MidLevelSM_side_speed -> SKIP));true&(share__choice(speed_adjustment.in?speed_adj -> (SStop /\ set_speed_adj!speed_adj -> SKIP)));true&(share__choice(target_angle.out!const_MidLevelSM_forward_angle -> SKIP));true&(share__choice(angle_adjustment.in?angle_adj -> (SStop /\ set_angle_adj!angle_adj -> SKIP)));share__choice(share__choice(get_speed_adj?speed_adj -> share__choice(get_angle_adj?angle_adj -> share__choice(get_lspeed?lspeed -> true & (share__choice(set_lspeed!Minus(Minus(lspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(share__choice(get_speed_adj?speed_adj -> share__choice(get_rspeed?rspeed -> share__choice(get_angle_adj?angle_adj -> true & (share__choice(set_rspeed!Plus(Minus(rspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(get_lspeed?lspeed -> true&CALL__output_left_motor(
									id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp,
									lspeed
								));share__choice(get_rspeed?rspeed -> true&CALL__output_right_motor(
									id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp,
									rspeed
								)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(target_speed.out!const_MidLevelSM_side_speed -> SKIP));true&(share__choice(speed_adjustment.in?speed_adj -> (SStop /\ set_speed_adj!speed_adj -> SKIP)));true&(share__choice(target_angle.out!const_MidLevelSM_forward_angle -> SKIP));true&(share__choice(angle_adjustment.in?angle_adj -> (SStop /\ set_angle_adj!angle_adj -> SKIP)));share__choice(share__choice(get_speed_adj?speed_adj -> share__choice(get_angle_adj?angle_adj -> share__choice(get_lspeed?lspeed -> true & (share__choice(set_lspeed!Minus(Minus(lspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(share__choice(get_speed_adj?speed_adj -> share__choice(get_rspeed?rspeed -> share__choice(get_angle_adj?angle_adj -> true & (share__choice(set_rspeed!Plus(Minus(rspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(get_lspeed?lspeed -> true&CALL__output_left_motor(
									id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp,
									lspeed
								));share__choice(get_rspeed?rspeed -> true&CALL__output_right_motor(
									id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp,
									rspeed
								)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Stop
				module Stop
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(target_speed.out!const_MidLevelSM_turn_speed -> SKIP));true&(share__choice(speed_adjustment.in?speed_adj -> (SStop /\ set_speed_adj!speed_adj -> SKIP)));true&(share__choice(target_angle.out!const_MidLevelSM_forward_angle -> SKIP));true&(share__choice(angle_adjustment.in?angle_adj -> (SStop /\ set_angle_adj!angle_adj -> SKIP)));share__choice(share__choice(get_speed_adj?speed_adj -> share__choice(get_angle_adj?angle_adj -> share__choice(get_lspeed?lspeed -> true & (share__choice(set_lspeed!Minus(Minus(lspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(share__choice(get_speed_adj?speed_adj -> share__choice(get_rspeed?rspeed -> share__choice(get_angle_adj?angle_adj -> true & (share__choice(set_rspeed!Plus(Minus(rspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(get_lspeed?lspeed -> true&CALL__output_left_motor(
									id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp,
									lspeed
								));share__choice(get_rspeed?rspeed -> true&CALL__output_right_motor(
									id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp,
									rspeed
								)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= true&(share__choice(target_speed.out!const_MidLevelSM_turn_speed -> SKIP));true&(share__choice(speed_adjustment.in?speed_adj -> (SStop /\ set_speed_adj!speed_adj -> SKIP)));true&(share__choice(target_angle.out!const_MidLevelSM_forward_angle -> SKIP));true&(share__choice(angle_adjustment.in?angle_adj -> (SStop /\ set_angle_adj!angle_adj -> SKIP)));share__choice(share__choice(get_speed_adj?speed_adj -> share__choice(get_angle_adj?angle_adj -> share__choice(get_lspeed?lspeed -> true & (share__choice(set_lspeed!Minus(Minus(lspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(share__choice(get_speed_adj?speed_adj -> share__choice(get_rspeed?rspeed -> share__choice(get_angle_adj?angle_adj -> true & (share__choice(set_rspeed!Plus(Minus(rspeed, speed_adj, core_int), angle_adj, core_int) -> SKIP))))));share__choice(get_lspeed?lspeed -> true&CALL__output_left_motor(
									id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp,
									lspeed
								));share__choice(get_rspeed?rspeed -> true&CALL__output_right_motor(
									id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp,
									rspeed
								)) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				CALL__output_left_motor(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp,
							param_x) 	= output_left_motorCall.param_x -> SKIP
				CALL__output_right_motor(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp,
							param_x) 	= output_right_motorCall.param_x -> SKIP
				
				-- END of Operation calls --
				
				-- STM processes
				STM(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful(id__,
									    const_MidLevelSM_step,
									    const_MidLevelSM_climb_speed,
									    const_MidLevelSM_descent_speed,
									    const_MidLevelSM_side_speed,
									    const_MidLevelSM_forward_angle,
									    const_MidLevelSM_left_angle,
									    const_MidLevelSM_right_angle,
									    const_MidLevelSM_turn_speed,
									    const_MidLevelSM_movesp,
									    const_MidLevelSM_stopsp) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp))
				)\sharedVarHide
				
				STM_VS_O(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful_VS_O(id__,
									    const_MidLevelSM_step,
									    const_MidLevelSM_climb_speed,
									    const_MidLevelSM_descent_speed,
									    const_MidLevelSM_side_speed,
									    const_MidLevelSM_forward_angle,
									    const_MidLevelSM_left_angle,
									    const_MidLevelSM_right_angle,
									    const_MidLevelSM_turn_speed,
									    const_MidLevelSM_movesp,
									    const_MidLevelSM_stopsp) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp))
				)\sharedVarHide
				
				-- Transitions
				Transitions(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp) = ((let
					Trans = share__choice(get_direction?direction -> get_orientation?orientation -> (
						((share__ -> SKIP
						 [] dbisim((turn__!NID_Go_up.in?direction:{direction|direction <- Direction, (direction==Direction_right)} -> share__choice(set_direction!direction -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_orientation?orientation -> true & (share__choice(set_orientation!turn_right(orientation) -> SKIP))));share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_stopsp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_stopsp -> SKIP))) ; Turn_right::enter -> SKIP)))
						 	 [] dbisim((((orientation==Orientation_left) or (orientation==Orientation_right)))&(move_forward__!NID_Turn_right.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_movesp -> SKIP)));share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_movesp -> SKIP))) ; Go_side::enter -> SKIP)))
						 	 [] dbisim((turn__!NID_Go_up.in?direction:{direction|direction <- Direction, (direction==Direction_left)} -> share__choice(set_direction!direction -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_orientation?orientation -> true & (share__choice(set_orientation!turn_left(orientation) -> SKIP))));share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_stopsp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_stopsp -> SKIP))) ; Turn_left::enter -> SKIP)))
						 	 [] dbisim((turn__!NID_Turn_right.in?direction:{direction|direction <- Direction, (direction==Direction_right)} -> share__choice(set_direction!direction -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_orientation?orientation -> true & (share__choice(set_orientation!turn_right(orientation) -> SKIP)))) ; Turn_right::enter -> SKIP)))
						 	 [] dbisim((((orientation==Orientation_left) or (orientation==Orientation_right)))&(move_forward__!NID_Turn_left.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_movesp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_movesp -> SKIP))) ; Go_side::enter -> SKIP)))
						 	 [] dbisim((turn__!NID_Turn_left.in?direction:{direction|direction <- Direction, (direction==Direction_left)} -> share__choice(set_direction!direction -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_orientation?orientation -> true & (share__choice(set_orientation!turn_left(orientation) -> SKIP)))) ; Turn_left::enter -> SKIP)))
						 	 [] dbisim(((orientation==Orientation_up))&(move_forward__!NID_Turn_right.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_movesp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_movesp -> SKIP))) ; Go_up::enter -> SKIP)))
						 	 [] dbisim(((orientation==Orientation_down))&(move_forward__!NID_Turn_right.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_movesp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_movesp -> SKIP))) ; Go_down::enter -> SKIP)))
						 	 [] dbisim(((orientation==Orientation_up))&(move_forward__!NID_Turn_left.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_movesp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_movesp -> SKIP))) ; Go_up::enter -> SKIP)))
						 	 [] dbisim(((orientation==Orientation_down))&(move_forward__!NID_Turn_left.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_movesp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_movesp -> SKIP))) ; Go_down::enter -> SKIP)))
						 	 [] dbisim((turn__!NID_Go_side.in?direction:{direction|direction <- Direction, (direction==Direction_left)} -> share__choice(set_direction!direction -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_orientation?orientation -> true & (share__choice(set_orientation!turn_left(orientation) -> SKIP))));share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_stopsp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_stopsp -> SKIP))) ; Turn_left::enter -> SKIP)))
						 	 [] dbisim((turn__!NID_Go_side.in?direction:{direction|direction <- Direction, (direction==Direction_right)} -> share__choice(set_direction!direction -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_orientation?orientation -> true & (share__choice(set_orientation!turn_right(orientation) -> SKIP))));share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_stopsp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_stopsp -> SKIP))) ; Turn_right::enter -> SKIP)))
						 	 [] dbisim((turn__!NID_Go_down.in?direction:{direction|direction <- Direction, (direction==Direction_left)} -> share__choice(set_direction!direction -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_orientation?orientation -> true & (share__choice(set_orientation!turn_left(orientation) -> SKIP))));share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_stopsp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_stopsp -> SKIP))) ; Turn_left::enter -> SKIP)))
						 	 [] dbisim((turn__!NID_Go_down.in?direction:{direction|direction <- Direction, (direction==Direction_right)} -> share__choice(set_direction!direction -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_orientation?orientation -> true & (share__choice(set_orientation!turn_right(orientation) -> SKIP))));share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_stopsp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_stopsp -> SKIP))) ; Turn_right::enter -> SKIP)))
						 	 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((share__choice(true & (share__choice(set_orientation!Orientation_up -> SKIP)));share__choice(true & (share__choice(set_lspeed!0 -> SKIP)));share__choice(true & (share__choice(set_rspeed!0 -> SKIP))) ; Go_up::enter -> SKIP))))
						 	 [] dbisim((turn__!NID_Turn_right.in?direction:{direction|direction <- Direction, (direction==Direction_left)} -> share__choice(set_direction!direction -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_orientation?orientation -> true & (share__choice(set_orientation!turn_left(orientation) -> SKIP)))) ; Turn_left::enter -> SKIP)))
						 	 [] dbisim((turn__!NID_Turn_left.in?direction:{direction|direction <- Direction, (direction==Direction_right)} -> share__choice(set_direction!direction -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_orientation?orientation -> true & (share__choice(set_orientation!turn_right(orientation) -> SKIP)))) ; Turn_right::enter -> SKIP)))
						 	 [] dbisim((true)&(stop__!NID_Go_up.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_stopsp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_stopsp -> SKIP))) ; Stop::enter -> SKIP)))
						 	 [] dbisim((true)&(stop__!NID_Go_down.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_stopsp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_stopsp -> SKIP))) ; Stop::enter -> SKIP)))
						 	 [] dbisim((true)&(stop__!NID_Go_side.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_lspeed!const_MidLevelSM_stopsp -> SKIP)));share__choice(true & (share__choice(set_rspeed!const_MidLevelSM_stopsp -> SKIP))) ; Stop::enter -> SKIP)))
						 	 [] dbisim((turn__!NID_Stop.in?direction:{direction|direction <- Direction, (direction==Direction_right)} -> share__choice(set_direction!direction -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_orientation?orientation -> true & (share__choice(set_orientation!turn_right(orientation) -> SKIP)))) ; Turn_right::enter -> SKIP)))
						 	 [] dbisim((turn__!NID_Stop.in?direction:{direction|direction <- Direction, (direction==Direction_left)} -> share__choice(set_direction!direction -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_orientation?orientation -> true & (share__choice(set_orientation!turn_left(orientation) -> SKIP)))) ; Turn_left::enter -> SKIP)))
						 	 [] dbisim((true)&(internal__!NID_Turn_right -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Turn_right::enter -> SKIP)))
						 	 [] dbisim((true)&(internal__!NID_Go_side -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Go_side::enter -> SKIP)))
						 	 [] dbisim((true)&(internal__!NID_Go_up -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Go_up::enter -> SKIP)))
						 	 [] dbisim((true)&(internal__!NID_Turn_left -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Turn_left::enter -> SKIP)))
						 	 [] dbisim((true)&(internal__!NID_Stop -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Stop::enter -> SKIP)))
						 	 [] dbisim((true)&(internal__!NID_Go_down -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Go_down::enter -> SKIP)))
						 ) ; Trans)
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
					)
					)
				within
					Trans
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							Go_up::enter,
							Turn_right::enter,
							Go_down::enter,
							Turn_left::enter,
							Go_side::enter,
							Stop::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|turn__.NID_Go_up.in,move_forward__.NID_Turn_right.in,turn__.NID_Go_up.in,turn__.NID_Turn_right.in,move_forward__.NID_Turn_left.in,turn__.NID_Turn_left.in,move_forward__.NID_Turn_right.in,move_forward__.NID_Turn_right.in,move_forward__.NID_Turn_left.in,move_forward__.NID_Turn_left.in,turn__.NID_Go_side.in,turn__.NID_Go_side.in,turn__.NID_Go_down.in,turn__.NID_Go_down.in,internal__.NID_i0,turn__.NID_Turn_right.in,turn__.NID_Turn_left.in,stop__.NID_Go_up.in,stop__.NID_Go_down.in,stop__.NID_Go_side.in,turn__.NID_Stop.in,turn__.NID_Stop.in,internal__.NID_Turn_right,internal__.NID_Go_side,internal__.NID_Go_up,internal__.NID_Turn_left,internal__.NID_Stop,internal__.NID_Go_down|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::D__(id__,
								   		    const_MidLevelSM_step,
								   		    const_MidLevelSM_climb_speed,
								   		    const_MidLevelSM_descent_speed,
								   		    const_MidLevelSM_side_speed,
								   		    const_MidLevelSM_forward_angle,
								   		    const_MidLevelSM_left_angle,
								   		    const_MidLevelSM_right_angle,
								   		    const_MidLevelSM_turn_speed,
								   		    const_MidLevelSM_movesp,
								   		    const_MidLevelSM_stopsp)
								   [| { share__, terminate } |] (
								   Go_up::D__(id__,
								   		    const_MidLevelSM_step,
								   		    const_MidLevelSM_climb_speed,
								   		    const_MidLevelSM_descent_speed,
								   		    const_MidLevelSM_side_speed,
								   		    const_MidLevelSM_forward_angle,
								   		    const_MidLevelSM_left_angle,
								   		    const_MidLevelSM_right_angle,
								   		    const_MidLevelSM_turn_speed,
								   		    const_MidLevelSM_movesp,
								   		    const_MidLevelSM_stopsp)
								   [| { share__, terminate } |] (
								   Turn_right::D__(id__,
								   		    const_MidLevelSM_step,
								   		    const_MidLevelSM_climb_speed,
								   		    const_MidLevelSM_descent_speed,
								   		    const_MidLevelSM_side_speed,
								   		    const_MidLevelSM_forward_angle,
								   		    const_MidLevelSM_left_angle,
								   		    const_MidLevelSM_right_angle,
								   		    const_MidLevelSM_turn_speed,
								   		    const_MidLevelSM_movesp,
								   		    const_MidLevelSM_stopsp)
								   [| { share__, terminate } |] (
								   Go_down::D__(id__,
								   		    const_MidLevelSM_step,
								   		    const_MidLevelSM_climb_speed,
								   		    const_MidLevelSM_descent_speed,
								   		    const_MidLevelSM_side_speed,
								   		    const_MidLevelSM_forward_angle,
								   		    const_MidLevelSM_left_angle,
								   		    const_MidLevelSM_right_angle,
								   		    const_MidLevelSM_turn_speed,
								   		    const_MidLevelSM_movesp,
								   		    const_MidLevelSM_stopsp)
								   [| { share__, terminate } |] (
								   Turn_left::D__(id__,
								   		    const_MidLevelSM_step,
								   		    const_MidLevelSM_climb_speed,
								   		    const_MidLevelSM_descent_speed,
								   		    const_MidLevelSM_side_speed,
								   		    const_MidLevelSM_forward_angle,
								   		    const_MidLevelSM_left_angle,
								   		    const_MidLevelSM_right_angle,
								   		    const_MidLevelSM_turn_speed,
								   		    const_MidLevelSM_movesp,
								   		    const_MidLevelSM_stopsp)
								   [| { share__, terminate } |] (
								   Go_side::D__(id__,
								   		    const_MidLevelSM_step,
								   		    const_MidLevelSM_climb_speed,
								   		    const_MidLevelSM_descent_speed,
								   		    const_MidLevelSM_side_speed,
								   		    const_MidLevelSM_forward_angle,
								   		    const_MidLevelSM_left_angle,
								   		    const_MidLevelSM_right_angle,
								   		    const_MidLevelSM_turn_speed,
								   		    const_MidLevelSM_movesp,
								   		    const_MidLevelSM_stopsp)
								   [| { share__, terminate } |] (
								   Stop::D__(id__,
								   		    const_MidLevelSM_step,
								   		    const_MidLevelSM_climb_speed,
								   		    const_MidLevelSM_descent_speed,
								   		    const_MidLevelSM_side_speed,
								   		    const_MidLevelSM_forward_angle,
								   		    const_MidLevelSM_left_angle,
								   		    const_MidLevelSM_right_angle,
								   		    const_MidLevelSM_turn_speed,
								   		    const_MidLevelSM_movesp,
								   		    const_MidLevelSM_stopsp)
								   )
								   )
								   )
								   )
								   )
								   )
								 )
								 [[Go_up::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_Go_up.in,turn__.NID_Go_up.in,stop__.NID_Go_up.in,internal__.NID_Go_up|}]]
								 [[Turn_right::interrupt <- x__ | x__ <- {|interrupt,move_forward__.NID_Turn_right.in,turn__.NID_Turn_right.in,move_forward__.NID_Turn_right.in,move_forward__.NID_Turn_right.in,turn__.NID_Turn_right.in,internal__.NID_Turn_right|}]]
								 [[Go_down::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_Go_down.in,turn__.NID_Go_down.in,stop__.NID_Go_down.in,internal__.NID_Go_down|}]]
								 [[Turn_left::interrupt <- x__ | x__ <- {|interrupt,move_forward__.NID_Turn_left.in,turn__.NID_Turn_left.in,move_forward__.NID_Turn_left.in,move_forward__.NID_Turn_left.in,turn__.NID_Turn_left.in,internal__.NID_Turn_left|}]]
								 [[Go_side::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_Go_side.in,turn__.NID_Go_side.in,stop__.NID_Go_side.in,internal__.NID_Go_side|}]]
								 [[Stop::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_Stop.in,turn__.NID_Stop.in,internal__.NID_Stop|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_direction |} ]] 
								  [[set_direction <- setL_direction,set_orientation <- setL_orientation]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_direction
								 			,setL_orientation
								 			,setR_direction
								 			|}) |]
								 ((i0::enter -> Transitions(id__,
								 		    const_MidLevelSM_step,
								 		    const_MidLevelSM_climb_speed,
								 		    const_MidLevelSM_descent_speed,
								 		    const_MidLevelSM_side_speed,
								 		    const_MidLevelSM_forward_angle,
								 		    const_MidLevelSM_left_angle,
								 		    const_MidLevelSM_right_angle,
								 		    const_MidLevelSM_turn_speed,
								 		    const_MidLevelSM_movesp,
								 		    const_MidLevelSM_stopsp))
								  [[ share__ <- x__ | x__ <- {| share__,setL_direction,setL_orientation |} ]]
								  [[set_direction <- setR_direction]]
								 )
								)[[setL_direction <- set_direction,setL_orientation <- set_orientation]]
								 [[setR_direction <- set_direction]]
								)
							)
							 \ hideSet)
							[[
								target_speed__.x____ <- target_speed,
								target_angle__.x____ <- target_angle,
								speed_adjustment__.x____ <- speed_adjustment,
								angle_adjustment__.x____ <- angle_adjustment,
								move_forward__.x____ <- move_forward,
								turn__.x____ <- turn,
								stop__.x____ <- stop
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp) = 
					dbisim((MachineBody(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp)\ enteredSS)
					)
				
				IteratedBehaviour(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp) = 
					dbisim((MachineBody(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp)\ enteredSS)
					)
				
				Stateful(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp) = 
					((
						(Behaviour(id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															dbisim(
																sbisim(
																	dbisim(
																		sbisim(
																			Behaviour(id__,
																					    const_MidLevelSM_step,
																					    const_MidLevelSM_climb_speed,
																					    const_MidLevelSM_descent_speed,
																					    const_MidLevelSM_side_speed,
																					    const_MidLevelSM_forward_angle,
																					    const_MidLevelSM_left_angle,
																					    const_MidLevelSM_right_angle,
																					    const_MidLevelSM_turn_speed,
																					    const_MidLevelSM_movesp,
																					    const_MidLevelSM_stopsp)
																			[| {|get_orientation,set_orientation,terminate|} |]
																			Memory_orientation(Orientation_up)
																		)\{|get_orientation,set_orientation|}
																	)
																	[| {|get_direction,set_direction,terminate|} |]
																	Memory_direction(Direction_left)
																)\{|get_direction,set_direction|}
															)
															[| {|get_angle_adj,set_angle_adj,terminate|} |]
															Memory_angle_adj(0)
														)\{|get_angle_adj,set_angle_adj|}
													)
													[| {|get_speed_adj,set_speed_adj,terminate|} |]
													Memory_speed_adj(0)
												)\{|get_speed_adj,set_speed_adj|}
											)
											[| {|get_angle,set_angle,terminate|} |]
											Memory_angle(0)
										)\{|get_angle,set_angle|}
									)
									[| {|get_rspeed,set_rspeed,terminate|} |]
									Memory_rspeed(0)
								)\{|get_rspeed,set_rspeed|}
							)
							[| {|get_lspeed,set_lspeed,terminate|} |]
							Memory_lspeed(0)
						)\{|get_lspeed,set_lspeed|}
					)
					)
				
				-- Visible counterparts
				MachineBody_VS_O(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							Go_up::enter,
							Turn_right::enter,
							Go_down::enter,
							Turn_left::enter,
							Go_side::enter,
							Stop::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|turn__.NID_Go_up.in,move_forward__.NID_Turn_right.in,turn__.NID_Go_up.in,turn__.NID_Turn_right.in,move_forward__.NID_Turn_left.in,turn__.NID_Turn_left.in,move_forward__.NID_Turn_right.in,move_forward__.NID_Turn_right.in,move_forward__.NID_Turn_left.in,move_forward__.NID_Turn_left.in,turn__.NID_Go_side.in,turn__.NID_Go_side.in,turn__.NID_Go_down.in,turn__.NID_Go_down.in,internal__.NID_i0,turn__.NID_Turn_right.in,turn__.NID_Turn_left.in,stop__.NID_Go_up.in,stop__.NID_Go_down.in,stop__.NID_Go_side.in,turn__.NID_Stop.in,turn__.NID_Stop.in,internal__.NID_Turn_right,internal__.NID_Go_side,internal__.NID_Go_up,internal__.NID_Turn_left,internal__.NID_Stop,internal__.NID_Go_down|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::VS_O__(id__,
								   		    const_MidLevelSM_step,
								   		    const_MidLevelSM_climb_speed,
								   		    const_MidLevelSM_descent_speed,
								   		    const_MidLevelSM_side_speed,
								   		    const_MidLevelSM_forward_angle,
								   		    const_MidLevelSM_left_angle,
								   		    const_MidLevelSM_right_angle,
								   		    const_MidLevelSM_turn_speed,
								   		    const_MidLevelSM_movesp,
								   		    const_MidLevelSM_stopsp)
								   [| { share__, terminate } |] (
								   Go_up::VS_O__(id__,
								   		    const_MidLevelSM_step,
								   		    const_MidLevelSM_climb_speed,
								   		    const_MidLevelSM_descent_speed,
								   		    const_MidLevelSM_side_speed,
								   		    const_MidLevelSM_forward_angle,
								   		    const_MidLevelSM_left_angle,
								   		    const_MidLevelSM_right_angle,
								   		    const_MidLevelSM_turn_speed,
								   		    const_MidLevelSM_movesp,
								   		    const_MidLevelSM_stopsp)
								   [| { share__, terminate } |] (
								   Turn_right::VS_O__(id__,
								   		    const_MidLevelSM_step,
								   		    const_MidLevelSM_climb_speed,
								   		    const_MidLevelSM_descent_speed,
								   		    const_MidLevelSM_side_speed,
								   		    const_MidLevelSM_forward_angle,
								   		    const_MidLevelSM_left_angle,
								   		    const_MidLevelSM_right_angle,
								   		    const_MidLevelSM_turn_speed,
								   		    const_MidLevelSM_movesp,
								   		    const_MidLevelSM_stopsp)
								   [| { share__, terminate } |] (
								   Go_down::VS_O__(id__,
								   		    const_MidLevelSM_step,
								   		    const_MidLevelSM_climb_speed,
								   		    const_MidLevelSM_descent_speed,
								   		    const_MidLevelSM_side_speed,
								   		    const_MidLevelSM_forward_angle,
								   		    const_MidLevelSM_left_angle,
								   		    const_MidLevelSM_right_angle,
								   		    const_MidLevelSM_turn_speed,
								   		    const_MidLevelSM_movesp,
								   		    const_MidLevelSM_stopsp)
								   [| { share__, terminate } |] (
								   Turn_left::VS_O__(id__,
								   		    const_MidLevelSM_step,
								   		    const_MidLevelSM_climb_speed,
								   		    const_MidLevelSM_descent_speed,
								   		    const_MidLevelSM_side_speed,
								   		    const_MidLevelSM_forward_angle,
								   		    const_MidLevelSM_left_angle,
								   		    const_MidLevelSM_right_angle,
								   		    const_MidLevelSM_turn_speed,
								   		    const_MidLevelSM_movesp,
								   		    const_MidLevelSM_stopsp)
								   [| { share__, terminate } |] (
								   Go_side::VS_O__(id__,
								   		    const_MidLevelSM_step,
								   		    const_MidLevelSM_climb_speed,
								   		    const_MidLevelSM_descent_speed,
								   		    const_MidLevelSM_side_speed,
								   		    const_MidLevelSM_forward_angle,
								   		    const_MidLevelSM_left_angle,
								   		    const_MidLevelSM_right_angle,
								   		    const_MidLevelSM_turn_speed,
								   		    const_MidLevelSM_movesp,
								   		    const_MidLevelSM_stopsp)
								   [| { share__, terminate } |] (
								   Stop::VS_O__(id__,
								   		    const_MidLevelSM_step,
								   		    const_MidLevelSM_climb_speed,
								   		    const_MidLevelSM_descent_speed,
								   		    const_MidLevelSM_side_speed,
								   		    const_MidLevelSM_forward_angle,
								   		    const_MidLevelSM_left_angle,
								   		    const_MidLevelSM_right_angle,
								   		    const_MidLevelSM_turn_speed,
								   		    const_MidLevelSM_movesp,
								   		    const_MidLevelSM_stopsp)
								   )
								   )
								   )
								   )
								   )
								   )
								 )
								 [[Go_up::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_Go_up.in,turn__.NID_Go_up.in,stop__.NID_Go_up.in,internal__.NID_Go_up|}]]
								 [[Turn_right::interrupt <- x__ | x__ <- {|interrupt,move_forward__.NID_Turn_right.in,turn__.NID_Turn_right.in,move_forward__.NID_Turn_right.in,move_forward__.NID_Turn_right.in,turn__.NID_Turn_right.in,internal__.NID_Turn_right|}]]
								 [[Go_down::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_Go_down.in,turn__.NID_Go_down.in,stop__.NID_Go_down.in,internal__.NID_Go_down|}]]
								 [[Turn_left::interrupt <- x__ | x__ <- {|interrupt,move_forward__.NID_Turn_left.in,turn__.NID_Turn_left.in,move_forward__.NID_Turn_left.in,move_forward__.NID_Turn_left.in,turn__.NID_Turn_left.in,internal__.NID_Turn_left|}]]
								 [[Go_side::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_Go_side.in,turn__.NID_Go_side.in,stop__.NID_Go_side.in,internal__.NID_Go_side|}]]
								 [[Stop::interrupt <- x__ | x__ <- {|interrupt,turn__.NID_Stop.in,turn__.NID_Stop.in,internal__.NID_Stop|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_direction |} ]] 
								  [[set_direction <- setL_direction,set_orientation <- setL_orientation]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_direction
								 			,setL_orientation
								 			,setR_direction
								 			|}) |]
								 ((i0::enter -> Transitions(id__,
								 		    const_MidLevelSM_step,
								 		    const_MidLevelSM_climb_speed,
								 		    const_MidLevelSM_descent_speed,
								 		    const_MidLevelSM_side_speed,
								 		    const_MidLevelSM_forward_angle,
								 		    const_MidLevelSM_left_angle,
								 		    const_MidLevelSM_right_angle,
								 		    const_MidLevelSM_turn_speed,
								 		    const_MidLevelSM_movesp,
								 		    const_MidLevelSM_stopsp))
								  [[ share__ <- x__ | x__ <- {| share__,setL_direction,setL_orientation |} ]]
								  [[set_direction <- setR_direction]]
								 )
								)[[setL_direction <- set_direction,setL_orientation <- set_orientation]]
								 [[setR_direction <- set_direction]]
								)
							)
							 \ hideSet)
							[[
								target_speed__.x____ <- target_speed,
								target_angle__.x____ <- target_angle,
								speed_adjustment__.x____ <- speed_adjustment,
								angle_adjustment__.x____ <- angle_adjustment,
								move_forward__.x____ <- move_forward,
								turn__.x____ <- turn,
								stop__.x____ <- stop
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp) = 
					dbisim((MachineBody_VS_O(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp))
					)
				
				IteratedBehaviour_VS_O(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp) = 
					dbisim((MachineBody_VS_O(id__,
							    const_MidLevelSM_step,
							    const_MidLevelSM_climb_speed,
							    const_MidLevelSM_descent_speed,
							    const_MidLevelSM_side_speed,
							    const_MidLevelSM_forward_angle,
							    const_MidLevelSM_left_angle,
							    const_MidLevelSM_right_angle,
							    const_MidLevelSM_turn_speed,
							    const_MidLevelSM_movesp,
							    const_MidLevelSM_stopsp))
					)
				
				Stateful_VS_O(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp) = 
					dbisim((
						(Behaviour_VS_O(id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
								    const_MidLevelSM_step,
								    const_MidLevelSM_climb_speed,
								    const_MidLevelSM_descent_speed,
								    const_MidLevelSM_side_speed,
								    const_MidLevelSM_forward_angle,
								    const_MidLevelSM_left_angle,
								    const_MidLevelSM_right_angle,
								    const_MidLevelSM_turn_speed,
								    const_MidLevelSM_movesp,
								    const_MidLevelSM_stopsp))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful_VS_O(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															dbisim(
																sbisim(
																	dbisim(
																		sbisim(
																			Behaviour_VS_O(id__,
																					    const_MidLevelSM_step,
																					    const_MidLevelSM_climb_speed,
																					    const_MidLevelSM_descent_speed,
																					    const_MidLevelSM_side_speed,
																					    const_MidLevelSM_forward_angle,
																					    const_MidLevelSM_left_angle,
																					    const_MidLevelSM_right_angle,
																					    const_MidLevelSM_turn_speed,
																					    const_MidLevelSM_movesp,
																					    const_MidLevelSM_stopsp)
																			[| {|get_orientation,set_orientation,terminate|} |]
																			Memory_orientation(Orientation_up)
																		)\{|get_orientation,set_orientation|}
																	)
																	[| {|get_direction,set_direction,terminate|} |]
																	Memory_direction(Direction_left)
																)\{|get_direction,set_direction|}
															)
															[| {|get_angle_adj,set_angle_adj,terminate|} |]
															Memory_angle_adj(0)
														)\{|get_angle_adj,set_angle_adj|}
													)
													[| {|get_speed_adj,set_speed_adj,terminate|} |]
													Memory_speed_adj(0)
												)\{|get_speed_adj,set_speed_adj|}
											)
											[| {|get_angle,set_angle,terminate|} |]
											Memory_angle(0)
										)\{|get_angle,set_angle|}
									)
									[| {|get_rspeed,set_rspeed,terminate|} |]
									Memory_rspeed(0)
								)\{|get_rspeed,set_rspeed|}
							)
							[| {|get_lspeed,set_lspeed,terminate|} |]
							Memory_lspeed(0)
						)\{|get_lspeed,set_lspeed|}
					)
					)
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_lspeed(lspeed) =
					get_lspeed!lspeed -> Memory_lspeed(lspeed)
					[]
					set_lspeed?x__ -> Memory_lspeed(x__)
					[]
					terminate -> SKIP
				Memory_rspeed(rspeed) =
					get_rspeed!rspeed -> Memory_rspeed(rspeed)
					[]
					set_rspeed?x__ -> Memory_rspeed(x__)
					[]
					terminate -> SKIP
				Memory_angle(angle) =
					get_angle!angle -> Memory_angle(angle)
					[]
					set_angle?x__ -> Memory_angle(x__)
					[]
					terminate -> SKIP
				Memory_speed_adj(speed_adj) =
					get_speed_adj!speed_adj -> Memory_speed_adj(speed_adj)
					[]
					set_speed_adj?x__ -> Memory_speed_adj(x__)
					[]
					terminate -> SKIP
				Memory_angle_adj(angle_adj) =
					get_angle_adj!angle_adj -> Memory_angle_adj(angle_adj)
					[]
					set_angle_adj?x__ -> Memory_angle_adj(x__)
					[]
					terminate -> SKIP
				Memory_direction(direction) =
					get_direction!direction -> Memory_direction(direction)
					[]
					set_direction?x__ -> Memory_direction(x__)
					[]
					terminate -> SKIP
				Memory_orientation(orientation) =
					get_orientation!orientation -> Memory_orientation(orientation)
					[]
					set_orientation?x__ -> Memory_orientation(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp) = Memory_lspeed(0)
				[| { terminate } |] (
				Memory_rspeed(0)
				[| { terminate } |] (
				Memory_angle(0)
				[| { terminate } |] (
				Memory_speed_adj(0)
				[| { terminate } |] (
				Memory_angle_adj(0)
				[| { terminate } |] (
				Memory_direction(Direction_left)
				[| { terminate } |] (
				Memory_orientation(Orientation_up)
				)
				)
				)
				)
				)
				)
				
				getsetLocalChannels = {|get_lspeed,set_lspeed,get_rspeed,set_rspeed,get_angle,set_angle,get_speed_adj,set_speed_adj,get_angle_adj,set_angle_adj,get_direction,set_direction,get_orientation,set_orientation|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp) = STM_VS_O(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp)
				
				D__(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp) = STM(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp) \ internal_events
				O__(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp) = sbisim(diamond(D__(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp)))
				VS__(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp) = FVS__(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp)
				VS_O__(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp) = sbisim(diamond(FVS__(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp)))
				HEXT__(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp) = O__(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp) [|shared_variable_events|] SKIP
				HUP__(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp) = O__(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp) [|{share__}|] SKIP
				
				-- Shared memory
				-- Shared memory variables
				
				-- sharedVarMemory process
				sharedVarMemory(id__,
						    const_MidLevelSM_step,
						    const_MidLevelSM_climb_speed,
						    const_MidLevelSM_descent_speed,
						    const_MidLevelSM_side_speed,
						    const_MidLevelSM_forward_angle,
						    const_MidLevelSM_left_angle,
						    const_MidLevelSM_right_angle,
						    const_MidLevelSM_turn_speed,
						    const_MidLevelSM_movesp,
						    const_MidLevelSM_stopsp) = terminate -> SKIP
				
				sharedVarSync = {||}
				
				sharedVarHide = {||}
			endmodule
			module stm_ref9
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_wait_input|
				              NID_send_output|
				              NID_wait_right|
				              NID_wait_left
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_spl, set_spl, setL_spl, setR_spl: TripleAxis
				channel get_spr, set_spr, setL_spr, setR_spr: TripleAxis
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel speed_l__: NIDS.InOut.TripleAxis
				channel speed_l: InOut.TripleAxis
				channel speed_r__: NIDS.InOut.TripleAxis
				channel speed_r: InOut.TripleAxis
				channel linear_speed__: NIDS.InOut.core_int
				channel linear_speed: InOut.core_int
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				wait_input::enter,
				send_output::enter,
				wait_right::enter,
				wait_left::enter
				|}
				
				enteredSS = 	{|
				wait_input::entered,
				send_output::entered,
				wait_right::entered,
				wait_left::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	speed_l,
					speed_r,
					linear_speed
					|}
			
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, interrupt
					
					D__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
					
					VS_O__(id__) = D__(id__)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: wait_input
				module wait_input
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: send_output
				module send_output
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: wait_right
				module wait_right
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: wait_left
				module wait_left
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				-- END of Operation calls --
				
				-- STM processes
				STM(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__))
				)\sharedVarHide
				
				STM_VS_O(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__))
				)\sharedVarHide
				
				-- Transitions
				Transitions(id__) = ((let
					Trans = (
						((share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; wait_input::enter -> SKIP))))
						 	 [] dbisim((true)&(speed_l__!NID_wait_input.in?spl:{spl|spl <- TripleAxis, true} -> share__choice(set_spl!spl -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; wait_right::enter -> SKIP)))
						 	 [] dbisim((true)&(speed_r__!NID_wait_input.in?spr:{spr|spr <- TripleAxis, true} -> share__choice(set_spr!spr -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; wait_left::enter -> SKIP)))
						 	 [] dbisim((true)&(speed_r__!NID_wait_right.in?spr:{spr|spr <- TripleAxis, true} -> share__choice(set_spr!spr -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; send_output::enter -> SKIP)))
						 	 [] dbisim((true)&(speed_l__!NID_wait_left.in?spl:{spl|spl <- TripleAxis, true} -> share__choice(set_spl!spl -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; send_output::enter -> SKIP)))
						 	 [] dbisim((true)&(internal__!NID_send_output -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_spr?spr -> share__choice(get_spl?spl -> true&(share__choice(linear_speed.out!get_linear_speed(TripleAxis_Z(spl),TripleAxis_Z(spr)) -> SKIP)))) ; wait_input::enter -> SKIP)))
						 ) ; Trans)
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
					)
				within
					Trans
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							wait_input::enter,
							send_output::enter,
							wait_right::enter,
							wait_left::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0,speed_l__.NID_wait_input.in,speed_r__.NID_wait_input.in,speed_r__.NID_wait_right.in,speed_l__.NID_wait_left.in,internal__.NID_send_output|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::D__(id__)
								   [| { share__, terminate } |] (
								   wait_input::D__(id__)
								   [| { share__, terminate } |] (
								   send_output::D__(id__)
								   [| { share__, terminate } |] (
								   wait_right::D__(id__)
								   [| { share__, terminate } |] (
								   wait_left::D__(id__)
								   )
								   )
								   )
								   )
								 )
								 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,speed_l__.NID_wait_input.in,speed_r__.NID_wait_input.in|}]]
								 [[send_output::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_send_output|}]]
								 [[wait_right::interrupt <- x__ | x__ <- {|interrupt,speed_r__.NID_wait_right.in|}]]
								 [[wait_left::interrupt <- x__ | x__ <- {|interrupt,speed_l__.NID_wait_left.in|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_spr,setR_spl |} ]] 
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setR_spr
								 			 			,setR_spl
								 			|}) |]
								 ((i0::enter -> Transitions(id__))
								  [[ share__ <- x__ | x__ <- {| share__ |} ]]
								  [[set_spr <- setR_spr,set_spl <- setR_spl]]
								 )
								)
								 [[setR_spr <- set_spr,setR_spl <- set_spl]]
								)
							)
							 \ hideSet)
							[[
								speed_l__.x____ <- speed_l,
								speed_r__.x____ <- speed_r,
								linear_speed__.x____ <- linear_speed
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__) = 
					dbisim((MachineBody(id__)\ enteredSS)
					)
				
				IteratedBehaviour(id__) = 
					dbisim((MachineBody(id__)\ enteredSS)
					)
				
				Stateful(id__) = 
					((
						(Behaviour(id__) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful(id__) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									Behaviour(id__)
									[| {|get_spr,set_spr,terminate|} |]
									Memory_spr((0,0,0))
								)\{|get_spr,set_spr|}
							)
							[| {|get_spl,set_spl,terminate|} |]
							Memory_spl((0,0,0))
						)\{|get_spl,set_spl|}
					)
					)
				
				-- Visible counterparts
				MachineBody_VS_O(id__) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							wait_input::enter,
							send_output::enter,
							wait_right::enter,
							wait_left::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0,speed_l__.NID_wait_input.in,speed_r__.NID_wait_input.in,speed_r__.NID_wait_right.in,speed_l__.NID_wait_left.in,internal__.NID_send_output|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::VS_O__(id__)
								   [| { share__, terminate } |] (
								   wait_input::VS_O__(id__)
								   [| { share__, terminate } |] (
								   send_output::VS_O__(id__)
								   [| { share__, terminate } |] (
								   wait_right::VS_O__(id__)
								   [| { share__, terminate } |] (
								   wait_left::VS_O__(id__)
								   )
								   )
								   )
								   )
								 )
								 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,speed_l__.NID_wait_input.in,speed_r__.NID_wait_input.in|}]]
								 [[send_output::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_send_output|}]]
								 [[wait_right::interrupt <- x__ | x__ <- {|interrupt,speed_r__.NID_wait_right.in|}]]
								 [[wait_left::interrupt <- x__ | x__ <- {|interrupt,speed_l__.NID_wait_left.in|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_spr,setR_spl |} ]] 
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setR_spr
								 			 			,setR_spl
								 			|}) |]
								 ((i0::enter -> Transitions(id__))
								  [[ share__ <- x__ | x__ <- {| share__ |} ]]
								  [[set_spr <- setR_spr,set_spl <- setR_spl]]
								 )
								)
								 [[setR_spr <- set_spr,setR_spl <- set_spl]]
								)
							)
							 \ hideSet)
							[[
								speed_l__.x____ <- speed_l,
								speed_r__.x____ <- speed_r,
								linear_speed__.x____ <- linear_speed
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__) = 
					dbisim((MachineBody_VS_O(id__))
					)
				
				IteratedBehaviour_VS_O(id__) = 
					dbisim((MachineBody_VS_O(id__))
					)
				
				Stateful_VS_O(id__) = 
					dbisim((
						(Behaviour_VS_O(id__) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful_VS_O(id__) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									Behaviour_VS_O(id__)
									[| {|get_spr,set_spr,terminate|} |]
									Memory_spr((0,0,0))
								)\{|get_spr,set_spr|}
							)
							[| {|get_spl,set_spl,terminate|} |]
							Memory_spl((0,0,0))
						)\{|get_spl,set_spl|}
					)
					)
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_spl(spl) =
					get_spl!spl -> Memory_spl(spl)
					[]
					set_spl?x__ -> Memory_spl(x__)
					[]
					terminate -> SKIP
				Memory_spr(spr) =
					get_spr!spr -> Memory_spr(spr)
					[]
					set_spr?x__ -> Memory_spr(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__) = Memory_spl((0,0,0))
				[| { terminate } |] (
				Memory_spr((0,0,0))
				)
				
				getsetLocalChannels = {|get_spl,set_spl,get_spr,set_spr|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__) = STM_VS_O(id__)
				
				D__(id__) = STM(id__) \ internal_events
				O__(id__) = sbisim(diamond(D__(id__)))
				VS__(id__) = FVS__(id__)
				VS_O__(id__) = sbisim(diamond(FVS__(id__)))
				HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
				HUP__(id__) = O__(id__) [|{share__}|] SKIP
				
				-- Shared memory
				-- Shared memory variables
				
				-- sharedVarMemory process
				sharedVarMemory(id__) = terminate -> SKIP
				
				sharedVarSync = {||}
				
				sharedVarHide = {||}
			endmodule
			module stm_ref10
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_wait_input|
				              NID_send_output
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_x, set_x, setL_x, setR_x: TripleAxis
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel input__: NIDS.InOut.TripleAxis
				channel input: InOut.TripleAxis
				channel output1__: NIDS.InOut.TripleAxis
				channel output1: InOut.TripleAxis
				channel output2__: NIDS.InOut.TripleAxis
				channel output2: InOut.TripleAxis
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				wait_input::enter,
				send_output::enter
				|}
				
				enteredSS = 	{|
				wait_input::entered,
				send_output::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	input,
					output1,
					output2
					|}
			
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, interrupt
					
					D__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
					
					VS_O__(id__) = D__(id__)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: wait_input
				module wait_input
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: send_output
				module send_output
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				-- END of Operation calls --
				
				-- STM processes
				STM(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__))
				)\sharedVarHide
				
				STM_VS_O(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__))
				)\sharedVarHide
				
				-- Transitions
				Transitions(id__) = ((let
					Trans = (
						((share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; wait_input::enter -> SKIP))))
						 	 [] dbisim((true)&(input__!NID_wait_input.in?x:{x|x <- TripleAxis, true} -> share__choice(set_x!x -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; send_output::enter -> SKIP)))
						 	 [] dbisim((true)&(internal__!NID_send_output -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_x?x -> true&(share__choice(output1.out!x -> SKIP)));share__choice(get_x?x -> true&(share__choice(output2.out!x -> SKIP))) ; wait_input::enter -> SKIP)))
						 ) ; Trans)
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
					)
				within
					Trans
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							wait_input::enter,
							send_output::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0,input__.NID_wait_input.in,internal__.NID_send_output|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::D__(id__)
								   [| { share__, terminate } |] (
								   wait_input::D__(id__)
								   [| { share__, terminate } |] (
								   send_output::D__(id__)
								   )
								   )
								 )
								 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,input__.NID_wait_input.in|}]]
								 [[send_output::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_send_output|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_x |} ]] 
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setR_x
								 			|}) |]
								 ((i0::enter -> Transitions(id__))
								  [[ share__ <- x__ | x__ <- {| share__ |} ]]
								  [[set_x <- setR_x]]
								 )
								)
								 [[setR_x <- set_x]]
								)
							)
							 \ hideSet)
							[[
								input__.x____ <- input,
								output1__.x____ <- output1,
								output2__.x____ <- output2
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__) = 
					dbisim((MachineBody(id__)\ enteredSS)
					)
				
				IteratedBehaviour(id__) = 
					dbisim((MachineBody(id__)\ enteredSS)
					)
				
				Stateful(id__) = 
					((
						(Behaviour(id__) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful(id__) =
					(dbisim(
						sbisim(
							Behaviour(id__)
							[| {|get_x,set_x,terminate|} |]
							Memory_x((0,0,0))
						)\{|get_x,set_x|}
					)
					)
				
				-- Visible counterparts
				MachineBody_VS_O(id__) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							wait_input::enter,
							send_output::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0,input__.NID_wait_input.in,internal__.NID_send_output|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::VS_O__(id__)
								   [| { share__, terminate } |] (
								   wait_input::VS_O__(id__)
								   [| { share__, terminate } |] (
								   send_output::VS_O__(id__)
								   )
								   )
								 )
								 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,input__.NID_wait_input.in|}]]
								 [[send_output::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_send_output|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_x |} ]] 
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setR_x
								 			|}) |]
								 ((i0::enter -> Transitions(id__))
								  [[ share__ <- x__ | x__ <- {| share__ |} ]]
								  [[set_x <- setR_x]]
								 )
								)
								 [[setR_x <- set_x]]
								)
							)
							 \ hideSet)
							[[
								input__.x____ <- input,
								output1__.x____ <- output1,
								output2__.x____ <- output2
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__) = 
					dbisim((MachineBody_VS_O(id__))
					)
				
				IteratedBehaviour_VS_O(id__) = 
					dbisim((MachineBody_VS_O(id__))
					)
				
				Stateful_VS_O(id__) = 
					dbisim((
						(Behaviour_VS_O(id__) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful_VS_O(id__) =
					(dbisim(
						sbisim(
							Behaviour_VS_O(id__)
							[| {|get_x,set_x,terminate|} |]
							Memory_x((0,0,0))
						)\{|get_x,set_x|}
					)
					)
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_x(x) =
					get_x!x -> Memory_x(x)
					[]
					set_x?x__ -> Memory_x(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__) = Memory_x((0,0,0))
				
				getsetLocalChannels = {|get_x,set_x|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__) = STM_VS_O(id__)
				
				D__(id__) = STM(id__) \ internal_events
				O__(id__) = sbisim(diamond(D__(id__)))
				VS__(id__) = FVS__(id__)
				VS_O__(id__) = sbisim(diamond(FVS__(id__)))
				HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
				HUP__(id__) = O__(id__) [|{share__}|] SKIP
				
				-- Shared memory
				-- Shared memory variables
				
				-- sharedVarMemory process
				sharedVarMemory(id__) = terminate -> SKIP
				
				sharedVarSync = {||}
				
				sharedVarHide = {||}
			endmodule
			module stm_ref11
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_wait_input|
				              NID_send_output
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_x, set_x, setL_x, setR_x: TripleAxis
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel input__: NIDS.InOut.TripleAxis
				channel input: InOut.TripleAxis
				channel output1__: NIDS.InOut.TripleAxis
				channel output1: InOut.TripleAxis
				channel output2__: NIDS.InOut.TripleAxis
				channel output2: InOut.TripleAxis
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				wait_input::enter,
				send_output::enter
				|}
				
				enteredSS = 	{|
				wait_input::entered,
				send_output::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	input,
					output1,
					output2
					|}
			
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, interrupt
					
					D__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
					
					VS_O__(id__) = D__(id__)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: wait_input
				module wait_input
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: send_output
				module send_output
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				-- END of Operation calls --
				
				-- STM processes
				STM(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__))
				)\sharedVarHide
				
				STM_VS_O(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__))
				)\sharedVarHide
				
				-- Transitions
				Transitions(id__) = ((let
					Trans = (
						((share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; wait_input::enter -> SKIP))))
						 	 [] dbisim((true)&(input__!NID_wait_input.in?x:{x|x <- TripleAxis, true} -> share__choice(set_x!x -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; send_output::enter -> SKIP)))
						 	 [] dbisim((true)&(internal__!NID_send_output -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_x?x -> true&(share__choice(output1.out!x -> SKIP)));share__choice(get_x?x -> true&(share__choice(output2.out!x -> SKIP))) ; wait_input::enter -> SKIP)))
						 ) ; Trans)
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
					)
				within
					Trans
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							wait_input::enter,
							send_output::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0,input__.NID_wait_input.in,internal__.NID_send_output|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::D__(id__)
								   [| { share__, terminate } |] (
								   wait_input::D__(id__)
								   [| { share__, terminate } |] (
								   send_output::D__(id__)
								   )
								   )
								 )
								 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,input__.NID_wait_input.in|}]]
								 [[send_output::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_send_output|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_x |} ]] 
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setR_x
								 			|}) |]
								 ((i0::enter -> Transitions(id__))
								  [[ share__ <- x__ | x__ <- {| share__ |} ]]
								  [[set_x <- setR_x]]
								 )
								)
								 [[setR_x <- set_x]]
								)
							)
							 \ hideSet)
							[[
								input__.x____ <- input,
								output1__.x____ <- output1,
								output2__.x____ <- output2
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__) = 
					dbisim((MachineBody(id__)\ enteredSS)
					)
				
				IteratedBehaviour(id__) = 
					dbisim((MachineBody(id__)\ enteredSS)
					)
				
				Stateful(id__) = 
					((
						(Behaviour(id__) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful(id__) =
					(dbisim(
						sbisim(
							Behaviour(id__)
							[| {|get_x,set_x,terminate|} |]
							Memory_x((0,0,0))
						)\{|get_x,set_x|}
					)
					)
				
				-- Visible counterparts
				MachineBody_VS_O(id__) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							wait_input::enter,
							send_output::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0,input__.NID_wait_input.in,internal__.NID_send_output|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::VS_O__(id__)
								   [| { share__, terminate } |] (
								   wait_input::VS_O__(id__)
								   [| { share__, terminate } |] (
								   send_output::VS_O__(id__)
								   )
								   )
								 )
								 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,input__.NID_wait_input.in|}]]
								 [[send_output::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_send_output|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_x |} ]] 
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setR_x
								 			|}) |]
								 ((i0::enter -> Transitions(id__))
								  [[ share__ <- x__ | x__ <- {| share__ |} ]]
								  [[set_x <- setR_x]]
								 )
								)
								 [[setR_x <- set_x]]
								)
							)
							 \ hideSet)
							[[
								input__.x____ <- input,
								output1__.x____ <- output1,
								output2__.x____ <- output2
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__) = 
					dbisim((MachineBody_VS_O(id__))
					)
				
				IteratedBehaviour_VS_O(id__) = 
					dbisim((MachineBody_VS_O(id__))
					)
				
				Stateful_VS_O(id__) = 
					dbisim((
						(Behaviour_VS_O(id__) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful_VS_O(id__) =
					(dbisim(
						sbisim(
							Behaviour_VS_O(id__)
							[| {|get_x,set_x,terminate|} |]
							Memory_x((0,0,0))
						)\{|get_x,set_x|}
					)
					)
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_x(x) =
					get_x!x -> Memory_x(x)
					[]
					set_x?x__ -> Memory_x(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__) = Memory_x((0,0,0))
				
				getsetLocalChannels = {|get_x,set_x|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__) = STM_VS_O(id__)
				
				D__(id__) = STM(id__) \ internal_events
				O__(id__) = sbisim(diamond(D__(id__)))
				VS__(id__) = FVS__(id__)
				VS_O__(id__) = sbisim(diamond(FVS__(id__)))
				HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
				HUP__(id__) = O__(id__) [|{share__}|] SKIP
				
				-- Shared memory
				-- Shared memory variables
				
				-- sharedVarMemory process
				sharedVarMemory(id__) = terminate -> SKIP
				
				sharedVarSync = {||}
				
				sharedVarHide = {||}
			endmodule
			module stm_ref12
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_wait_input|
				              NID_send_output
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_x, set_x, setL_x, setR_x: TripleAxis
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel input__: NIDS.InOut.TripleAxis
				channel input: InOut.TripleAxis
				channel output1__: NIDS.InOut.TripleAxis
				channel output1: InOut.TripleAxis
				channel output2__: NIDS.InOut.TripleAxis
				channel output2: InOut.TripleAxis
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				wait_input::enter,
				send_output::enter
				|}
				
				enteredSS = 	{|
				wait_input::entered,
				send_output::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	input,
					output1,
					output2
					|}
			
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, interrupt
					
					D__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
					
					VS_O__(id__) = D__(id__)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: wait_input
				module wait_input
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: send_output
				module send_output
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				-- END of Operation calls --
				
				-- STM processes
				STM(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__))
				)\sharedVarHide
				
				STM_VS_O(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__))
				)\sharedVarHide
				
				-- Transitions
				Transitions(id__) = ((let
					Trans = (
						((share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; wait_input::enter -> SKIP))))
						 	 [] dbisim((true)&(input__!NID_wait_input.in?x:{x|x <- TripleAxis, true} -> share__choice(set_x!x -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; send_output::enter -> SKIP)))
						 	 [] dbisim((true)&(internal__!NID_send_output -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_x?x -> true&(share__choice(output1.out!x -> SKIP)));share__choice(get_x?x -> true&(share__choice(output2.out!x -> SKIP))) ; wait_input::enter -> SKIP)))
						 ) ; Trans)
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
					)
				within
					Trans
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							wait_input::enter,
							send_output::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0,input__.NID_wait_input.in,internal__.NID_send_output|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::D__(id__)
								   [| { share__, terminate } |] (
								   wait_input::D__(id__)
								   [| { share__, terminate } |] (
								   send_output::D__(id__)
								   )
								   )
								 )
								 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,input__.NID_wait_input.in|}]]
								 [[send_output::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_send_output|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_x |} ]] 
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setR_x
								 			|}) |]
								 ((i0::enter -> Transitions(id__))
								  [[ share__ <- x__ | x__ <- {| share__ |} ]]
								  [[set_x <- setR_x]]
								 )
								)
								 [[setR_x <- set_x]]
								)
							)
							 \ hideSet)
							[[
								input__.x____ <- input,
								output1__.x____ <- output1,
								output2__.x____ <- output2
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__) = 
					dbisim((MachineBody(id__)\ enteredSS)
					)
				
				IteratedBehaviour(id__) = 
					dbisim((MachineBody(id__)\ enteredSS)
					)
				
				Stateful(id__) = 
					((
						(Behaviour(id__) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful(id__) =
					(dbisim(
						sbisim(
							Behaviour(id__)
							[| {|get_x,set_x,terminate|} |]
							Memory_x((0,0,0))
						)\{|get_x,set_x|}
					)
					)
				
				-- Visible counterparts
				MachineBody_VS_O(id__) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							wait_input::enter,
							send_output::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0,input__.NID_wait_input.in,internal__.NID_send_output|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::VS_O__(id__)
								   [| { share__, terminate } |] (
								   wait_input::VS_O__(id__)
								   [| { share__, terminate } |] (
								   send_output::VS_O__(id__)
								   )
								   )
								 )
								 [[wait_input::interrupt <- x__ | x__ <- {|interrupt,input__.NID_wait_input.in|}]]
								 [[send_output::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_send_output|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_x |} ]] 
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setR_x
								 			|}) |]
								 ((i0::enter -> Transitions(id__))
								  [[ share__ <- x__ | x__ <- {| share__ |} ]]
								  [[set_x <- setR_x]]
								 )
								)
								 [[setR_x <- set_x]]
								)
							)
							 \ hideSet)
							[[
								input__.x____ <- input,
								output1__.x____ <- output1,
								output2__.x____ <- output2
								| x____ <- NIDS
							]]
						)
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__) = 
					dbisim((MachineBody_VS_O(id__))
					)
				
				IteratedBehaviour_VS_O(id__) = 
					dbisim((MachineBody_VS_O(id__))
					)
				
				Stateful_VS_O(id__) = 
					dbisim((
						(Behaviour_VS_O(id__) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__))
					 	\getsetLocalChannels
					)
					)
				
				IteratedStateful_VS_O(id__) =
					(dbisim(
						sbisim(
							Behaviour_VS_O(id__)
							[| {|get_x,set_x,terminate|} |]
							Memory_x((0,0,0))
						)\{|get_x,set_x|}
					)
					)
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_x(x) =
					get_x!x -> Memory_x(x)
					[]
					set_x?x__ -> Memory_x(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__) = Memory_x((0,0,0))
				
				getsetLocalChannels = {|get_x,set_x|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__) = STM_VS_O(id__)
				
				D__(id__) = STM(id__) \ internal_events
				O__(id__) = sbisim(diamond(D__(id__)))
				VS__(id__) = FVS__(id__)
				VS_O__(id__) = sbisim(diamond(FVS__(id__)))
				HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
				HUP__(id__) = O__(id__) [|{share__}|] SKIP
				
				-- Shared memory
				-- Shared memory variables
				
				-- sharedVarMemory process
				sharedVarMemory(id__) = terminate -> SKIP
				
				sharedVarSync = {||}
				
				sharedVarHide = {||}
			endmodule
			
				-- undefined operations
				CALL__brush(id__,
						    param_x) 	= brushCall.param_x -> SKIP
				CALL__vacuum(id__,
						    param_x) 	= vacuumCall.param_x -> SKIP
				CALL__output_left_motor(id__,
						    param_x) 	= output_left_motorCall.param_x -> SKIP
				CALL__output_right_motor(id__,
						    param_x) 	= output_right_motorCall.param_x -> SKIP
				
				-- declaring controller memory
				Memory(id__) = SKIP
				
				D__(id__,
						    const_Module_PathPlanningController_stm_ref0_cliff,
						    const_Module_PathPlanningController_stm_ref0_nozzle,
						    const_Module_PathPlanningController_stm_ref0_battery_low,
						    const_Module_PathPlanningController_stm_ref0_sleep_time,
						    const_Module_PathPlanningController_stm_ref0_acc_distance,
						    const_Module_PathPlanningController_stm_ref1_t,
						    const_Module_PathPlanningController_stm_ref2_t,
						    const_Module_PathPlanningController_stm_ref3_t,
						    const_Module_PathPlanningController_stm_ref4_voltage,
						    const_Module_PathPlanningController_stm_ref5_t,
						    const_Module_PathPlanningController_stm_ref5_acc_distance,
						    const_Module_PathPlanningController_stm_ref6_kp,
						    const_Module_PathPlanningController_stm_ref6_ki,
						    const_Module_PathPlanningController_stm_ref6_kd,
						    const_Module_PathPlanningController_stm_ref6_step,
						    const_Module_PathPlanningController_stm_ref7_kp,
						    const_Module_PathPlanningController_stm_ref7_ki,
						    const_Module_PathPlanningController_stm_ref7_kd,
						    const_Module_PathPlanningController_stm_ref7_step,
						    const_Module_PathPlanningController_stm_ref8_step,
						    const_Module_PathPlanningController_stm_ref8_climb_speed,
						    const_Module_PathPlanningController_stm_ref8_descent_speed,
						    const_Module_PathPlanningController_stm_ref8_side_speed,
						    const_Module_PathPlanningController_stm_ref8_forward_angle,
						    const_Module_PathPlanningController_stm_ref8_left_angle,
						    const_Module_PathPlanningController_stm_ref8_right_angle,
						    const_Module_PathPlanningController_stm_ref8_turn_speed,
						    const_Module_PathPlanningController_stm_ref8_movesp,
						    const_Module_PathPlanningController_stm_ref8_stopsp) = 	((
						(
							let
								const_PathPlanningSM_cliff = const_Module_PathPlanningController_stm_ref0_cliff
								const_PathPlanningSM_nozzle = const_Module_PathPlanningController_stm_ref0_nozzle
								const_PathPlanningSM_battery_low = const_Module_PathPlanningController_stm_ref0_battery_low
								const_PathPlanningSM_sleep_time = const_Module_PathPlanningController_stm_ref0_sleep_time
								const_PathPlanningSM_acc_distance = const_Module_PathPlanningController_stm_ref0_acc_distance
							within 
							stm_ref0::D__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::displacement.in <- stm_ref3::displacement.out,
								stm_ref0::displacement.out <- stm_ref3::displacement.in,
								stm_ref0::ultrasonic <- ultrasonic,
								stm_ref0::battery_level <- battery_level,
								stm_ref0::charging <- charging
							]]
						)
							[|{|terminate, stm_ref0::clean, stm_ref3::displacement, stm_ref0::move_forward, stm_ref0::turn, stm_ref0::stop|}|]
						(
							(
								let
									const_SpeedSM_t = const_Module_PathPlanningController_stm_ref1_t
								within 
								stm_ref1::D__(id__,
										    const_SpeedSM_t)[[
									stm_ref1::terminate <- terminate,
									stm_ref1::acc.in <- stm_ref10::output1.out,
									stm_ref1::acc.out <- stm_ref10::output1.in
								]]
							)
								[|{|terminate, stm_ref1::sp, stm_ref10::output1|}|]
							(
								(
									let
										const_SpeedSM_t = const_Module_PathPlanningController_stm_ref2_t
									within 
									stm_ref2::D__(id__,
											    const_SpeedSM_t)[[
										stm_ref2::terminate <- terminate,
										stm_ref2::acc.in <- stm_ref11::output1.out,
										stm_ref2::acc.out <- stm_ref11::output1.in
									]]
								)
									[|{|terminate, stm_ref11::output1, stm_ref2::sp|}|]
								(
									(
										let
											const_DisplacementSM_t = const_Module_PathPlanningController_stm_ref3_t
										within 
										stm_ref3::D__(id__,
												    const_DisplacementSM_t)[[
											stm_ref3::terminate <- terminate,
											stm_ref3::sp.in <- stm_ref12::output1.out,
											stm_ref3::sp.out <- stm_ref12::output1.in
										]]
									)
										[|{|terminate, stm_ref12::output1|}|]
									(
										(
											let
												const_CleanSM_voltage = const_Module_PathPlanningController_stm_ref4_voltage
											within 
											stm_ref4::D__(id__,
													    const_CleanSM_voltage)[[
												stm_ref4::terminate <- terminate,
												stm_ref4::clean.in <- stm_ref0::clean.out,
												stm_ref4::clean.out <- stm_ref0::clean.in,
												stm_ref4::brushCall <- brushCall,
												stm_ref4::vacuumCall <- vacuumCall
											]]
										)
											[|{|terminate|}|]
										(
											(
												let
													const_AngularSpeedSM_t = const_Module_PathPlanningController_stm_ref5_t
													const_AngularSpeedSM_acc_distance = const_Module_PathPlanningController_stm_ref5_acc_distance
												within 
												stm_ref5::D__(id__,
														    const_AngularSpeedSM_t,
														    const_AngularSpeedSM_acc_distance)[[
													stm_ref5::terminate <- terminate,
													stm_ref5::acc_l.in <- stm_ref10::output2.out,
													stm_ref5::acc_l.out <- stm_ref10::output2.in,
													stm_ref5::acc_r.in <- stm_ref11::output2.out,
													stm_ref5::acc_r.out <- stm_ref11::output2.in
												]]
											)
												[|{|terminate, stm_ref5::angle, stm_ref10::output2, stm_ref11::output2|}|]
											(
												(
													let
														const_PID_kp = const_Module_PathPlanningController_stm_ref6_kp
														const_PID_ki = const_Module_PathPlanningController_stm_ref6_ki
														const_PID_kd = const_Module_PathPlanningController_stm_ref6_kd
														const_PID_step = const_Module_PathPlanningController_stm_ref6_step
													within 
													stm_ref6::D__(id__,
															    const_PID_kp,
															    const_PID_ki,
															    const_PID_kd,
															    const_PID_step)[[
														stm_ref6::terminate <- terminate,
														stm_ref6::target.in <- stm_ref8::target_angle.out,
														stm_ref6::target.out <- stm_ref8::target_angle.in,
														stm_ref6::actual.in <- stm_ref5::angle.out,
														stm_ref6::actual.out <- stm_ref5::angle.in
													]]
												)
													[|{|terminate, stm_ref8::target_angle, stm_ref6::err_output|}|]
												(
													(
														let
															const_PID_kp = const_Module_PathPlanningController_stm_ref7_kp
															const_PID_ki = const_Module_PathPlanningController_stm_ref7_ki
															const_PID_kd = const_Module_PathPlanningController_stm_ref7_kd
															const_PID_step = const_Module_PathPlanningController_stm_ref7_step
														within 
														stm_ref7::D__(id__,
																    const_PID_kp,
																    const_PID_ki,
																    const_PID_kd,
																    const_PID_step)[[
															stm_ref7::terminate <- terminate,
															stm_ref7::target.in <- stm_ref8::target_speed.out,
															stm_ref7::target.out <- stm_ref8::target_speed.in,
															stm_ref7::actual.in <- stm_ref9::linear_speed.out,
															stm_ref7::actual.out <- stm_ref9::linear_speed.in
														]]
													)
														[|{|terminate, stm_ref8::target_speed, stm_ref7::err_output, stm_ref9::linear_speed|}|]
													(
														(
															let
																const_MidLevelSM_step = const_Module_PathPlanningController_stm_ref8_step
																const_MidLevelSM_climb_speed = const_Module_PathPlanningController_stm_ref8_climb_speed
																const_MidLevelSM_descent_speed = const_Module_PathPlanningController_stm_ref8_descent_speed
																const_MidLevelSM_side_speed = const_Module_PathPlanningController_stm_ref8_side_speed
																const_MidLevelSM_forward_angle = const_Module_PathPlanningController_stm_ref8_forward_angle
																const_MidLevelSM_left_angle = const_Module_PathPlanningController_stm_ref8_left_angle
																const_MidLevelSM_right_angle = const_Module_PathPlanningController_stm_ref8_right_angle
																const_MidLevelSM_turn_speed = const_Module_PathPlanningController_stm_ref8_turn_speed
																const_MidLevelSM_movesp = const_Module_PathPlanningController_stm_ref8_movesp
																const_MidLevelSM_stopsp = const_Module_PathPlanningController_stm_ref8_stopsp
															within 
															stm_ref8::D__(id__,
																	    const_MidLevelSM_step,
																	    const_MidLevelSM_climb_speed,
																	    const_MidLevelSM_descent_speed,
																	    const_MidLevelSM_side_speed,
																	    const_MidLevelSM_forward_angle,
																	    const_MidLevelSM_left_angle,
																	    const_MidLevelSM_right_angle,
																	    const_MidLevelSM_turn_speed,
																	    const_MidLevelSM_movesp,
																	    const_MidLevelSM_stopsp)[[
																stm_ref8::terminate <- terminate,
																stm_ref8::speed_adjustment.in <- stm_ref7::err_output.out,
																stm_ref8::speed_adjustment.out <- stm_ref7::err_output.in,
																stm_ref8::angle_adjustment.in <- stm_ref6::err_output.out,
																stm_ref8::angle_adjustment.out <- stm_ref6::err_output.in,
																stm_ref8::move_forward.in <- stm_ref0::move_forward.out,
																stm_ref8::move_forward.out <- stm_ref0::move_forward.in,
																stm_ref8::turn.in <- stm_ref0::turn.out,
																stm_ref8::turn.out <- stm_ref0::turn.in,
																stm_ref8::stop.in <- stm_ref0::stop.out,
																stm_ref8::stop.out <- stm_ref0::stop.in,
																stm_ref8::output_left_motorCall <- output_left_motorCall,
																stm_ref8::output_right_motorCall <- output_right_motorCall
															]]
														)
															[|{|terminate|}|]
														(
															(
																stm_ref9::D__(id__)[[
																	stm_ref9::terminate <- terminate,
																	stm_ref9::speed_l.in <- stm_ref1::sp.out,
																	stm_ref9::speed_l.out <- stm_ref1::sp.in,
																	stm_ref9::speed_r.in <- stm_ref12::output2.out,
																	stm_ref9::speed_r.out <- stm_ref12::output2.in
																]]
															)
																[|{|terminate, stm_ref12::output2|}|]
															(
																(
																	stm_ref10::D__(id__)[[
																		stm_ref10::terminate <- terminate,
																		stm_ref10::input <- acc_l
																	]]
																)
																	[|{|terminate|}|]
																(
																	(
																		stm_ref11::D__(id__)[[
																			stm_ref11::terminate <- terminate,
																			stm_ref11::input <- acc_r
																		]]
																	)
																		[|{|terminate|}|]
																	(
																		stm_ref12::D__(id__)[[
																			stm_ref12::terminate <- terminate,
																			stm_ref12::input.in <- stm_ref2::sp.out,
																			stm_ref12::input.out <- stm_ref2::sp.in
																		]]
																	)
																)
																\diff(
																	{|terminate|},
																	{|terminate|}
																)
															)
															\diff(
																{|terminate|},
																{|terminate|}
															)
														)
														\diff(
															{|terminate, stm_ref12::output2|},
															{|terminate|}
														)
													)
													\diff(
														{|terminate|},
														{|terminate|}
													)
												)
												\diff(
													{|terminate, stm_ref8::target_speed, stm_ref7::err_output, stm_ref9::linear_speed|},
													{|terminate|}
												)
											)
											\diff(
												{|terminate, stm_ref8::target_angle, stm_ref6::err_output|},
												{|terminate|}
											)
										)
										\diff(
											{|terminate, stm_ref5::angle, stm_ref10::output2, stm_ref11::output2|},
											{|terminate|}
										)
									)
									\diff(
										{|terminate|},
										{|terminate|}
									)
								)
								\diff(
									{|terminate, stm_ref12::output1|},
									{|terminate|}
								)
							)
							\diff(
								{|terminate, stm_ref11::output1, stm_ref2::sp|},
								{|terminate|}
							)
						)
						\diff(
							{|terminate, stm_ref1::sp, stm_ref10::output1|},
							{|terminate|}
						)
					)
					\diff(
						{|terminate, stm_ref0::clean, stm_ref3::displacement, stm_ref0::move_forward, stm_ref0::turn, stm_ref0::stop|},
						{|terminate|}
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				
				-- VS version
				VS__(id__,
						    const_Module_PathPlanningController_stm_ref0_cliff,
						    const_Module_PathPlanningController_stm_ref0_nozzle,
						    const_Module_PathPlanningController_stm_ref0_battery_low,
						    const_Module_PathPlanningController_stm_ref0_sleep_time,
						    const_Module_PathPlanningController_stm_ref0_acc_distance,
						    const_Module_PathPlanningController_stm_ref1_t,
						    const_Module_PathPlanningController_stm_ref2_t,
						    const_Module_PathPlanningController_stm_ref3_t,
						    const_Module_PathPlanningController_stm_ref4_voltage,
						    const_Module_PathPlanningController_stm_ref5_t,
						    const_Module_PathPlanningController_stm_ref5_acc_distance,
						    const_Module_PathPlanningController_stm_ref6_kp,
						    const_Module_PathPlanningController_stm_ref6_ki,
						    const_Module_PathPlanningController_stm_ref6_kd,
						    const_Module_PathPlanningController_stm_ref6_step,
						    const_Module_PathPlanningController_stm_ref7_kp,
						    const_Module_PathPlanningController_stm_ref7_ki,
						    const_Module_PathPlanningController_stm_ref7_kd,
						    const_Module_PathPlanningController_stm_ref7_step,
						    const_Module_PathPlanningController_stm_ref8_step,
						    const_Module_PathPlanningController_stm_ref8_climb_speed,
						    const_Module_PathPlanningController_stm_ref8_descent_speed,
						    const_Module_PathPlanningController_stm_ref8_side_speed,
						    const_Module_PathPlanningController_stm_ref8_forward_angle,
						    const_Module_PathPlanningController_stm_ref8_left_angle,
						    const_Module_PathPlanningController_stm_ref8_right_angle,
						    const_Module_PathPlanningController_stm_ref8_turn_speed,
						    const_Module_PathPlanningController_stm_ref8_movesp,
						    const_Module_PathPlanningController_stm_ref8_stopsp) = 	((
						(
							let
								const_PathPlanningSM_cliff = const_Module_PathPlanningController_stm_ref0_cliff
								const_PathPlanningSM_nozzle = const_Module_PathPlanningController_stm_ref0_nozzle
								const_PathPlanningSM_battery_low = const_Module_PathPlanningController_stm_ref0_battery_low
								const_PathPlanningSM_sleep_time = const_Module_PathPlanningController_stm_ref0_sleep_time
								const_PathPlanningSM_acc_distance = const_Module_PathPlanningController_stm_ref0_acc_distance
							within 
							stm_ref0::VS__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::displacement.in <- stm_ref3::displacement.out,
								stm_ref0::displacement.out <- stm_ref3::displacement.in,
								stm_ref0::ultrasonic <- ultrasonic,
								stm_ref0::battery_level <- battery_level,
								stm_ref0::charging <- charging
							]]
						)
							[|{|terminate, stm_ref0::clean, stm_ref3::displacement, stm_ref0::move_forward, stm_ref0::turn, stm_ref0::stop|}|]
						(
							(
								let
									const_SpeedSM_t = const_Module_PathPlanningController_stm_ref1_t
								within 
								stm_ref1::VS__(id__,
										    const_SpeedSM_t)[[
									stm_ref1::terminate <- terminate,
									stm_ref1::acc.in <- stm_ref10::output1.out,
									stm_ref1::acc.out <- stm_ref10::output1.in
								]]
							)
								[|{|terminate, stm_ref1::sp, stm_ref10::output1|}|]
							(
								(
									let
										const_SpeedSM_t = const_Module_PathPlanningController_stm_ref2_t
									within 
									stm_ref2::VS__(id__,
											    const_SpeedSM_t)[[
										stm_ref2::terminate <- terminate,
										stm_ref2::acc.in <- stm_ref11::output1.out,
										stm_ref2::acc.out <- stm_ref11::output1.in
									]]
								)
									[|{|terminate, stm_ref11::output1, stm_ref2::sp|}|]
								(
									(
										let
											const_DisplacementSM_t = const_Module_PathPlanningController_stm_ref3_t
										within 
										stm_ref3::VS__(id__,
												    const_DisplacementSM_t)[[
											stm_ref3::terminate <- terminate,
											stm_ref3::sp.in <- stm_ref12::output1.out,
											stm_ref3::sp.out <- stm_ref12::output1.in
										]]
									)
										[|{|terminate, stm_ref12::output1|}|]
									(
										(
											let
												const_CleanSM_voltage = const_Module_PathPlanningController_stm_ref4_voltage
											within 
											stm_ref4::VS__(id__,
													    const_CleanSM_voltage)[[
												stm_ref4::terminate <- terminate,
												stm_ref4::clean.in <- stm_ref0::clean.out,
												stm_ref4::clean.out <- stm_ref0::clean.in,
												stm_ref4::brushCall <- brushCall,
												stm_ref4::vacuumCall <- vacuumCall
											]]
										)
											[|{|terminate|}|]
										(
											(
												let
													const_AngularSpeedSM_t = const_Module_PathPlanningController_stm_ref5_t
													const_AngularSpeedSM_acc_distance = const_Module_PathPlanningController_stm_ref5_acc_distance
												within 
												stm_ref5::VS__(id__,
														    const_AngularSpeedSM_t,
														    const_AngularSpeedSM_acc_distance)[[
													stm_ref5::terminate <- terminate,
													stm_ref5::acc_l.in <- stm_ref10::output2.out,
													stm_ref5::acc_l.out <- stm_ref10::output2.in,
													stm_ref5::acc_r.in <- stm_ref11::output2.out,
													stm_ref5::acc_r.out <- stm_ref11::output2.in
												]]
											)
												[|{|terminate, stm_ref5::angle, stm_ref10::output2, stm_ref11::output2|}|]
											(
												(
													let
														const_PID_kp = const_Module_PathPlanningController_stm_ref6_kp
														const_PID_ki = const_Module_PathPlanningController_stm_ref6_ki
														const_PID_kd = const_Module_PathPlanningController_stm_ref6_kd
														const_PID_step = const_Module_PathPlanningController_stm_ref6_step
													within 
													stm_ref6::VS__(id__,
															    const_PID_kp,
															    const_PID_ki,
															    const_PID_kd,
															    const_PID_step)[[
														stm_ref6::terminate <- terminate,
														stm_ref6::target.in <- stm_ref8::target_angle.out,
														stm_ref6::target.out <- stm_ref8::target_angle.in,
														stm_ref6::actual.in <- stm_ref5::angle.out,
														stm_ref6::actual.out <- stm_ref5::angle.in
													]]
												)
													[|{|terminate, stm_ref8::target_angle, stm_ref6::err_output|}|]
												(
													(
														let
															const_PID_kp = const_Module_PathPlanningController_stm_ref7_kp
															const_PID_ki = const_Module_PathPlanningController_stm_ref7_ki
															const_PID_kd = const_Module_PathPlanningController_stm_ref7_kd
															const_PID_step = const_Module_PathPlanningController_stm_ref7_step
														within 
														stm_ref7::VS__(id__,
																    const_PID_kp,
																    const_PID_ki,
																    const_PID_kd,
																    const_PID_step)[[
															stm_ref7::terminate <- terminate,
															stm_ref7::target.in <- stm_ref8::target_speed.out,
															stm_ref7::target.out <- stm_ref8::target_speed.in,
															stm_ref7::actual.in <- stm_ref9::linear_speed.out,
															stm_ref7::actual.out <- stm_ref9::linear_speed.in
														]]
													)
														[|{|terminate, stm_ref8::target_speed, stm_ref7::err_output, stm_ref9::linear_speed|}|]
													(
														(
															let
																const_MidLevelSM_step = const_Module_PathPlanningController_stm_ref8_step
																const_MidLevelSM_climb_speed = const_Module_PathPlanningController_stm_ref8_climb_speed
																const_MidLevelSM_descent_speed = const_Module_PathPlanningController_stm_ref8_descent_speed
																const_MidLevelSM_side_speed = const_Module_PathPlanningController_stm_ref8_side_speed
																const_MidLevelSM_forward_angle = const_Module_PathPlanningController_stm_ref8_forward_angle
																const_MidLevelSM_left_angle = const_Module_PathPlanningController_stm_ref8_left_angle
																const_MidLevelSM_right_angle = const_Module_PathPlanningController_stm_ref8_right_angle
																const_MidLevelSM_turn_speed = const_Module_PathPlanningController_stm_ref8_turn_speed
																const_MidLevelSM_movesp = const_Module_PathPlanningController_stm_ref8_movesp
																const_MidLevelSM_stopsp = const_Module_PathPlanningController_stm_ref8_stopsp
															within 
															stm_ref8::VS__(id__,
																	    const_MidLevelSM_step,
																	    const_MidLevelSM_climb_speed,
																	    const_MidLevelSM_descent_speed,
																	    const_MidLevelSM_side_speed,
																	    const_MidLevelSM_forward_angle,
																	    const_MidLevelSM_left_angle,
																	    const_MidLevelSM_right_angle,
																	    const_MidLevelSM_turn_speed,
																	    const_MidLevelSM_movesp,
																	    const_MidLevelSM_stopsp)[[
																stm_ref8::terminate <- terminate,
																stm_ref8::speed_adjustment.in <- stm_ref7::err_output.out,
																stm_ref8::speed_adjustment.out <- stm_ref7::err_output.in,
																stm_ref8::angle_adjustment.in <- stm_ref6::err_output.out,
																stm_ref8::angle_adjustment.out <- stm_ref6::err_output.in,
																stm_ref8::move_forward.in <- stm_ref0::move_forward.out,
																stm_ref8::move_forward.out <- stm_ref0::move_forward.in,
																stm_ref8::turn.in <- stm_ref0::turn.out,
																stm_ref8::turn.out <- stm_ref0::turn.in,
																stm_ref8::stop.in <- stm_ref0::stop.out,
																stm_ref8::stop.out <- stm_ref0::stop.in,
																stm_ref8::output_left_motorCall <- output_left_motorCall,
																stm_ref8::output_right_motorCall <- output_right_motorCall
															]]
														)
															[|{|terminate|}|]
														(
															(
																stm_ref9::VS__(id__)[[
																	stm_ref9::terminate <- terminate,
																	stm_ref9::speed_l.in <- stm_ref1::sp.out,
																	stm_ref9::speed_l.out <- stm_ref1::sp.in,
																	stm_ref9::speed_r.in <- stm_ref12::output2.out,
																	stm_ref9::speed_r.out <- stm_ref12::output2.in
																]]
															)
																[|{|terminate, stm_ref12::output2|}|]
															(
																(
																	stm_ref10::VS__(id__)[[
																		stm_ref10::terminate <- terminate,
																		stm_ref10::input <- acc_l
																	]]
																)
																	[|{|terminate|}|]
																(
																	(
																		stm_ref11::VS__(id__)[[
																			stm_ref11::terminate <- terminate,
																			stm_ref11::input <- acc_r
																		]]
																	)
																		[|{|terminate|}|]
																	(
																		stm_ref12::VS__(id__)[[
																			stm_ref12::terminate <- terminate,
																			stm_ref12::input.in <- stm_ref2::sp.out,
																			stm_ref12::input.out <- stm_ref2::sp.in
																		]]
																	)
																)
																\diff(
																	{|terminate|},
																	{|terminate|}
																)
															)
															\diff(
																{|terminate|},
																{|terminate|}
															)
														)
														\diff(
															{|terminate, stm_ref12::output2|},
															{|terminate|}
														)
													)
													\diff(
														{|terminate|},
														{|terminate|}
													)
												)
												\diff(
													{|terminate, stm_ref8::target_speed, stm_ref7::err_output, stm_ref9::linear_speed|},
													{|terminate|}
												)
											)
											\diff(
												{|terminate, stm_ref8::target_angle, stm_ref6::err_output|},
												{|terminate|}
											)
										)
										\diff(
											{|terminate, stm_ref5::angle, stm_ref10::output2, stm_ref11::output2|},
											{|terminate|}
										)
									)
									\diff(
										{|terminate|},
										{|terminate|}
									)
								)
								\diff(
									{|terminate, stm_ref12::output1|},
									{|terminate|}
								)
							)
							\diff(
								{|terminate, stm_ref11::output1, stm_ref2::sp|},
								{|terminate|}
							)
						)
						\diff(
							{|terminate, stm_ref1::sp, stm_ref10::output1|},
							{|terminate|}
						)
					)
					\diff(
						{|terminate, stm_ref0::clean, stm_ref3::displacement, stm_ref0::move_forward, stm_ref0::turn, stm_ref0::stop|},
						{|terminate|}
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
			
				-- O version (optimised) THESE TWO PROCESSES SHOULD BE KEPT IN SYNC WITH THE ABOVE TWO
				O__(id__,
						    const_Module_PathPlanningController_stm_ref0_cliff,
						    const_Module_PathPlanningController_stm_ref0_nozzle,
						    const_Module_PathPlanningController_stm_ref0_battery_low,
						    const_Module_PathPlanningController_stm_ref0_sleep_time,
						    const_Module_PathPlanningController_stm_ref0_acc_distance,
						    const_Module_PathPlanningController_stm_ref1_t,
						    const_Module_PathPlanningController_stm_ref2_t,
						    const_Module_PathPlanningController_stm_ref3_t,
						    const_Module_PathPlanningController_stm_ref4_voltage,
						    const_Module_PathPlanningController_stm_ref5_t,
						    const_Module_PathPlanningController_stm_ref5_acc_distance,
						    const_Module_PathPlanningController_stm_ref6_kp,
						    const_Module_PathPlanningController_stm_ref6_ki,
						    const_Module_PathPlanningController_stm_ref6_kd,
						    const_Module_PathPlanningController_stm_ref6_step,
						    const_Module_PathPlanningController_stm_ref7_kp,
						    const_Module_PathPlanningController_stm_ref7_ki,
						    const_Module_PathPlanningController_stm_ref7_kd,
						    const_Module_PathPlanningController_stm_ref7_step,
						    const_Module_PathPlanningController_stm_ref8_step,
						    const_Module_PathPlanningController_stm_ref8_climb_speed,
						    const_Module_PathPlanningController_stm_ref8_descent_speed,
						    const_Module_PathPlanningController_stm_ref8_side_speed,
						    const_Module_PathPlanningController_stm_ref8_forward_angle,
						    const_Module_PathPlanningController_stm_ref8_left_angle,
						    const_Module_PathPlanningController_stm_ref8_right_angle,
						    const_Module_PathPlanningController_stm_ref8_turn_speed,
						    const_Module_PathPlanningController_stm_ref8_movesp,
						    const_Module_PathPlanningController_stm_ref8_stopsp) = sbisim(diamond(	((
						(
							let
								const_PathPlanningSM_cliff = const_Module_PathPlanningController_stm_ref0_cliff
								const_PathPlanningSM_nozzle = const_Module_PathPlanningController_stm_ref0_nozzle
								const_PathPlanningSM_battery_low = const_Module_PathPlanningController_stm_ref0_battery_low
								const_PathPlanningSM_sleep_time = const_Module_PathPlanningController_stm_ref0_sleep_time
								const_PathPlanningSM_acc_distance = const_Module_PathPlanningController_stm_ref0_acc_distance
							within 
							stm_ref0::O__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::displacement.in <- stm_ref3::displacement.out,
								stm_ref0::displacement.out <- stm_ref3::displacement.in,
								stm_ref0::ultrasonic <- ultrasonic,
								stm_ref0::battery_level <- battery_level,
								stm_ref0::charging <- charging
							]]
						)
							[|{|terminate, stm_ref0::clean, stm_ref3::displacement, stm_ref0::move_forward, stm_ref0::turn, stm_ref0::stop|}|]
						(
							(
								let
									const_SpeedSM_t = const_Module_PathPlanningController_stm_ref1_t
								within 
								stm_ref1::O__(id__,
										    const_SpeedSM_t)[[
									stm_ref1::terminate <- terminate,
									stm_ref1::acc.in <- stm_ref10::output1.out,
									stm_ref1::acc.out <- stm_ref10::output1.in
								]]
							)
								[|{|terminate, stm_ref1::sp, stm_ref10::output1|}|]
							(
								(
									let
										const_SpeedSM_t = const_Module_PathPlanningController_stm_ref2_t
									within 
									stm_ref2::O__(id__,
											    const_SpeedSM_t)[[
										stm_ref2::terminate <- terminate,
										stm_ref2::acc.in <- stm_ref11::output1.out,
										stm_ref2::acc.out <- stm_ref11::output1.in
									]]
								)
									[|{|terminate, stm_ref11::output1, stm_ref2::sp|}|]
								(
									(
										let
											const_DisplacementSM_t = const_Module_PathPlanningController_stm_ref3_t
										within 
										stm_ref3::O__(id__,
												    const_DisplacementSM_t)[[
											stm_ref3::terminate <- terminate,
											stm_ref3::sp.in <- stm_ref12::output1.out,
											stm_ref3::sp.out <- stm_ref12::output1.in
										]]
									)
										[|{|terminate, stm_ref12::output1|}|]
									(
										(
											let
												const_CleanSM_voltage = const_Module_PathPlanningController_stm_ref4_voltage
											within 
											stm_ref4::O__(id__,
													    const_CleanSM_voltage)[[
												stm_ref4::terminate <- terminate,
												stm_ref4::clean.in <- stm_ref0::clean.out,
												stm_ref4::clean.out <- stm_ref0::clean.in,
												stm_ref4::brushCall <- brushCall,
												stm_ref4::vacuumCall <- vacuumCall
											]]
										)
											[|{|terminate|}|]
										(
											(
												let
													const_AngularSpeedSM_t = const_Module_PathPlanningController_stm_ref5_t
													const_AngularSpeedSM_acc_distance = const_Module_PathPlanningController_stm_ref5_acc_distance
												within 
												stm_ref5::O__(id__,
														    const_AngularSpeedSM_t,
														    const_AngularSpeedSM_acc_distance)[[
													stm_ref5::terminate <- terminate,
													stm_ref5::acc_l.in <- stm_ref10::output2.out,
													stm_ref5::acc_l.out <- stm_ref10::output2.in,
													stm_ref5::acc_r.in <- stm_ref11::output2.out,
													stm_ref5::acc_r.out <- stm_ref11::output2.in
												]]
											)
												[|{|terminate, stm_ref5::angle, stm_ref10::output2, stm_ref11::output2|}|]
											(
												(
													let
														const_PID_kp = const_Module_PathPlanningController_stm_ref6_kp
														const_PID_ki = const_Module_PathPlanningController_stm_ref6_ki
														const_PID_kd = const_Module_PathPlanningController_stm_ref6_kd
														const_PID_step = const_Module_PathPlanningController_stm_ref6_step
													within 
													stm_ref6::O__(id__,
															    const_PID_kp,
															    const_PID_ki,
															    const_PID_kd,
															    const_PID_step)[[
														stm_ref6::terminate <- terminate,
														stm_ref6::target.in <- stm_ref8::target_angle.out,
														stm_ref6::target.out <- stm_ref8::target_angle.in,
														stm_ref6::actual.in <- stm_ref5::angle.out,
														stm_ref6::actual.out <- stm_ref5::angle.in
													]]
												)
													[|{|terminate, stm_ref8::target_angle, stm_ref6::err_output|}|]
												(
													(
														let
															const_PID_kp = const_Module_PathPlanningController_stm_ref7_kp
															const_PID_ki = const_Module_PathPlanningController_stm_ref7_ki
															const_PID_kd = const_Module_PathPlanningController_stm_ref7_kd
															const_PID_step = const_Module_PathPlanningController_stm_ref7_step
														within 
														stm_ref7::O__(id__,
																    const_PID_kp,
																    const_PID_ki,
																    const_PID_kd,
																    const_PID_step)[[
															stm_ref7::terminate <- terminate,
															stm_ref7::target.in <- stm_ref8::target_speed.out,
															stm_ref7::target.out <- stm_ref8::target_speed.in,
															stm_ref7::actual.in <- stm_ref9::linear_speed.out,
															stm_ref7::actual.out <- stm_ref9::linear_speed.in
														]]
													)
														[|{|terminate, stm_ref8::target_speed, stm_ref7::err_output, stm_ref9::linear_speed|}|]
													(
														(
															let
																const_MidLevelSM_step = const_Module_PathPlanningController_stm_ref8_step
																const_MidLevelSM_climb_speed = const_Module_PathPlanningController_stm_ref8_climb_speed
																const_MidLevelSM_descent_speed = const_Module_PathPlanningController_stm_ref8_descent_speed
																const_MidLevelSM_side_speed = const_Module_PathPlanningController_stm_ref8_side_speed
																const_MidLevelSM_forward_angle = const_Module_PathPlanningController_stm_ref8_forward_angle
																const_MidLevelSM_left_angle = const_Module_PathPlanningController_stm_ref8_left_angle
																const_MidLevelSM_right_angle = const_Module_PathPlanningController_stm_ref8_right_angle
																const_MidLevelSM_turn_speed = const_Module_PathPlanningController_stm_ref8_turn_speed
																const_MidLevelSM_movesp = const_Module_PathPlanningController_stm_ref8_movesp
																const_MidLevelSM_stopsp = const_Module_PathPlanningController_stm_ref8_stopsp
															within 
															stm_ref8::O__(id__,
																	    const_MidLevelSM_step,
																	    const_MidLevelSM_climb_speed,
																	    const_MidLevelSM_descent_speed,
																	    const_MidLevelSM_side_speed,
																	    const_MidLevelSM_forward_angle,
																	    const_MidLevelSM_left_angle,
																	    const_MidLevelSM_right_angle,
																	    const_MidLevelSM_turn_speed,
																	    const_MidLevelSM_movesp,
																	    const_MidLevelSM_stopsp)[[
																stm_ref8::terminate <- terminate,
																stm_ref8::speed_adjustment.in <- stm_ref7::err_output.out,
																stm_ref8::speed_adjustment.out <- stm_ref7::err_output.in,
																stm_ref8::angle_adjustment.in <- stm_ref6::err_output.out,
																stm_ref8::angle_adjustment.out <- stm_ref6::err_output.in,
																stm_ref8::move_forward.in <- stm_ref0::move_forward.out,
																stm_ref8::move_forward.out <- stm_ref0::move_forward.in,
																stm_ref8::turn.in <- stm_ref0::turn.out,
																stm_ref8::turn.out <- stm_ref0::turn.in,
																stm_ref8::stop.in <- stm_ref0::stop.out,
																stm_ref8::stop.out <- stm_ref0::stop.in,
																stm_ref8::output_left_motorCall <- output_left_motorCall,
																stm_ref8::output_right_motorCall <- output_right_motorCall
															]]
														)
															[|{|terminate|}|]
														(
															(
																stm_ref9::O__(id__)[[
																	stm_ref9::terminate <- terminate,
																	stm_ref9::speed_l.in <- stm_ref1::sp.out,
																	stm_ref9::speed_l.out <- stm_ref1::sp.in,
																	stm_ref9::speed_r.in <- stm_ref12::output2.out,
																	stm_ref9::speed_r.out <- stm_ref12::output2.in
																]]
															)
																[|{|terminate, stm_ref12::output2|}|]
															(
																(
																	stm_ref10::O__(id__)[[
																		stm_ref10::terminate <- terminate,
																		stm_ref10::input <- acc_l
																	]]
																)
																	[|{|terminate|}|]
																(
																	(
																		stm_ref11::O__(id__)[[
																			stm_ref11::terminate <- terminate,
																			stm_ref11::input <- acc_r
																		]]
																	)
																		[|{|terminate|}|]
																	(
																		stm_ref12::O__(id__)[[
																			stm_ref12::terminate <- terminate,
																			stm_ref12::input.in <- stm_ref2::sp.out,
																			stm_ref12::input.out <- stm_ref2::sp.in
																		]]
																	)
																)
																\diff(
																	{|terminate|},
																	{|terminate|}
																)
															)
															\diff(
																{|terminate|},
																{|terminate|}
															)
														)
														\diff(
															{|terminate, stm_ref12::output2|},
															{|terminate|}
														)
													)
													\diff(
														{|terminate|},
														{|terminate|}
													)
												)
												\diff(
													{|terminate, stm_ref8::target_speed, stm_ref7::err_output, stm_ref9::linear_speed|},
													{|terminate|}
												)
											)
											\diff(
												{|terminate, stm_ref8::target_angle, stm_ref6::err_output|},
												{|terminate|}
											)
										)
										\diff(
											{|terminate, stm_ref5::angle, stm_ref10::output2, stm_ref11::output2|},
											{|terminate|}
										)
									)
									\diff(
										{|terminate|},
										{|terminate|}
									)
								)
								\diff(
									{|terminate, stm_ref12::output1|},
									{|terminate|}
								)
							)
							\diff(
								{|terminate, stm_ref11::output1, stm_ref2::sp|},
								{|terminate|}
							)
						)
						\diff(
							{|terminate, stm_ref1::sp, stm_ref10::output1|},
							{|terminate|}
						)
					)
					\diff(
						{|terminate, stm_ref0::clean, stm_ref3::displacement, stm_ref0::move_forward, stm_ref0::turn, stm_ref0::stop|},
						{|terminate|}
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					dbisim(Memory(id__))
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				))
								
				-- VS_O version
				VS_O__(id__,
						    const_Module_PathPlanningController_stm_ref0_cliff,
						    const_Module_PathPlanningController_stm_ref0_nozzle,
						    const_Module_PathPlanningController_stm_ref0_battery_low,
						    const_Module_PathPlanningController_stm_ref0_sleep_time,
						    const_Module_PathPlanningController_stm_ref0_acc_distance,
						    const_Module_PathPlanningController_stm_ref1_t,
						    const_Module_PathPlanningController_stm_ref2_t,
						    const_Module_PathPlanningController_stm_ref3_t,
						    const_Module_PathPlanningController_stm_ref4_voltage,
						    const_Module_PathPlanningController_stm_ref5_t,
						    const_Module_PathPlanningController_stm_ref5_acc_distance,
						    const_Module_PathPlanningController_stm_ref6_kp,
						    const_Module_PathPlanningController_stm_ref6_ki,
						    const_Module_PathPlanningController_stm_ref6_kd,
						    const_Module_PathPlanningController_stm_ref6_step,
						    const_Module_PathPlanningController_stm_ref7_kp,
						    const_Module_PathPlanningController_stm_ref7_ki,
						    const_Module_PathPlanningController_stm_ref7_kd,
						    const_Module_PathPlanningController_stm_ref7_step,
						    const_Module_PathPlanningController_stm_ref8_step,
						    const_Module_PathPlanningController_stm_ref8_climb_speed,
						    const_Module_PathPlanningController_stm_ref8_descent_speed,
						    const_Module_PathPlanningController_stm_ref8_side_speed,
						    const_Module_PathPlanningController_stm_ref8_forward_angle,
						    const_Module_PathPlanningController_stm_ref8_left_angle,
						    const_Module_PathPlanningController_stm_ref8_right_angle,
						    const_Module_PathPlanningController_stm_ref8_turn_speed,
						    const_Module_PathPlanningController_stm_ref8_movesp,
						    const_Module_PathPlanningController_stm_ref8_stopsp) = sbisim(diamond(	((
						(
							let
								const_PathPlanningSM_cliff = const_Module_PathPlanningController_stm_ref0_cliff
								const_PathPlanningSM_nozzle = const_Module_PathPlanningController_stm_ref0_nozzle
								const_PathPlanningSM_battery_low = const_Module_PathPlanningController_stm_ref0_battery_low
								const_PathPlanningSM_sleep_time = const_Module_PathPlanningController_stm_ref0_sleep_time
								const_PathPlanningSM_acc_distance = const_Module_PathPlanningController_stm_ref0_acc_distance
							within 
							stm_ref0::VS_O__(id__,
									    const_PathPlanningSM_cliff,
									    const_PathPlanningSM_nozzle,
									    const_PathPlanningSM_battery_low,
									    const_PathPlanningSM_sleep_time,
									    const_PathPlanningSM_acc_distance)[[
								stm_ref0::terminate <- terminate,
								stm_ref0::displacement.in <- stm_ref3::displacement.out,
								stm_ref0::displacement.out <- stm_ref3::displacement.in,
								stm_ref0::ultrasonic <- ultrasonic,
								stm_ref0::battery_level <- battery_level,
								stm_ref0::charging <- charging
							]]
						)
							[|{|terminate, stm_ref0::clean, stm_ref3::displacement, stm_ref0::move_forward, stm_ref0::turn, stm_ref0::stop|}|]
						(
							(
								let
									const_SpeedSM_t = const_Module_PathPlanningController_stm_ref1_t
								within 
								stm_ref1::VS_O__(id__,
										    const_SpeedSM_t)[[
									stm_ref1::terminate <- terminate,
									stm_ref1::acc.in <- stm_ref10::output1.out,
									stm_ref1::acc.out <- stm_ref10::output1.in
								]]
							)
								[|{|terminate, stm_ref1::sp, stm_ref10::output1|}|]
							(
								(
									let
										const_SpeedSM_t = const_Module_PathPlanningController_stm_ref2_t
									within 
									stm_ref2::VS_O__(id__,
											    const_SpeedSM_t)[[
										stm_ref2::terminate <- terminate,
										stm_ref2::acc.in <- stm_ref11::output1.out,
										stm_ref2::acc.out <- stm_ref11::output1.in
									]]
								)
									[|{|terminate, stm_ref11::output1, stm_ref2::sp|}|]
								(
									(
										let
											const_DisplacementSM_t = const_Module_PathPlanningController_stm_ref3_t
										within 
										stm_ref3::VS_O__(id__,
												    const_DisplacementSM_t)[[
											stm_ref3::terminate <- terminate,
											stm_ref3::sp.in <- stm_ref12::output1.out,
											stm_ref3::sp.out <- stm_ref12::output1.in
										]]
									)
										[|{|terminate, stm_ref12::output1|}|]
									(
										(
											let
												const_CleanSM_voltage = const_Module_PathPlanningController_stm_ref4_voltage
											within 
											stm_ref4::VS_O__(id__,
													    const_CleanSM_voltage)[[
												stm_ref4::terminate <- terminate,
												stm_ref4::clean.in <- stm_ref0::clean.out,
												stm_ref4::clean.out <- stm_ref0::clean.in,
												stm_ref4::brushCall <- brushCall,
												stm_ref4::vacuumCall <- vacuumCall
											]]
										)
											[|{|terminate|}|]
										(
											(
												let
													const_AngularSpeedSM_t = const_Module_PathPlanningController_stm_ref5_t
													const_AngularSpeedSM_acc_distance = const_Module_PathPlanningController_stm_ref5_acc_distance
												within 
												stm_ref5::VS_O__(id__,
														    const_AngularSpeedSM_t,
														    const_AngularSpeedSM_acc_distance)[[
													stm_ref5::terminate <- terminate,
													stm_ref5::acc_l.in <- stm_ref10::output2.out,
													stm_ref5::acc_l.out <- stm_ref10::output2.in,
													stm_ref5::acc_r.in <- stm_ref11::output2.out,
													stm_ref5::acc_r.out <- stm_ref11::output2.in
												]]
											)
												[|{|terminate, stm_ref5::angle, stm_ref10::output2, stm_ref11::output2|}|]
											(
												(
													let
														const_PID_kp = const_Module_PathPlanningController_stm_ref6_kp
														const_PID_ki = const_Module_PathPlanningController_stm_ref6_ki
														const_PID_kd = const_Module_PathPlanningController_stm_ref6_kd
														const_PID_step = const_Module_PathPlanningController_stm_ref6_step
													within 
													stm_ref6::VS_O__(id__,
															    const_PID_kp,
															    const_PID_ki,
															    const_PID_kd,
															    const_PID_step)[[
														stm_ref6::terminate <- terminate,
														stm_ref6::target.in <- stm_ref8::target_angle.out,
														stm_ref6::target.out <- stm_ref8::target_angle.in,
														stm_ref6::actual.in <- stm_ref5::angle.out,
														stm_ref6::actual.out <- stm_ref5::angle.in
													]]
												)
													[|{|terminate, stm_ref8::target_angle, stm_ref6::err_output|}|]
												(
													(
														let
															const_PID_kp = const_Module_PathPlanningController_stm_ref7_kp
															const_PID_ki = const_Module_PathPlanningController_stm_ref7_ki
															const_PID_kd = const_Module_PathPlanningController_stm_ref7_kd
															const_PID_step = const_Module_PathPlanningController_stm_ref7_step
														within 
														stm_ref7::VS_O__(id__,
																    const_PID_kp,
																    const_PID_ki,
																    const_PID_kd,
																    const_PID_step)[[
															stm_ref7::terminate <- terminate,
															stm_ref7::target.in <- stm_ref8::target_speed.out,
															stm_ref7::target.out <- stm_ref8::target_speed.in,
															stm_ref7::actual.in <- stm_ref9::linear_speed.out,
															stm_ref7::actual.out <- stm_ref9::linear_speed.in
														]]
													)
														[|{|terminate, stm_ref8::target_speed, stm_ref7::err_output, stm_ref9::linear_speed|}|]
													(
														(
															let
																const_MidLevelSM_step = const_Module_PathPlanningController_stm_ref8_step
																const_MidLevelSM_climb_speed = const_Module_PathPlanningController_stm_ref8_climb_speed
																const_MidLevelSM_descent_speed = const_Module_PathPlanningController_stm_ref8_descent_speed
																const_MidLevelSM_side_speed = const_Module_PathPlanningController_stm_ref8_side_speed
																const_MidLevelSM_forward_angle = const_Module_PathPlanningController_stm_ref8_forward_angle
																const_MidLevelSM_left_angle = const_Module_PathPlanningController_stm_ref8_left_angle
																const_MidLevelSM_right_angle = const_Module_PathPlanningController_stm_ref8_right_angle
																const_MidLevelSM_turn_speed = const_Module_PathPlanningController_stm_ref8_turn_speed
																const_MidLevelSM_movesp = const_Module_PathPlanningController_stm_ref8_movesp
																const_MidLevelSM_stopsp = const_Module_PathPlanningController_stm_ref8_stopsp
															within 
															stm_ref8::VS_O__(id__,
																	    const_MidLevelSM_step,
																	    const_MidLevelSM_climb_speed,
																	    const_MidLevelSM_descent_speed,
																	    const_MidLevelSM_side_speed,
																	    const_MidLevelSM_forward_angle,
																	    const_MidLevelSM_left_angle,
																	    const_MidLevelSM_right_angle,
																	    const_MidLevelSM_turn_speed,
																	    const_MidLevelSM_movesp,
																	    const_MidLevelSM_stopsp)[[
																stm_ref8::terminate <- terminate,
																stm_ref8::speed_adjustment.in <- stm_ref7::err_output.out,
																stm_ref8::speed_adjustment.out <- stm_ref7::err_output.in,
																stm_ref8::angle_adjustment.in <- stm_ref6::err_output.out,
																stm_ref8::angle_adjustment.out <- stm_ref6::err_output.in,
																stm_ref8::move_forward.in <- stm_ref0::move_forward.out,
																stm_ref8::move_forward.out <- stm_ref0::move_forward.in,
																stm_ref8::turn.in <- stm_ref0::turn.out,
																stm_ref8::turn.out <- stm_ref0::turn.in,
																stm_ref8::stop.in <- stm_ref0::stop.out,
																stm_ref8::stop.out <- stm_ref0::stop.in,
																stm_ref8::output_left_motorCall <- output_left_motorCall,
																stm_ref8::output_right_motorCall <- output_right_motorCall
															]]
														)
															[|{|terminate|}|]
														(
															(
																stm_ref9::VS_O__(id__)[[
																	stm_ref9::terminate <- terminate,
																	stm_ref9::speed_l.in <- stm_ref1::sp.out,
																	stm_ref9::speed_l.out <- stm_ref1::sp.in,
																	stm_ref9::speed_r.in <- stm_ref12::output2.out,
																	stm_ref9::speed_r.out <- stm_ref12::output2.in
																]]
															)
																[|{|terminate, stm_ref12::output2|}|]
															(
																(
																	stm_ref10::VS_O__(id__)[[
																		stm_ref10::terminate <- terminate,
																		stm_ref10::input <- acc_l
																	]]
																)
																	[|{|terminate|}|]
																(
																	(
																		stm_ref11::VS_O__(id__)[[
																			stm_ref11::terminate <- terminate,
																			stm_ref11::input <- acc_r
																		]]
																	)
																		[|{|terminate|}|]
																	(
																		stm_ref12::VS_O__(id__)[[
																			stm_ref12::terminate <- terminate,
																			stm_ref12::input.in <- stm_ref2::sp.out,
																			stm_ref12::input.out <- stm_ref2::sp.in
																		]]
																	)
																)
																\diff(
																	{|terminate|},
																	{|terminate|}
																)
															)
															\diff(
																{|terminate|},
																{|terminate|}
															)
														)
														\diff(
															{|terminate, stm_ref12::output2|},
															{|terminate|}
														)
													)
													\diff(
														{|terminate|},
														{|terminate|}
													)
												)
												\diff(
													{|terminate, stm_ref8::target_speed, stm_ref7::err_output, stm_ref9::linear_speed|},
													{|terminate|}
												)
											)
											\diff(
												{|terminate, stm_ref8::target_angle, stm_ref6::err_output|},
												{|terminate|}
											)
										)
										\diff(
											{|terminate, stm_ref5::angle, stm_ref10::output2, stm_ref11::output2|},
											{|terminate|}
										)
									)
									\diff(
										{|terminate|},
										{|terminate|}
									)
								)
								\diff(
									{|terminate, stm_ref12::output1|},
									{|terminate|}
								)
							)
							\diff(
								{|terminate, stm_ref11::output1, stm_ref2::sp|},
								{|terminate|}
							)
						)
						\diff(
							{|terminate, stm_ref1::sp, stm_ref10::output1|},
							{|terminate|}
						)
					)
					\diff(
						{|terminate, stm_ref0::clean, stm_ref3::displacement, stm_ref0::move_forward, stm_ref0::turn, stm_ref0::stop|},
						{|terminate|}
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					dbisim(Memory(id__))
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				))
			
				HEXT(id__,
						    const_Module_PathPlanningController_stm_ref0_cliff,
						    const_Module_PathPlanningController_stm_ref0_nozzle,
						    const_Module_PathPlanningController_stm_ref0_battery_low,
						    const_Module_PathPlanningController_stm_ref0_sleep_time,
						    const_Module_PathPlanningController_stm_ref0_acc_distance,
						    const_Module_PathPlanningController_stm_ref1_t,
						    const_Module_PathPlanningController_stm_ref2_t,
						    const_Module_PathPlanningController_stm_ref3_t,
						    const_Module_PathPlanningController_stm_ref4_voltage,
						    const_Module_PathPlanningController_stm_ref5_t,
						    const_Module_PathPlanningController_stm_ref5_acc_distance,
						    const_Module_PathPlanningController_stm_ref6_kp,
						    const_Module_PathPlanningController_stm_ref6_ki,
						    const_Module_PathPlanningController_stm_ref6_kd,
						    const_Module_PathPlanningController_stm_ref6_step,
						    const_Module_PathPlanningController_stm_ref7_kp,
						    const_Module_PathPlanningController_stm_ref7_ki,
						    const_Module_PathPlanningController_stm_ref7_kd,
						    const_Module_PathPlanningController_stm_ref7_step,
						    const_Module_PathPlanningController_stm_ref8_step,
						    const_Module_PathPlanningController_stm_ref8_climb_speed,
						    const_Module_PathPlanningController_stm_ref8_descent_speed,
						    const_Module_PathPlanningController_stm_ref8_side_speed,
						    const_Module_PathPlanningController_stm_ref8_forward_angle,
						    const_Module_PathPlanningController_stm_ref8_left_angle,
						    const_Module_PathPlanningController_stm_ref8_right_angle,
						    const_Module_PathPlanningController_stm_ref8_turn_speed,
						    const_Module_PathPlanningController_stm_ref8_movesp,
						    const_Module_PathPlanningController_stm_ref8_stopsp) = O__(id__,
						    const_Module_PathPlanningController_stm_ref0_cliff,
						    const_Module_PathPlanningController_stm_ref0_nozzle,
						    const_Module_PathPlanningController_stm_ref0_battery_low,
						    const_Module_PathPlanningController_stm_ref0_sleep_time,
						    const_Module_PathPlanningController_stm_ref0_acc_distance,
						    const_Module_PathPlanningController_stm_ref1_t,
						    const_Module_PathPlanningController_stm_ref2_t,
						    const_Module_PathPlanningController_stm_ref3_t,
						    const_Module_PathPlanningController_stm_ref4_voltage,
						    const_Module_PathPlanningController_stm_ref5_t,
						    const_Module_PathPlanningController_stm_ref5_acc_distance,
						    const_Module_PathPlanningController_stm_ref6_kp,
						    const_Module_PathPlanningController_stm_ref6_ki,
						    const_Module_PathPlanningController_stm_ref6_kd,
						    const_Module_PathPlanningController_stm_ref6_step,
						    const_Module_PathPlanningController_stm_ref7_kp,
						    const_Module_PathPlanningController_stm_ref7_ki,
						    const_Module_PathPlanningController_stm_ref7_kd,
						    const_Module_PathPlanningController_stm_ref7_step,
						    const_Module_PathPlanningController_stm_ref8_step,
						    const_Module_PathPlanningController_stm_ref8_climb_speed,
						    const_Module_PathPlanningController_stm_ref8_descent_speed,
						    const_Module_PathPlanningController_stm_ref8_side_speed,
						    const_Module_PathPlanningController_stm_ref8_forward_angle,
						    const_Module_PathPlanningController_stm_ref8_left_angle,
						    const_Module_PathPlanningController_stm_ref8_right_angle,
						    const_Module_PathPlanningController_stm_ref8_turn_speed,
						    const_Module_PathPlanningController_stm_ref8_movesp,
						    const_Module_PathPlanningController_stm_ref8_stopsp) [|shared_variable_events|] SKIP			
	
		endmodule
	
	-- declaring module memory
	Memory(id__) = SKIP
	
	D__(id__,
			    const_Module_PathPlanningController_stm_ref0_cliff,
			    const_Module_PathPlanningController_stm_ref0_nozzle,
			    const_Module_PathPlanningController_stm_ref0_battery_low,
			    const_Module_PathPlanningController_stm_ref0_sleep_time,
			    const_Module_PathPlanningController_stm_ref0_acc_distance,
			    const_Module_PathPlanningController_stm_ref1_t,
			    const_Module_PathPlanningController_stm_ref2_t,
			    const_Module_PathPlanningController_stm_ref3_t,
			    const_Module_PathPlanningController_stm_ref4_voltage,
			    const_Module_PathPlanningController_stm_ref5_t,
			    const_Module_PathPlanningController_stm_ref5_acc_distance,
			    const_Module_PathPlanningController_stm_ref6_kp,
			    const_Module_PathPlanningController_stm_ref6_ki,
			    const_Module_PathPlanningController_stm_ref6_kd,
			    const_Module_PathPlanningController_stm_ref6_step,
			    const_Module_PathPlanningController_stm_ref7_kp,
			    const_Module_PathPlanningController_stm_ref7_ki,
			    const_Module_PathPlanningController_stm_ref7_kd,
			    const_Module_PathPlanningController_stm_ref7_step,
			    const_Module_PathPlanningController_stm_ref8_step,
			    const_Module_PathPlanningController_stm_ref8_climb_speed,
			    const_Module_PathPlanningController_stm_ref8_descent_speed,
			    const_Module_PathPlanningController_stm_ref8_side_speed,
			    const_Module_PathPlanningController_stm_ref8_forward_angle,
			    const_Module_PathPlanningController_stm_ref8_left_angle,
			    const_Module_PathPlanningController_stm_ref8_right_angle,
			    const_Module_PathPlanningController_stm_ref8_turn_speed,
			    const_Module_PathPlanningController_stm_ref8_movesp,
			    const_Module_PathPlanningController_stm_ref8_stopsp) = 	(
			(
				(SKIP)
					[|{||}|]
				(
					(
						PathPlanningController::D__(id__,
								    const_Module_PathPlanningController_stm_ref0_cliff,
								    const_Module_PathPlanningController_stm_ref0_nozzle,
								    const_Module_PathPlanningController_stm_ref0_battery_low,
								    const_Module_PathPlanningController_stm_ref0_sleep_time,
								    const_Module_PathPlanningController_stm_ref0_acc_distance,
								    const_Module_PathPlanningController_stm_ref1_t,
								    const_Module_PathPlanningController_stm_ref2_t,
								    const_Module_PathPlanningController_stm_ref3_t,
								    const_Module_PathPlanningController_stm_ref4_voltage,
								    const_Module_PathPlanningController_stm_ref5_t,
								    const_Module_PathPlanningController_stm_ref5_acc_distance,
								    const_Module_PathPlanningController_stm_ref6_kp,
								    const_Module_PathPlanningController_stm_ref6_ki,
								    const_Module_PathPlanningController_stm_ref6_kd,
								    const_Module_PathPlanningController_stm_ref6_step,
								    const_Module_PathPlanningController_stm_ref7_kp,
								    const_Module_PathPlanningController_stm_ref7_ki,
								    const_Module_PathPlanningController_stm_ref7_kd,
								    const_Module_PathPlanningController_stm_ref7_step,
								    const_Module_PathPlanningController_stm_ref8_step,
								    const_Module_PathPlanningController_stm_ref8_climb_speed,
								    const_Module_PathPlanningController_stm_ref8_descent_speed,
								    const_Module_PathPlanningController_stm_ref8_side_speed,
								    const_Module_PathPlanningController_stm_ref8_forward_angle,
								    const_Module_PathPlanningController_stm_ref8_left_angle,
								    const_Module_PathPlanningController_stm_ref8_right_angle,
								    const_Module_PathPlanningController_stm_ref8_turn_speed,
								    const_Module_PathPlanningController_stm_ref8_movesp,
								    const_Module_PathPlanningController_stm_ref8_stopsp)[[
							PathPlanningController::terminate <- terminate,
							PathPlanningController::acc_l <- acc_l,
							PathPlanningController::acc_r <- acc_r,
							PathPlanningController::battery_level <- battery_level,
							PathPlanningController::charging <- charging,
							PathPlanningController::ultrasonic <- ultrasonic,
							PathPlanningController::brushCall <- brushCall,
							PathPlanningController::vacuumCall <- vacuumCall,
							PathPlanningController::output_left_motorCall <- output_left_motorCall,
							PathPlanningController::output_right_motorCall <- output_right_motorCall
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
			)
			\ Union({
				{|
				|},
				{|
				|},
				{|
				|}
			})
			[|{|terminate|}|>SKIP
		)
		\{|terminate|}
	
	-- visible state equivalent
	
	VS__(id__,
			    const_Module_PathPlanningController_stm_ref0_cliff,
			    const_Module_PathPlanningController_stm_ref0_nozzle,
			    const_Module_PathPlanningController_stm_ref0_battery_low,
			    const_Module_PathPlanningController_stm_ref0_sleep_time,
			    const_Module_PathPlanningController_stm_ref0_acc_distance,
			    const_Module_PathPlanningController_stm_ref1_t,
			    const_Module_PathPlanningController_stm_ref2_t,
			    const_Module_PathPlanningController_stm_ref3_t,
			    const_Module_PathPlanningController_stm_ref4_voltage,
			    const_Module_PathPlanningController_stm_ref5_t,
			    const_Module_PathPlanningController_stm_ref5_acc_distance,
			    const_Module_PathPlanningController_stm_ref6_kp,
			    const_Module_PathPlanningController_stm_ref6_ki,
			    const_Module_PathPlanningController_stm_ref6_kd,
			    const_Module_PathPlanningController_stm_ref6_step,
			    const_Module_PathPlanningController_stm_ref7_kp,
			    const_Module_PathPlanningController_stm_ref7_ki,
			    const_Module_PathPlanningController_stm_ref7_kd,
			    const_Module_PathPlanningController_stm_ref7_step,
			    const_Module_PathPlanningController_stm_ref8_step,
			    const_Module_PathPlanningController_stm_ref8_climb_speed,
			    const_Module_PathPlanningController_stm_ref8_descent_speed,
			    const_Module_PathPlanningController_stm_ref8_side_speed,
			    const_Module_PathPlanningController_stm_ref8_forward_angle,
			    const_Module_PathPlanningController_stm_ref8_left_angle,
			    const_Module_PathPlanningController_stm_ref8_right_angle,
			    const_Module_PathPlanningController_stm_ref8_turn_speed,
			    const_Module_PathPlanningController_stm_ref8_movesp,
			    const_Module_PathPlanningController_stm_ref8_stopsp) = 	(
			(
				(SKIP)
					[|{||}|]
				(
					(
						PathPlanningController::VS__(id__,
								    const_Module_PathPlanningController_stm_ref0_cliff,
								    const_Module_PathPlanningController_stm_ref0_nozzle,
								    const_Module_PathPlanningController_stm_ref0_battery_low,
								    const_Module_PathPlanningController_stm_ref0_sleep_time,
								    const_Module_PathPlanningController_stm_ref0_acc_distance,
								    const_Module_PathPlanningController_stm_ref1_t,
								    const_Module_PathPlanningController_stm_ref2_t,
								    const_Module_PathPlanningController_stm_ref3_t,
								    const_Module_PathPlanningController_stm_ref4_voltage,
								    const_Module_PathPlanningController_stm_ref5_t,
								    const_Module_PathPlanningController_stm_ref5_acc_distance,
								    const_Module_PathPlanningController_stm_ref6_kp,
								    const_Module_PathPlanningController_stm_ref6_ki,
								    const_Module_PathPlanningController_stm_ref6_kd,
								    const_Module_PathPlanningController_stm_ref6_step,
								    const_Module_PathPlanningController_stm_ref7_kp,
								    const_Module_PathPlanningController_stm_ref7_ki,
								    const_Module_PathPlanningController_stm_ref7_kd,
								    const_Module_PathPlanningController_stm_ref7_step,
								    const_Module_PathPlanningController_stm_ref8_step,
								    const_Module_PathPlanningController_stm_ref8_climb_speed,
								    const_Module_PathPlanningController_stm_ref8_descent_speed,
								    const_Module_PathPlanningController_stm_ref8_side_speed,
								    const_Module_PathPlanningController_stm_ref8_forward_angle,
								    const_Module_PathPlanningController_stm_ref8_left_angle,
								    const_Module_PathPlanningController_stm_ref8_right_angle,
								    const_Module_PathPlanningController_stm_ref8_turn_speed,
								    const_Module_PathPlanningController_stm_ref8_movesp,
								    const_Module_PathPlanningController_stm_ref8_stopsp)[[
							PathPlanningController::terminate <- terminate,
							PathPlanningController::acc_l <- acc_l,
							PathPlanningController::acc_r <- acc_r,
							PathPlanningController::battery_level <- battery_level,
							PathPlanningController::charging <- charging,
							PathPlanningController::ultrasonic <- ultrasonic,
							PathPlanningController::brushCall <- brushCall,
							PathPlanningController::vacuumCall <- vacuumCall,
							PathPlanningController::output_left_motorCall <- output_left_motorCall,
							PathPlanningController::output_right_motorCall <- output_right_motorCall
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
			)
			\ Union({
				{|
				|},
				{|
				|},
				{|
				|}
			})
			[|{|terminate|}|>SKIP
		)
		\{|terminate|}
	
	-- O version (optimised)
	
	O__(id__,
			    const_Module_PathPlanningController_stm_ref0_cliff,
			    const_Module_PathPlanningController_stm_ref0_nozzle,
			    const_Module_PathPlanningController_stm_ref0_battery_low,
			    const_Module_PathPlanningController_stm_ref0_sleep_time,
			    const_Module_PathPlanningController_stm_ref0_acc_distance,
			    const_Module_PathPlanningController_stm_ref1_t,
			    const_Module_PathPlanningController_stm_ref2_t,
			    const_Module_PathPlanningController_stm_ref3_t,
			    const_Module_PathPlanningController_stm_ref4_voltage,
			    const_Module_PathPlanningController_stm_ref5_t,
			    const_Module_PathPlanningController_stm_ref5_acc_distance,
			    const_Module_PathPlanningController_stm_ref6_kp,
			    const_Module_PathPlanningController_stm_ref6_ki,
			    const_Module_PathPlanningController_stm_ref6_kd,
			    const_Module_PathPlanningController_stm_ref6_step,
			    const_Module_PathPlanningController_stm_ref7_kp,
			    const_Module_PathPlanningController_stm_ref7_ki,
			    const_Module_PathPlanningController_stm_ref7_kd,
			    const_Module_PathPlanningController_stm_ref7_step,
			    const_Module_PathPlanningController_stm_ref8_step,
			    const_Module_PathPlanningController_stm_ref8_climb_speed,
			    const_Module_PathPlanningController_stm_ref8_descent_speed,
			    const_Module_PathPlanningController_stm_ref8_side_speed,
			    const_Module_PathPlanningController_stm_ref8_forward_angle,
			    const_Module_PathPlanningController_stm_ref8_left_angle,
			    const_Module_PathPlanningController_stm_ref8_right_angle,
			    const_Module_PathPlanningController_stm_ref8_turn_speed,
			    const_Module_PathPlanningController_stm_ref8_movesp,
			    const_Module_PathPlanningController_stm_ref8_stopsp) = sbisim(diamond(	(
			(
				(SKIP)
					[|{||}|]
				(
					(
						PathPlanningController::O__(id__,
								    const_Module_PathPlanningController_stm_ref0_cliff,
								    const_Module_PathPlanningController_stm_ref0_nozzle,
								    const_Module_PathPlanningController_stm_ref0_battery_low,
								    const_Module_PathPlanningController_stm_ref0_sleep_time,
								    const_Module_PathPlanningController_stm_ref0_acc_distance,
								    const_Module_PathPlanningController_stm_ref1_t,
								    const_Module_PathPlanningController_stm_ref2_t,
								    const_Module_PathPlanningController_stm_ref3_t,
								    const_Module_PathPlanningController_stm_ref4_voltage,
								    const_Module_PathPlanningController_stm_ref5_t,
								    const_Module_PathPlanningController_stm_ref5_acc_distance,
								    const_Module_PathPlanningController_stm_ref6_kp,
								    const_Module_PathPlanningController_stm_ref6_ki,
								    const_Module_PathPlanningController_stm_ref6_kd,
								    const_Module_PathPlanningController_stm_ref6_step,
								    const_Module_PathPlanningController_stm_ref7_kp,
								    const_Module_PathPlanningController_stm_ref7_ki,
								    const_Module_PathPlanningController_stm_ref7_kd,
								    const_Module_PathPlanningController_stm_ref7_step,
								    const_Module_PathPlanningController_stm_ref8_step,
								    const_Module_PathPlanningController_stm_ref8_climb_speed,
								    const_Module_PathPlanningController_stm_ref8_descent_speed,
								    const_Module_PathPlanningController_stm_ref8_side_speed,
								    const_Module_PathPlanningController_stm_ref8_forward_angle,
								    const_Module_PathPlanningController_stm_ref8_left_angle,
								    const_Module_PathPlanningController_stm_ref8_right_angle,
								    const_Module_PathPlanningController_stm_ref8_turn_speed,
								    const_Module_PathPlanningController_stm_ref8_movesp,
								    const_Module_PathPlanningController_stm_ref8_stopsp)[[
							PathPlanningController::terminate <- terminate,
							PathPlanningController::acc_l <- acc_l,
							PathPlanningController::acc_r <- acc_r,
							PathPlanningController::battery_level <- battery_level,
							PathPlanningController::charging <- charging,
							PathPlanningController::ultrasonic <- ultrasonic,
							PathPlanningController::brushCall <- brushCall,
							PathPlanningController::vacuumCall <- vacuumCall,
							PathPlanningController::output_left_motorCall <- output_left_motorCall,
							PathPlanningController::output_right_motorCall <- output_right_motorCall
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					dbisim(Memory(id__))
				)
			)
			\ Union({
				{|
				|},
				{|
				|},
				{|
				|}
			})
			[|{|terminate|}|>SKIP
		)
		\{|terminate|}
	))
	
	-- visible state optimised equivalent
	
	VS_O__(id__,
			    const_Module_PathPlanningController_stm_ref0_cliff,
			    const_Module_PathPlanningController_stm_ref0_nozzle,
			    const_Module_PathPlanningController_stm_ref0_battery_low,
			    const_Module_PathPlanningController_stm_ref0_sleep_time,
			    const_Module_PathPlanningController_stm_ref0_acc_distance,
			    const_Module_PathPlanningController_stm_ref1_t,
			    const_Module_PathPlanningController_stm_ref2_t,
			    const_Module_PathPlanningController_stm_ref3_t,
			    const_Module_PathPlanningController_stm_ref4_voltage,
			    const_Module_PathPlanningController_stm_ref5_t,
			    const_Module_PathPlanningController_stm_ref5_acc_distance,
			    const_Module_PathPlanningController_stm_ref6_kp,
			    const_Module_PathPlanningController_stm_ref6_ki,
			    const_Module_PathPlanningController_stm_ref6_kd,
			    const_Module_PathPlanningController_stm_ref6_step,
			    const_Module_PathPlanningController_stm_ref7_kp,
			    const_Module_PathPlanningController_stm_ref7_ki,
			    const_Module_PathPlanningController_stm_ref7_kd,
			    const_Module_PathPlanningController_stm_ref7_step,
			    const_Module_PathPlanningController_stm_ref8_step,
			    const_Module_PathPlanningController_stm_ref8_climb_speed,
			    const_Module_PathPlanningController_stm_ref8_descent_speed,
			    const_Module_PathPlanningController_stm_ref8_side_speed,
			    const_Module_PathPlanningController_stm_ref8_forward_angle,
			    const_Module_PathPlanningController_stm_ref8_left_angle,
			    const_Module_PathPlanningController_stm_ref8_right_angle,
			    const_Module_PathPlanningController_stm_ref8_turn_speed,
			    const_Module_PathPlanningController_stm_ref8_movesp,
			    const_Module_PathPlanningController_stm_ref8_stopsp) = sbisim(diamond(	(
			(
				(SKIP)
					[|{||}|]
				(
					(
						PathPlanningController::VS_O__(id__,
								    const_Module_PathPlanningController_stm_ref0_cliff,
								    const_Module_PathPlanningController_stm_ref0_nozzle,
								    const_Module_PathPlanningController_stm_ref0_battery_low,
								    const_Module_PathPlanningController_stm_ref0_sleep_time,
								    const_Module_PathPlanningController_stm_ref0_acc_distance,
								    const_Module_PathPlanningController_stm_ref1_t,
								    const_Module_PathPlanningController_stm_ref2_t,
								    const_Module_PathPlanningController_stm_ref3_t,
								    const_Module_PathPlanningController_stm_ref4_voltage,
								    const_Module_PathPlanningController_stm_ref5_t,
								    const_Module_PathPlanningController_stm_ref5_acc_distance,
								    const_Module_PathPlanningController_stm_ref6_kp,
								    const_Module_PathPlanningController_stm_ref6_ki,
								    const_Module_PathPlanningController_stm_ref6_kd,
								    const_Module_PathPlanningController_stm_ref6_step,
								    const_Module_PathPlanningController_stm_ref7_kp,
								    const_Module_PathPlanningController_stm_ref7_ki,
								    const_Module_PathPlanningController_stm_ref7_kd,
								    const_Module_PathPlanningController_stm_ref7_step,
								    const_Module_PathPlanningController_stm_ref8_step,
								    const_Module_PathPlanningController_stm_ref8_climb_speed,
								    const_Module_PathPlanningController_stm_ref8_descent_speed,
								    const_Module_PathPlanningController_stm_ref8_side_speed,
								    const_Module_PathPlanningController_stm_ref8_forward_angle,
								    const_Module_PathPlanningController_stm_ref8_left_angle,
								    const_Module_PathPlanningController_stm_ref8_right_angle,
								    const_Module_PathPlanningController_stm_ref8_turn_speed,
								    const_Module_PathPlanningController_stm_ref8_movesp,
								    const_Module_PathPlanningController_stm_ref8_stopsp)[[
							PathPlanningController::terminate <- terminate,
							PathPlanningController::acc_l <- acc_l,
							PathPlanningController::acc_r <- acc_r,
							PathPlanningController::battery_level <- battery_level,
							PathPlanningController::charging <- charging,
							PathPlanningController::ultrasonic <- ultrasonic,
							PathPlanningController::brushCall <- brushCall,
							PathPlanningController::vacuumCall <- vacuumCall,
							PathPlanningController::output_left_motorCall <- output_left_motorCall,
							PathPlanningController::output_right_motorCall <- output_right_motorCall
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					dbisim(Memory(id__))
				)
			)
			\ Union({
				{|
				|},
				{|
				|},
				{|
				|}
			})
			[|{|terminate|}|>SKIP
		)
		\{|terminate|}
	))
	
	-- O version (optimised) with visible assignments
	
	AS_O__(id__,
			    const_Module_PathPlanningController_stm_ref0_cliff,
			    const_Module_PathPlanningController_stm_ref0_nozzle,
			    const_Module_PathPlanningController_stm_ref0_battery_low,
			    const_Module_PathPlanningController_stm_ref0_sleep_time,
			    const_Module_PathPlanningController_stm_ref0_acc_distance,
			    const_Module_PathPlanningController_stm_ref1_t,
			    const_Module_PathPlanningController_stm_ref2_t,
			    const_Module_PathPlanningController_stm_ref3_t,
			    const_Module_PathPlanningController_stm_ref4_voltage,
			    const_Module_PathPlanningController_stm_ref5_t,
			    const_Module_PathPlanningController_stm_ref5_acc_distance,
			    const_Module_PathPlanningController_stm_ref6_kp,
			    const_Module_PathPlanningController_stm_ref6_ki,
			    const_Module_PathPlanningController_stm_ref6_kd,
			    const_Module_PathPlanningController_stm_ref6_step,
			    const_Module_PathPlanningController_stm_ref7_kp,
			    const_Module_PathPlanningController_stm_ref7_ki,
			    const_Module_PathPlanningController_stm_ref7_kd,
			    const_Module_PathPlanningController_stm_ref7_step,
			    const_Module_PathPlanningController_stm_ref8_step,
			    const_Module_PathPlanningController_stm_ref8_climb_speed,
			    const_Module_PathPlanningController_stm_ref8_descent_speed,
			    const_Module_PathPlanningController_stm_ref8_side_speed,
			    const_Module_PathPlanningController_stm_ref8_forward_angle,
			    const_Module_PathPlanningController_stm_ref8_left_angle,
			    const_Module_PathPlanningController_stm_ref8_right_angle,
			    const_Module_PathPlanningController_stm_ref8_turn_speed,
			    const_Module_PathPlanningController_stm_ref8_movesp,
			    const_Module_PathPlanningController_stm_ref8_stopsp) = sbisim(diamond(	(
			(
				(SKIP)
					[|{||}|]
				(
					(
						PathPlanningController::O__(id__,
								    const_Module_PathPlanningController_stm_ref0_cliff,
								    const_Module_PathPlanningController_stm_ref0_nozzle,
								    const_Module_PathPlanningController_stm_ref0_battery_low,
								    const_Module_PathPlanningController_stm_ref0_sleep_time,
								    const_Module_PathPlanningController_stm_ref0_acc_distance,
								    const_Module_PathPlanningController_stm_ref1_t,
								    const_Module_PathPlanningController_stm_ref2_t,
								    const_Module_PathPlanningController_stm_ref3_t,
								    const_Module_PathPlanningController_stm_ref4_voltage,
								    const_Module_PathPlanningController_stm_ref5_t,
								    const_Module_PathPlanningController_stm_ref5_acc_distance,
								    const_Module_PathPlanningController_stm_ref6_kp,
								    const_Module_PathPlanningController_stm_ref6_ki,
								    const_Module_PathPlanningController_stm_ref6_kd,
								    const_Module_PathPlanningController_stm_ref6_step,
								    const_Module_PathPlanningController_stm_ref7_kp,
								    const_Module_PathPlanningController_stm_ref7_ki,
								    const_Module_PathPlanningController_stm_ref7_kd,
								    const_Module_PathPlanningController_stm_ref7_step,
								    const_Module_PathPlanningController_stm_ref8_step,
								    const_Module_PathPlanningController_stm_ref8_climb_speed,
								    const_Module_PathPlanningController_stm_ref8_descent_speed,
								    const_Module_PathPlanningController_stm_ref8_side_speed,
								    const_Module_PathPlanningController_stm_ref8_forward_angle,
								    const_Module_PathPlanningController_stm_ref8_left_angle,
								    const_Module_PathPlanningController_stm_ref8_right_angle,
								    const_Module_PathPlanningController_stm_ref8_turn_speed,
								    const_Module_PathPlanningController_stm_ref8_movesp,
								    const_Module_PathPlanningController_stm_ref8_stopsp)[[
							PathPlanningController::terminate <- terminate,
							PathPlanningController::acc_l <- acc_l,
							PathPlanningController::acc_r <- acc_r,
							PathPlanningController::battery_level <- battery_level,
							PathPlanningController::charging <- charging,
							PathPlanningController::ultrasonic <- ultrasonic,
							PathPlanningController::brushCall <- brushCall,
							PathPlanningController::vacuumCall <- vacuumCall,
							PathPlanningController::output_left_motorCall <- output_left_motorCall,
							PathPlanningController::output_right_motorCall <- output_right_motorCall
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					dbisim(Memory(id__))
				)
			)
			\ Union({
				{|
				|},
				{|
				|},
				{|
				|}
			})
			[|{|terminate|}|>SKIP
		)
		\{|terminate|}
	))
	
endmodule
