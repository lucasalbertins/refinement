transparent normal
include "file_SimFW_coreassertions.csp"
ID_P_SimFW = {1..1}
datatype alphabet_P_SimFW = DecisionNode_MergeNode0_P_SimFW_t_alphabet | move_0_2__1_P_SimFW_t_alphabet| InitialNode0_P_SimFW_t_alphabet| accept_obstacle_1_P_SimFW_t_alphabet
robochart_alphabet_P_SimFW = {|CFootBot::moveCall,CFootBot::obstacle.in,CFootBot::obstacle.out|}
countCe_P_SimFW = {1..4}
countUpdate_P_SimFW = {1..1}
countClear_P_SimFW = {1..0}
limiteUpdate_P_SimFW = {(1)..(1)}
channel startActivity_P_SimFW: ID_P_SimFW
channel endActivity_P_SimFW: ID_P_SimFW
channel ce_P_SimFW: ID_P_SimFW.countCe_P_SimFW
channel clear_P_SimFW: ID_P_SimFW.countClear_P_SimFW
channel update_P_SimFW: ID_P_SimFW.countUpdate_P_SimFW.limiteUpdate_P_SimFW
channel endDiagram_P_SimFW: ID_P_SimFW
channel dc
channel begin, end:  {1..1}

alphabet_Astah_P_SimFW = {| startActivity_P_SimFW, endActivity_P_SimFW, ce_P_SimFW, clear_P_SimFW, update_P_SimFW, endDiagram_P_SimFW, dc |}

MAIN = normal(P_SimFW(1))
END_DIAGRAM_P_SimFW(id) = endDiagram_P_SimFW.id -> SKIP
P_SimFW(ID_P_SimFW) = (Internal_P_SimFW(ID_P_SimFW) [|{|update_P_SimFW,clear_P_SimFW,endDiagram_P_SimFW|}|] TokenManager_P_SimFW_t(ID_P_SimFW,0,0))
Internal_P_SimFW(id) = StartActivity_P_SimFW(id); Node_P_SimFW(id); EndActivity_P_SimFW(id)
StartActivity_P_SimFW(id) = startActivity_P_SimFW.id -> SKIP
EndActivity_P_SimFW(id) = endActivity_P_SimFW.id -> SKIP
AlphabetDiagram_P_SimFW(id,DecisionNode_MergeNode0_P_SimFW_t_alphabet) = {|ce_P_SimFW.id.1,ce_P_SimFW.id.2,ce_P_SimFW.id.3,endDiagram_P_SimFW.id|}
AlphabetDiagram_P_SimFW(id,move_0_2__1_P_SimFW_t_alphabet) = {|ce_P_SimFW.id.4,ce_P_SimFW.id.2,endDiagram_P_SimFW.id|}
AlphabetDiagram_P_SimFW(id,InitialNode0_P_SimFW_t_alphabet) = {|ce_P_SimFW.id.1,endDiagram_P_SimFW.id|}
AlphabetDiagram_P_SimFW(id,accept_obstacle_1_P_SimFW_t_alphabet) = {|ce_P_SimFW.id.3,ce_P_SimFW.id.4,endDiagram_P_SimFW.id|}
AlphabetDiagram_P_SimFW_t(id) = union(union(union(AlphabetDiagram_P_SimFW(id,DecisionNode_MergeNode0_P_SimFW_t_alphabet),AlphabetDiagram_P_SimFW(id,move_0_2__1_P_SimFW_t_alphabet)),AlphabetDiagram_P_SimFW(id,InitialNode0_P_SimFW_t_alphabet)),AlphabetDiagram_P_SimFW(id,accept_obstacle_1_P_SimFW_t_alphabet))

ProcessDiagram_P_SimFW(id,DecisionNode_MergeNode0_P_SimFW_t_alphabet) = normal(DecisionNode_MergeNode0_P_SimFW_t(id))
ProcessDiagram_P_SimFW(id,move_0_2__1_P_SimFW_t_alphabet) = normal(move_0_2__1_P_SimFW_t(id))
ProcessDiagram_P_SimFW(id,InitialNode0_P_SimFW_t_alphabet) = normal(InitialNode0_P_SimFW_t(id))
ProcessDiagram_P_SimFW(id,accept_obstacle_1_P_SimFW_t_alphabet) = normal(accept_obstacle_1_P_SimFW_t(id))
InitialNode0_P_SimFW(id) = update_P_SimFW.id.1!(1-0) -> ((ce_P_SimFW.id.1 -> SKIP))
InitialNode0_P_SimFW_t(id) = InitialNode0_P_SimFW(id) /\ END_DIAGRAM_P_SimFW(id)
DecisionNode_MergeNode0_P_SimFW(id) = ((ce_P_SimFW.id.1 -> SKIP) [] (ce_P_SimFW.id.2 -> SKIP)); ce_P_SimFW.id.3 -> DecisionNode_MergeNode0_P_SimFW(id)
DecisionNode_MergeNode0_P_SimFW_t(id) = DecisionNode_MergeNode0_P_SimFW(id) /\ END_DIAGRAM_P_SimFW(id)
accept_obstacle_1_P_SimFW(id) = ((ce_P_SimFW.id.3 -> SKIP)); begin.1 -> end.1 -> SKIP; ((ce_P_SimFW.id.4 -> SKIP)); accept_obstacle_1_P_SimFW(id)
accept_obstacle_1_P_SimFW_t(id) = accept_obstacle_1_P_SimFW(id) /\ END_DIAGRAM_P_SimFW(id)
move_0_2__1_P_SimFW(id) = ((ce_P_SimFW.id.4 -> SKIP)); CFootBot::moveCall.0.2 -> ((ce_P_SimFW.id.2 -> SKIP)); move_0_2__1_P_SimFW(id)
move_0_2__1_P_SimFW_t(id) = move_0_2__1_P_SimFW(id) /\ END_DIAGRAM_P_SimFW(id)

TokenManager_P_SimFW(id,x,init) = update_P_SimFW.id?c?y:limiteUpdate_P_SimFW -> x+y < 10 & x+y > -10 & TokenManager_P_SimFW(id,x+y,1) [] clear_P_SimFW.id?c -> endDiagram_P_SimFW.id -> SKIP [] x == 0 & init == 1 & endDiagram_P_SimFW.id -> SKIP
TokenManager_P_SimFW_t(id,x,init) = TokenManager_P_SimFW(id,x,init)

assert Prop_P_SimFW [T= P_CFootBot

NRecurse(S, P) = |~| ev : S @ ev -> P

WAIT(alphabet,event) = 
	NRecurse(diff(alphabet, {event}), WAIT(alphabet,event))
	|~|
	event -> SKIP

WAIT_PROCCESSES_P_SimFW(processes) = ( ||| CONTROL : processes @ CONTROL )  /\ endDiagram_P_SimFW?id -> SKIP

Prop_P_SimFW = PROP_P_SimFW(Wait_control_processes_P_SimFW) \ alphabet_Astah_P_SimFW 

alphabet_robochart_P_SimFW = {|CFootBot::moveCall,CFootBot::obstacle.in,CFootBot::obstacle.out|}

PROP_P_SimFW(processes) = (MAIN [|{|begin, end, endDiagram_P_SimFW|}|] WAIT_PROCCESSES_P_SimFW(processes) ) \ {|begin, end|}

Wait_P_SimFW_1 = WAIT(alphabet_robochart_P_SimFW, CFootBot::obstacle.in)

Wait_P_SimFW_control_1 = begin.1 -> Wait_P_SimFW_1; end.1 -> Wait_P_SimFW_control_1

Wait_control_processes_P_SimFW = {Wait_P_SimFW_control_1}

Node_P_SimFW(id) = composeNodes_P_SimFW(id)

composeNodes_P_SimFW(id) = 
	let
	    alphabet_P_SimFW_s = seq(alphabet_P_SimFW)
		composeNodes_(id,<ev>,_) = ProcessDiagram_P_SimFW(id,ev)
		composeNodes_(id,<ev>^tail,past) = 
			ProcessDiagram_P_SimFW(id,ev) 
				[|union(diff(AlphabetDiagram_P_SimFW(id,ev),past),{endDiagram_P_SimFW.id})|] 
			( composeNodes_(id,tail,union(past,AlphabetDiagram_P_SimFW(id,ev))) )
	within 
		composeNodes_(id,alphabet_P_SimFW_s,{})

