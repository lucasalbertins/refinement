
module CFootBot
exports 

	transparent diamond
	transparent sbisim
	transparent chase
	
	-- declaring channels
	-- declaring robotic platform events
	channel obstacle: InOut
	
	channel moveCall, moveRet: core_real.core_real
	
	-- declaring module termination channel
	channel terminate
				
	-- declaring robotic platform variables
	
		module ctrl_ref0
			Timed(OneStep) {
				shared_variable_events = {|
				|}		
			}	
		exports
			transparent diamond
			transparent sbisim
			transparent chase
			
					module stm_ref0		
					exports
						-- definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
						external prioritise
						transparent wbisim		
					
						Timed(OneStep) {	
							-- flow channels
							channel internal__ : TIDS
							channel enteredV, enterV, exitV, exitedV : SIDS
							channel enter, entered: SIDS.SIDS
							channel exit,exited: SIDS.SIDS
							channel terminate
							
							-- variable channels
							channel get_x, set_x: core_nat
									
							-- shared variable channels
							
							-- local variable channels for defined operations that are required by the state machine
							
							-- declaring state machine events
							channel obstacle__: TIDS.InOut
							channel obstacle: InOut
							
							-- declaring call and ret events for undefined operations
							channel moveCall, moveRet: core_real.core_real
						
							-- Only the undefined operations are declared here.
							-- If the state machine is in isolation, all required operations will be undefined.
							-- If it is in the context of a controller, the required operations not provided by the
							-- controller will be declared here, and the defined operations will be defined in the
							-- context of the Controller module, and therefore within scope of the state machien module.
							move(id__, lv, av) =  EDeadline(moveCall.lv.av,0); EDeadline(moveRet.lv.av,0)
							
							
							
							-- definition of functions used to expose flow channels
							ShowEvents(P,E) = P[[ entered.x____.y____ <- enteredV.y____ | entered.x____.y____ <- E]]
											   [[ enter.x____.y____ <- enterV.y____ | enter.x____.y____ <- E]]
											   [[ exit.x____.y____ <- exitV.y____ | exit.x____.y____ <- E]]
											   [[ exited.x____.y____ <- exitedV.y____ | exited.x____.y____ <- E ]]
												 
							ShowEnteredV(P) = P[[ entered.x____.y____ <- enteredV.y____ | x____ <- SIDS, y____ <- SIDS ]]
							ShowEnterV(P) = P[[ enter.x____.y____ <- enterV.y____ | x____ <- SIDS, y____ <- SIDS ]]
							ShowExitV(P) = P[[ exit.x____.y____ <- exitV.y____ | x____ <- SIDS, y____ <- SIDS ]]
							ShowExitedV(P) = P[[ exited.x____.y____ <- exitedV.y____ | x____ <- SIDS, y____ <- SIDS ]]
							ShowV(P) = P[[ entered.x____.y____ <- enteredV.y____ | x____ <- SIDS, y____ <- SIDS]]
										[[ enter.x____.y____ <- enterV.y____ | x____ <- SIDS, y____ <- SIDS ]]
										[[ exit.x____.y____ <- exitV.y____ | x____ <- SIDS, y____ <- SIDS]]
										[[ exited.x____.y____ <- exitedV.y____ | x____ <- SIDS, y____ <- SIDS ]]
							
							-- declaring identifiers of state and final states
							datatype SIDS = SID_SMovement
							              | SID_SMovement_Moving
							              | SID_SMovement_Turning
							
							-- declaring identifiers of transitions
							datatype TIDS = NULLTRANSITION__
							              | TID_SMovement_t1
							              | TID_SMovement_t2
							              | TID_SMovement_t3
							
							-- declaring identifiers of transitions that can interupt a state (excludes transitions from junctions)
							
							ITIDS = {
								TID_SMovement_t2,	TID_SMovement_t3
							}
							
							int_int = {|
								obstacle__.TID_SMovement_t2,
								internal__.TID_SMovement_t2,
								obstacle__.TID_SMovement_t3,
								internal__.TID_SMovement_t3
							|}
								
							
							internal_events = {|enter,entered,exit,exited|}
							shared_variable_events = {|
							|}
									
							
							-- declaring all states
							CS_SMovement_Moving_sync = {|
								enter.y____.x____, 
								entered.y____.x____, 
								exit.y____.x____, 
								exited.y____.x____,
								enter.x____.y____, 
								entered.x____.y____, 
								exit.x____.y____, 
								exited.x____.y____ |
								x____ <- {SID_SMovement_Moving,SID_SMovement_Turning},
								y____ <- {SID_SMovement_Moving}
							|}
							
							
							SMovement_Moving_triggers = {|
								internal__.TID_SMovement_t3,
								obstacle__.TID_SMovement_t2
							|}
							
							State_SMovement_Moving(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = let
								T_SMovement_t2(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = obstacle__!TID_SMovement_t2.in -> DoClockReset({clockReset.CLID_MBC}) ;  (exit.SID_SMovement_Moving.SID_SMovement_Moving -> SKIP;
													SKIP;exited.SID_SMovement_Moving.SID_SMovement_Moving -> SKIP;
													enter!SID_SMovement_Moving!SID_SMovement_Turning -> entered!SID_SMovement_Moving!SID_SMovement_Turning ->
													State_SMovement_Moving(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
								)
								State_SMovement_Moving_execute(id__,o____,const_SMovement_lv,const_SMovement_PI,const_SMovement_av) = true&move(id__, const_SMovement_lv, 0);WAIT(1); 
									entered!o____!SID_SMovement_Moving ->
									(SKIP; STOP /\ (
										T_SMovement_t2(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
										[]
										internal__?x____:diff(ITIDS,{NULLTRANSITION__,TID_SMovement_t3,TID_SMovement_t2}) -> exit?y____:diff(SIDS,{SID_SMovement_Moving})!SID_SMovement_Moving -> (
												SKIP;
												exited!y____!SID_SMovement_Moving -> SKIP);
												State_SMovement_Moving(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
										[] obstacle__?x____:diff(ITIDS,{NULLTRANSITION__,TID_SMovement_t3,TID_SMovement_t2})?d____ ->	exit?y____:diff(SIDS,{SID_SMovement_Moving})!SID_SMovement_Moving -> (
												SKIP;
												exited!y____!SID_SMovement_Moving -> SKIP);
												State_SMovement_Moving(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
									))
							within
								enter?x____:diff(SIDS,{SID_SMovement_Moving})!SID_SMovement_Moving -> (State_SMovement_Moving_execute(id__,x____,const_SMovement_lv,const_SMovement_PI,const_SMovement_av))
							
							CS_SMovement_Turning_sync = {|
								enter.y____.x____, 
								entered.y____.x____, 
								exit.y____.x____, 
								exited.y____.x____,
								enter.x____.y____, 
								entered.x____.y____, 
								exit.x____.y____, 
								exited.x____.y____ |
								x____ <- {SID_SMovement_Moving,SID_SMovement_Turning},
								y____ <- {SID_SMovement_Turning}
							|}
							
							
							SMovement_Turning_triggers = {|
								internal__.TID_SMovement_t3,
								obstacle__.TID_SMovement_t2
							|}
							
							State_SMovement_Turning(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = let
								T_SMovement_t3(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = internal__!TID_SMovement_t3 ->  exit.SID_SMovement_Turning.SID_SMovement_Turning -> SKIP;
													SKIP;exited.SID_SMovement_Turning.SID_SMovement_Turning -> SKIP;
													enter!SID_SMovement_Turning!SID_SMovement_Moving -> entered!SID_SMovement_Turning!SID_SMovement_Moving ->
													State_SMovement_Turning(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
								State_SMovement_Turning_execute(id__,o____,const_SMovement_lv,const_SMovement_PI,const_SMovement_av) = true&move(id__, 0, const_SMovement_av); 
									entered!o____!SID_SMovement_Turning ->
									(SKIP; STOP /\ (
										T_SMovement_t3(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
										[]
										internal__?x____:diff(ITIDS,{NULLTRANSITION__,TID_SMovement_t3,TID_SMovement_t2}) -> exit?y____:diff(SIDS,{SID_SMovement_Turning})!SID_SMovement_Turning -> (
												SKIP;
												exited!y____!SID_SMovement_Turning -> SKIP);
												State_SMovement_Turning(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
										[] obstacle__?x____:diff(ITIDS,{NULLTRANSITION__,TID_SMovement_t3,TID_SMovement_t2})?d____ ->	exit?y____:diff(SIDS,{SID_SMovement_Turning})!SID_SMovement_Turning -> (
												SKIP;
												exited!y____!SID_SMovement_Turning -> SKIP);
												State_SMovement_Turning(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
									))
							within
								enter?x____:diff(SIDS,{SID_SMovement_Turning})!SID_SMovement_Turning -> (State_SMovement_Turning_execute(id__,x____,const_SMovement_lv,const_SMovement_PI,const_SMovement_av))
							
							
							I_SMovement_i1(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = let
								T_SMovement_t1(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = internal__!TID_SMovement_t1 -> enter!SID_SMovement!SID_SMovement_Moving -> entered!SID_SMovement!SID_SMovement_Moving ->
								SKIP
							within
								T_SMovement_t1(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
							
							
							State_SMovement_Moving_R(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = 
								State_SMovement_Moving(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
									[|diff(int_int,SMovement_Moving_triggers)|]
								SKIP
									 		
							State_SMovement_Turning_R(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = 
								State_SMovement_Turning(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
									[|diff(int_int,SMovement_Turning_triggers)|]
								SKIP
									 		
								
							STM(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = (
								I_SMovement_i1(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
									[|
										{|enter.x____.y____, entered.x____.y____, exit.x____.y____, exited.x____.y____ |
											x____ <- diff(SIDS,{SID_SMovement_Moving,SID_SMovement_Turning}),
											y____ <- {SID_SMovement_Moving,SID_SMovement_Turning}
									|}|]
								(
									State_SMovement_Moving_R(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
										[|inter(CS_SMovement_Moving_sync,CS_SMovement_Turning_sync)|]
									State_SMovement_Turning_R(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
								)
							)
							
							-- optimized memory process
							channel getV_x: core_nat
							
							-- individual memory processes
							Memory_x(x) = (
								get_x!x -> Memory_x(x)
								[]
								getV_x!x -> Memory_x(x)
								[]
								set_x?x__ -> Memory_x(x__)
							)
							Memory_WC_TID_SMovement_t3_0(WC_TID_SMovement_t3_0) = (
								getWC.WC_TID_SMovement_t3_0_ID!WC_TID_SMovement_t3_0 -> Memory_WC_TID_SMovement_t3_0(WC_TID_SMovement_t3_0)
								[]
								setWC.WC_TID_SMovement_t3_0_ID?x__ -> Memory_WC_TID_SMovement_t3_0(x__)
							)
							
							-- processes that read variables and offer transitions
							
							MemoryTransitions(id__, x, WC_TID_SMovement_t3_0, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = (internal__!TID_SMovement_t1 -> SKIP
							[]
							obstacle__!TID_SMovement_t2.in -> SKIP
							[]
							(WC_TID_SMovement_t3_0)&(internal__!TID_SMovement_t3 -> SKIP)
							[]
							set_x?x__ -> SKIP
							[]
							setWC.WC_TID_SMovement_t3_0_ID?x__ -> SKIP)
							
							MemoryTransitions_SMovement(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = (getV_x?x ->
							getWC.WC_TID_SMovement_t3_0_ID?WC_TID_SMovement_t3_0 ->
							MemoryTransitions(id__, x, WC_TID_SMovement_t3_0, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)			
							); MemoryTransitions_SMovement(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
									
							
							-- synchronisation, hiding and process sets 
							MemoryVariablesProcesses_SMovement = Union(
								{
									{
										(Memory_x(0),{|getV_x,get_x,set_x|}),
										(Memory_WC_TID_SMovement_t3_0(false),{|getWC.WC_TID_SMovement_t3_0_ID,setWC.WC_TID_SMovement_t3_0_ID|})
									}
								}
							)
							
							MemoryVariablesSyncSet = Union({
								{|
									getV_x,
									getWC.WC_TID_SMovement_t3_0_ID,
									setWC,
									setWC.WC_TID_SMovement_t3_0_ID,
									set_x
								|}	
							})
							
							MemoryVariablesHideSet = Union({
								{|
									getV_x,
									getWC
								|}
							})
							
							-- combined individual memory processes
							MemoryVariables = ||| (P, alpha) : MemoryVariablesProcesses_SMovement @ P
							
							-- complete memory process	
							MemoryN(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = (wbisim(MemoryVariables) [| MemoryVariablesSyncSet |] wbisim(MemoryTransitions_SMovement(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av))) \ MemoryVariablesHideSet
							
							-- main process
							
							MachineMemorySyncSet = Union({
								union(
									union(
										{|get_x,set_x|},
										{||}
									)
										
									,
									{|internal__.TID_SMovement_t1,
									obstacle__.TID_SMovement_t2,
									internal__.TID_SMovement_t3|}
								),
								{|deadline|},
								WCresets
							})
							
							MachineMemoryHidingSet = Union({
								union(
									{|get_x,set_x|},
									{||}
								)
								,
								{|deadline|}
							})
							
							MachineInternalEvents = {|
								internal__
							|}
						
							-- main process
							AUX(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = prioritise(timed_priority(((
								wbisim(STM(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av))
									[|MachineMemorySyncSet|]
								(wbisim(MemoryN(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)) [| union(WCsets,WCsync) |] Clocks(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av))\WCsets
							)
							[[
								obstacle__.x____ <- obstacle
								| x____ <- TIDS
							]]
							\MachineMemoryHidingSet)
							[|{|terminate|}|>SKIP\MachineInternalEvents)
							,<Union({internal_events, ClockResets, {|terminate|}}),{tock}>)
							
							internal_(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = prioritise(timed_priority(((
								wbisim(STM(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av))
									[|MachineMemorySyncSet|]
								(wbisim(MemoryN(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)) [| union(WCsets,WCsync) |] Clocks(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av))\WCsets
							)
							\MachineMemoryHidingSet)
							[|{|terminate|}|>SKIP)
							,<Union({internal_events, ClockResets, {|internal__,terminate|}}),{tock}>)		
							-- declare clocks
							datatype ClockSet = dummyC | CLID_MBC
							channel clockReset : ClockSet
										
							
							-- declare trigger deadlines channel
							channel deadline : TIDS.Signal
							
							-- compile clocks process
							
							-- set of strings that uniquely identify the waiting conditions, each of which is 
							-- used to synchronise with the Memory process to set the correspoding variable in
							-- the memory process.
							datatype setWC_identifierSet = dummyWC
							                             | WC_TID_SMovement_t3_0_ID
							
							-- declaring getWC and setWC channel for updating memory variables related to clocks
							channel setWC : setWC_identifierSet.Bool
							channel getWC : setWC_identifierSet.Bool
							
							-- Set of pairs capturing waiting condition processes and their alphabet.
							-- It includes the corresponding set of the defined operations.
							WCset(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = Union({
								{
								({|clockReset.CLID_MBC,SMovement::internal__.SMovement::TID_SMovement_t3,setWC.WC_TID_SMovement_t3_0_ID | x <- SIDS|},P_WC_TID_SMovement_t3_0(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av))
								}
								})
							-- Set of transition events for which synchronisation is required between Clocks and the Memory process.
							-- It includes the corresponding set of the defined operations.
							WCsync = Union({
								{|SMovement::internal__.SMovement::TID_SMovement_t3|}
								})
							-- Set of all clock resets, including 'clockReset.C' events and 'entered.x.y' events where x is drawn
							-- from the set of all state machine state identifiers. It includes the corresponding set of the defined operations.
							WCresets = Union({
								{|clockReset.CLID_MBC | x <- SIDS |}
								})
							-- Set of all waiting condition set events. It includes the corresponding set of the defined operations.
							WCsets = Union({
								{|setWC|}
								})
							
							P_WC_TID_SMovement_t3_0_reset(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = clockReset.CLID_MBC -> setWC.WC_TID_SMovement_t3_0_ID.false -> P_WC_TID_SMovement_t3_0_monitor(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
							
							P_WC_TID_SMovement_t3_0_monitor(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = (TimedInterrupt(RUN({|tock,SMovement::internal__.SMovement::TID_SMovement_t3|}),Div(const_SMovement_PI, const_SMovement_av, core_real)) ; setWC.WC_TID_SMovement_t3_0_ID.true -> RUN({|tock,SMovement::internal__.SMovement::TID_SMovement_t3|})) /\ P_WC_TID_SMovement_t3_0_reset(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
							
							P_WC_TID_SMovement_t3_0(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = setWC.WC_TID_SMovement_t3_0_ID.false -> P_WC_TID_SMovement_t3_0_monitor(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
							
							-- Clocks process
							Clocks(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = || (alpha, P) : WCset(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) @ [alpha] wbisim(P)
			
							-- collects all clockResets including those of operations
							ClockResets = Union({
								{|clockReset|}
												})
							
							-- With no internal events visible
							D__(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = timed_priority(AUX(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) \ union(internal_events,ClockResets))
							
							O__(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = D__(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
							
							-- With enter/entered/exit/exited events visible
							FVS__(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = timed_priority(AUX(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) \ ClockResets)
							
							-- With enterV/enteredV/exitV/exitedV events visible
							VS__(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = ShowV(timed_priority(AUX(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) \ ClockResets))
							
							-- With clock resets visible
							FVS_C__(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = AUX(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
						}
					endmodule
		
		
			Timed(OneStep) {
				-- declaring call and ret events for undefined operations
				channel moveCall, moveRet: core_real.core_real
		
				move(id__, lv, av) =  EDeadline(moveCall.lv.av,0); EDeadline(moveRet.lv.av,0)
				
							
				-- declaring controller events
				channel obstacle: InOut
								
	
			
				-- declaring controller memory
				Memory(id__) = SKIP
				-- declaring controller termination channel
				channel terminate
				
				-- set of visible memory events
				visibleMemoryEvents = {||}
			
				D__(id__) = prioritise(wbisim(
					(
						stm_ref0::D__(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)[[
							stm_ref0::terminate <- terminate,
							stm_ref0::obstacle <- obstacle,
							stm_ref0::moveCall <- moveCall,
							stm_ref0::moveRet <- moveRet
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP,
				<union(visibleMemoryEvents,{terminate}),{tock}>)
				
				O__(id__) = D__(id__)
				
				-- VS version
				VS__(id__) = prioritise(wbisim(
					(
						stm_ref0::VS__(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)[[
							stm_ref0::terminate <- terminate,
							stm_ref0::obstacle <- obstacle,
							stm_ref0::moveCall <- moveCall,
							stm_ref0::moveRet <- moveRet
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP,
				<union(visibleMemoryEvents,{terminate}),{tock}>)
			
				HEXT(id__) = D__(id__) [|shared_variable_events|] SKIP
			}
		endmodule
	
	Timed(OneStep) {
			
		-- declaring module memory
		Memory(id__) = SKIP
		
		visibleMemoryEvents = {||}
		
		D__(id__) = prioritise(
			(				(
					(
						SKIP
							[|{||}|]
						(
							(
								ctrl_ref0::D__(id__)[[
									ctrl_ref0::terminate <- terminate,
									ctrl_ref0::obstacle <- obstacle,
									ctrl_ref0::moveCall <- moveCall,
									ctrl_ref0::moveRet <- moveRet
								]]
							)
								[|
									union(
										{|
										|},
										{|
										|}
									)
								|]
							Memory(id__)
						)
					)
					\ Union({
						{|
						|},
						{|
						|},
						{|
						|}
					})
					[|{|terminate|}|>SKIP
				)\{|terminate|}
			),
			<visibleMemoryEvents,{tock}>
		)
		
		O__(id__) = D__(id__)
		
		-- visible state equivalent
		VS__(id__) = prioritise(
			(				(
					(
						SKIP
							[|{||}|]
						(
							(
								ctrl_ref0::VS__(id__)[[
									ctrl_ref0::terminate <- terminate,
									ctrl_ref0::obstacle <- obstacle,
									ctrl_ref0::moveCall <- moveCall,
									ctrl_ref0::moveRet <- moveRet
								]]
							)
								[|
									union(
										{|
										|},
										{|
										|}
									)
								|]
							Memory(id__)
						)
					)
					\ Union({
						{|
						|},
						{|
						|},
						{|
						|}
					})							
					[|{|terminate|}|>SKIP
				)\{|terminate|}
			)
			,<visibleMemoryEvents,{tock}>
		)
	}
endmodule

	module Movement
		Timed(OneStep) {
			shared_variable_events = {|
			|}		
		}	
	exports
		transparent diamond
		transparent sbisim
		transparent chase
		
				module stm_ref0		
				exports
					-- definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					external prioritise
					transparent wbisim		
				
					Timed(OneStep) {	
						-- flow channels
						channel internal__ : TIDS
						channel enteredV, enterV, exitV, exitedV : SIDS
						channel enter, entered: SIDS.SIDS
						channel exit,exited: SIDS.SIDS
						channel terminate
						
						-- variable channels
						channel get_x, set_x: core_nat
								
						-- shared variable channels
						
						-- local variable channels for defined operations that are required by the state machine
						
						-- declaring state machine events
						channel obstacle__: TIDS.InOut
						channel obstacle: InOut
						
						-- declaring call and ret events for undefined operations
						channel moveCall, moveRet: core_real.core_real
					
						-- Only the undefined operations are declared here.
						-- If the state machine is in isolation, all required operations will be undefined.
						-- If it is in the context of a controller, the required operations not provided by the
						-- controller will be declared here, and the defined operations will be defined in the
						-- context of the Controller module, and therefore within scope of the state machien module.
						move(id__, lv, av) =  EDeadline(moveCall.lv.av,0); EDeadline(moveRet.lv.av,0)
						
						
						
						-- definition of functions used to expose flow channels
						ShowEvents(P,E) = P[[ entered.x____.y____ <- enteredV.y____ | entered.x____.y____ <- E]]
										   [[ enter.x____.y____ <- enterV.y____ | enter.x____.y____ <- E]]
										   [[ exit.x____.y____ <- exitV.y____ | exit.x____.y____ <- E]]
										   [[ exited.x____.y____ <- exitedV.y____ | exited.x____.y____ <- E ]]
											 
						ShowEnteredV(P) = P[[ entered.x____.y____ <- enteredV.y____ | x____ <- SIDS, y____ <- SIDS ]]
						ShowEnterV(P) = P[[ enter.x____.y____ <- enterV.y____ | x____ <- SIDS, y____ <- SIDS ]]
						ShowExitV(P) = P[[ exit.x____.y____ <- exitV.y____ | x____ <- SIDS, y____ <- SIDS ]]
						ShowExitedV(P) = P[[ exited.x____.y____ <- exitedV.y____ | x____ <- SIDS, y____ <- SIDS ]]
						ShowV(P) = P[[ entered.x____.y____ <- enteredV.y____ | x____ <- SIDS, y____ <- SIDS]]
									[[ enter.x____.y____ <- enterV.y____ | x____ <- SIDS, y____ <- SIDS ]]
									[[ exit.x____.y____ <- exitV.y____ | x____ <- SIDS, y____ <- SIDS]]
									[[ exited.x____.y____ <- exitedV.y____ | x____ <- SIDS, y____ <- SIDS ]]
						
						-- declaring identifiers of state and final states
						datatype SIDS = SID_SMovement
						              | SID_SMovement_Moving
						              | SID_SMovement_Turning
						
						-- declaring identifiers of transitions
						datatype TIDS = NULLTRANSITION__
						              | TID_SMovement_t1
						              | TID_SMovement_t2
						              | TID_SMovement_t3
						
						-- declaring identifiers of transitions that can interupt a state (excludes transitions from junctions)
						
						ITIDS = {
							TID_SMovement_t2,	TID_SMovement_t3
						}
						
						int_int = {|
							obstacle__.TID_SMovement_t2,
							internal__.TID_SMovement_t2,
							obstacle__.TID_SMovement_t3,
							internal__.TID_SMovement_t3
						|}
							
						
						internal_events = {|enter,entered,exit,exited|}
						shared_variable_events = {|
						|}
								
						
						-- declaring all states
						CS_SMovement_Moving_sync = {|
							enter.y____.x____, 
							entered.y____.x____, 
							exit.y____.x____, 
							exited.y____.x____,
							enter.x____.y____, 
							entered.x____.y____, 
							exit.x____.y____, 
							exited.x____.y____ |
							x____ <- {SID_SMovement_Moving,SID_SMovement_Turning},
							y____ <- {SID_SMovement_Moving}
						|}
						
						
						SMovement_Moving_triggers = {|
							internal__.TID_SMovement_t3,
							obstacle__.TID_SMovement_t2
						|}
						
						State_SMovement_Moving(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = let
							T_SMovement_t2(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = obstacle__!TID_SMovement_t2.in -> DoClockReset({clockReset.CLID_MBC}) ;  (exit.SID_SMovement_Moving.SID_SMovement_Moving -> SKIP;
												SKIP;exited.SID_SMovement_Moving.SID_SMovement_Moving -> SKIP;
												enter!SID_SMovement_Moving!SID_SMovement_Turning -> entered!SID_SMovement_Moving!SID_SMovement_Turning ->
												State_SMovement_Moving(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
							)
							State_SMovement_Moving_execute(id__,o____,const_SMovement_lv,const_SMovement_PI,const_SMovement_av) = true&move(id__, const_SMovement_lv, 0);WAIT(1); 
								entered!o____!SID_SMovement_Moving ->
								(SKIP; STOP /\ (
									T_SMovement_t2(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
									[]
									internal__?x____:diff(ITIDS,{NULLTRANSITION__,TID_SMovement_t3,TID_SMovement_t2}) -> exit?y____:diff(SIDS,{SID_SMovement_Moving})!SID_SMovement_Moving -> (
											SKIP;
											exited!y____!SID_SMovement_Moving -> SKIP);
											State_SMovement_Moving(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
									[] obstacle__?x____:diff(ITIDS,{NULLTRANSITION__,TID_SMovement_t3,TID_SMovement_t2})?d____ ->	exit?y____:diff(SIDS,{SID_SMovement_Moving})!SID_SMovement_Moving -> (
											SKIP;
											exited!y____!SID_SMovement_Moving -> SKIP);
											State_SMovement_Moving(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
								))
						within
							enter?x____:diff(SIDS,{SID_SMovement_Moving})!SID_SMovement_Moving -> (State_SMovement_Moving_execute(id__,x____,const_SMovement_lv,const_SMovement_PI,const_SMovement_av))
						
						CS_SMovement_Turning_sync = {|
							enter.y____.x____, 
							entered.y____.x____, 
							exit.y____.x____, 
							exited.y____.x____,
							enter.x____.y____, 
							entered.x____.y____, 
							exit.x____.y____, 
							exited.x____.y____ |
							x____ <- {SID_SMovement_Moving,SID_SMovement_Turning},
							y____ <- {SID_SMovement_Turning}
						|}
						
						
						SMovement_Turning_triggers = {|
							internal__.TID_SMovement_t3,
							obstacle__.TID_SMovement_t2
						|}
						
						State_SMovement_Turning(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = let
							T_SMovement_t3(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = internal__!TID_SMovement_t3 ->  exit.SID_SMovement_Turning.SID_SMovement_Turning -> SKIP;
												SKIP;exited.SID_SMovement_Turning.SID_SMovement_Turning -> SKIP;
												enter!SID_SMovement_Turning!SID_SMovement_Moving -> entered!SID_SMovement_Turning!SID_SMovement_Moving ->
												State_SMovement_Turning(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
							State_SMovement_Turning_execute(id__,o____,const_SMovement_lv,const_SMovement_PI,const_SMovement_av) = true&move(id__, 0, const_SMovement_av); 
								entered!o____!SID_SMovement_Turning ->
								(SKIP; STOP /\ (
									T_SMovement_t3(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
									[]
									internal__?x____:diff(ITIDS,{NULLTRANSITION__,TID_SMovement_t3,TID_SMovement_t2}) -> exit?y____:diff(SIDS,{SID_SMovement_Turning})!SID_SMovement_Turning -> (
											SKIP;
											exited!y____!SID_SMovement_Turning -> SKIP);
											State_SMovement_Turning(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
									[] obstacle__?x____:diff(ITIDS,{NULLTRANSITION__,TID_SMovement_t3,TID_SMovement_t2})?d____ ->	exit?y____:diff(SIDS,{SID_SMovement_Turning})!SID_SMovement_Turning -> (
											SKIP;
											exited!y____!SID_SMovement_Turning -> SKIP);
											State_SMovement_Turning(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
								))
						within
							enter?x____:diff(SIDS,{SID_SMovement_Turning})!SID_SMovement_Turning -> (State_SMovement_Turning_execute(id__,x____,const_SMovement_lv,const_SMovement_PI,const_SMovement_av))
						
						
						I_SMovement_i1(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = let
							T_SMovement_t1(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = internal__!TID_SMovement_t1 -> enter!SID_SMovement!SID_SMovement_Moving -> entered!SID_SMovement!SID_SMovement_Moving ->
							SKIP
						within
							T_SMovement_t1(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
						
						
						State_SMovement_Moving_R(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = 
							State_SMovement_Moving(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
								[|diff(int_int,SMovement_Moving_triggers)|]
							SKIP
								 		
						State_SMovement_Turning_R(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = 
							State_SMovement_Turning(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
								[|diff(int_int,SMovement_Turning_triggers)|]
							SKIP
								 		
							
						STM(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = (
							I_SMovement_i1(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
								[|
									{|enter.x____.y____, entered.x____.y____, exit.x____.y____, exited.x____.y____ |
										x____ <- diff(SIDS,{SID_SMovement_Moving,SID_SMovement_Turning}),
										y____ <- {SID_SMovement_Moving,SID_SMovement_Turning}
								|}|]
							(
								State_SMovement_Moving_R(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
									[|inter(CS_SMovement_Moving_sync,CS_SMovement_Turning_sync)|]
								State_SMovement_Turning_R(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
							)
						)
						
						-- optimized memory process
						channel getV_x: core_nat
						
						-- individual memory processes
						Memory_x(x) = (
							get_x!x -> Memory_x(x)
							[]
							getV_x!x -> Memory_x(x)
							[]
							set_x?x__ -> Memory_x(x__)
						)
						Memory_WC_TID_SMovement_t3_0(WC_TID_SMovement_t3_0) = (
							getWC.WC_TID_SMovement_t3_0_ID!WC_TID_SMovement_t3_0 -> Memory_WC_TID_SMovement_t3_0(WC_TID_SMovement_t3_0)
							[]
							setWC.WC_TID_SMovement_t3_0_ID?x__ -> Memory_WC_TID_SMovement_t3_0(x__)
						)
						
						-- processes that read variables and offer transitions
						
						MemoryTransitions(id__, x, WC_TID_SMovement_t3_0, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = (internal__!TID_SMovement_t1 -> SKIP
						[]
						obstacle__!TID_SMovement_t2.in -> SKIP
						[]
						(WC_TID_SMovement_t3_0)&(internal__!TID_SMovement_t3 -> SKIP)
						[]
						set_x?x__ -> SKIP
						[]
						setWC.WC_TID_SMovement_t3_0_ID?x__ -> SKIP)
						
						MemoryTransitions_SMovement(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = (getV_x?x ->
						getWC.WC_TID_SMovement_t3_0_ID?WC_TID_SMovement_t3_0 ->
						MemoryTransitions(id__, x, WC_TID_SMovement_t3_0, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)			
						); MemoryTransitions_SMovement(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
								
						
						-- synchronisation, hiding and process sets 
						MemoryVariablesProcesses_SMovement = Union(
							{
								{
									(Memory_x(0),{|getV_x,get_x,set_x|}),
									(Memory_WC_TID_SMovement_t3_0(false),{|getWC.WC_TID_SMovement_t3_0_ID,setWC.WC_TID_SMovement_t3_0_ID|})
								}
							}
						)
						
						MemoryVariablesSyncSet = Union({
							{|
								getV_x,
								getWC.WC_TID_SMovement_t3_0_ID,
								setWC,
								setWC.WC_TID_SMovement_t3_0_ID,
								set_x
							|}	
						})
						
						MemoryVariablesHideSet = Union({
							{|
								getV_x,
								getWC
							|}
						})
						
						-- combined individual memory processes
						MemoryVariables = ||| (P, alpha) : MemoryVariablesProcesses_SMovement @ P
						
						-- complete memory process	
						MemoryN(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = (wbisim(MemoryVariables) [| MemoryVariablesSyncSet |] wbisim(MemoryTransitions_SMovement(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av))) \ MemoryVariablesHideSet
						
						-- main process
						
						MachineMemorySyncSet = Union({
							union(
								union(
									{|get_x,set_x|},
									{||}
								)
									
								,
								{|internal__.TID_SMovement_t1,
								obstacle__.TID_SMovement_t2,
								internal__.TID_SMovement_t3|}
							),
							{|deadline|},
							WCresets
						})
						
						MachineMemoryHidingSet = Union({
							union(
								{|get_x,set_x|},
								{||}
							)
							,
							{|deadline|}
						})
						
						MachineInternalEvents = {|
							internal__
						|}
					
						-- main process
						AUX(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = prioritise(timed_priority(((
							wbisim(STM(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av))
								[|MachineMemorySyncSet|]
							(wbisim(MemoryN(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)) [| union(WCsets,WCsync) |] Clocks(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av))\WCsets
						)
						[[
							obstacle__.x____ <- obstacle
							| x____ <- TIDS
						]]
						\MachineMemoryHidingSet)
						[|{|terminate|}|>SKIP\MachineInternalEvents)
						,<Union({internal_events, ClockResets, {|terminate|}}),{tock}>)
						
						internal_(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = prioritise(timed_priority(((
							wbisim(STM(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av))
								[|MachineMemorySyncSet|]
							(wbisim(MemoryN(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)) [| union(WCsets,WCsync) |] Clocks(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av))\WCsets
						)
						\MachineMemoryHidingSet)
						[|{|terminate|}|>SKIP)
						,<Union({internal_events, ClockResets, {|internal__,terminate|}}),{tock}>)		
						-- declare clocks
						datatype ClockSet = dummyC | CLID_MBC
						channel clockReset : ClockSet
									
						
						-- declare trigger deadlines channel
						channel deadline : TIDS.Signal
						
						-- compile clocks process
						
						-- set of strings that uniquely identify the waiting conditions, each of which is 
						-- used to synchronise with the Memory process to set the correspoding variable in
						-- the memory process.
						datatype setWC_identifierSet = dummyWC
						                             | WC_TID_SMovement_t3_0_ID
						
						-- declaring getWC and setWC channel for updating memory variables related to clocks
						channel setWC : setWC_identifierSet.Bool
						channel getWC : setWC_identifierSet.Bool
						
						-- Set of pairs capturing waiting condition processes and their alphabet.
						-- It includes the corresponding set of the defined operations.
						WCset(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = Union({
							{
							({|clockReset.CLID_MBC,SMovement::internal__.SMovement::TID_SMovement_t3,setWC.WC_TID_SMovement_t3_0_ID | x <- SIDS|},P_WC_TID_SMovement_t3_0(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av))
							}
							})
						-- Set of transition events for which synchronisation is required between Clocks and the Memory process.
						-- It includes the corresponding set of the defined operations.
						WCsync = Union({
							{|SMovement::internal__.SMovement::TID_SMovement_t3|}
							})
						-- Set of all clock resets, including 'clockReset.C' events and 'entered.x.y' events where x is drawn
						-- from the set of all state machine state identifiers. It includes the corresponding set of the defined operations.
						WCresets = Union({
							{|clockReset.CLID_MBC | x <- SIDS |}
							})
						-- Set of all waiting condition set events. It includes the corresponding set of the defined operations.
						WCsets = Union({
							{|setWC|}
							})
						
						P_WC_TID_SMovement_t3_0_reset(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = clockReset.CLID_MBC -> setWC.WC_TID_SMovement_t3_0_ID.false -> P_WC_TID_SMovement_t3_0_monitor(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
						
						P_WC_TID_SMovement_t3_0_monitor(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = (TimedInterrupt(RUN({|tock,SMovement::internal__.SMovement::TID_SMovement_t3|}),Div(const_SMovement_PI, const_SMovement_av, core_real)) ; setWC.WC_TID_SMovement_t3_0_ID.true -> RUN({|tock,SMovement::internal__.SMovement::TID_SMovement_t3|})) /\ P_WC_TID_SMovement_t3_0_reset(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
						
						P_WC_TID_SMovement_t3_0(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = setWC.WC_TID_SMovement_t3_0_ID.false -> P_WC_TID_SMovement_t3_0_monitor(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
						
						-- Clocks process
						Clocks(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = || (alpha, P) : WCset(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) @ [alpha] wbisim(P)
		
						-- collects all clockResets including those of operations
						ClockResets = Union({
							{|clockReset|}
											})
						
						-- With no internal events visible
						D__(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = timed_priority(AUX(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) \ union(internal_events,ClockResets))
						
						O__(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = D__(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
						
						-- With enter/entered/exit/exited events visible
						FVS__(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = timed_priority(AUX(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) \ ClockResets)
						
						-- With enterV/enteredV/exitV/exitedV events visible
						VS__(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = ShowV(timed_priority(AUX(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) \ ClockResets))
						
						-- With clock resets visible
						FVS_C__(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = AUX(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
					}
				endmodule
	
	
		Timed(OneStep) {
			-- declaring call and ret events for undefined operations
			channel moveCall, moveRet: core_real.core_real
	
			move(id__, lv, av) =  EDeadline(moveCall.lv.av,0); EDeadline(moveRet.lv.av,0)
			
						
			-- declaring controller events
			channel obstacle: InOut
							

		
			-- declaring controller memory
			Memory(id__) = SKIP
			-- declaring controller termination channel
			channel terminate
			
			-- set of visible memory events
			visibleMemoryEvents = {||}
		
			D__(id__) = prioritise(wbisim(
				(
					stm_ref0::D__(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)[[
						stm_ref0::terminate <- terminate,
						stm_ref0::obstacle <- obstacle,
						stm_ref0::moveCall <- moveCall,
						stm_ref0::moveRet <- moveRet
					]]
				)
					[|
						union(
							{|
							|},
							{|
							|}
						)
					|]
				Memory(id__)
			)
			\ union(
				{|
				|},
				{|
				|}
			)
			[|{|terminate|}|>SKIP,
			<union(visibleMemoryEvents,{terminate}),{tock}>)
			
			O__(id__) = D__(id__)
			
			-- VS version
			VS__(id__) = prioritise(wbisim(
				(
					stm_ref0::VS__(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)[[
						stm_ref0::terminate <- terminate,
						stm_ref0::obstacle <- obstacle,
						stm_ref0::moveCall <- moveCall,
						stm_ref0::moveRet <- moveRet
					]]
				)
					[|
						union(
							{|
							|},
							{|
							|}
						)
					|]
				Memory(id__)
			)
			\ union(
				{|
				|},
				{|
				|}
			)
			[|{|terminate|}|>SKIP,
			<union(visibleMemoryEvents,{terminate}),{tock}>)
		
			HEXT(id__) = D__(id__) [|shared_variable_events|] SKIP
		}
	endmodule

		module SMovement		
		exports
			-- definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
			external prioritise
			transparent wbisim		
		
			Timed(OneStep) {	
				-- flow channels
				channel internal__ : TIDS
				channel enteredV, enterV, exitV, exitedV : SIDS
				channel enter, entered: SIDS.SIDS
				channel exit,exited: SIDS.SIDS
				channel terminate
				
				-- variable channels
				channel get_x, set_x: core_nat
						
				-- shared variable channels
				
				-- local variable channels for defined operations that are required by the state machine
				
				-- declaring state machine events
				channel obstacle__: TIDS.InOut
				channel obstacle: InOut
				
				-- declaring call and ret events for undefined operations
				channel moveCall, moveRet: core_real.core_real
			
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machien module.
				move(id__, lv, av) =  EDeadline(moveCall.lv.av,0); EDeadline(moveRet.lv.av,0)
				
				
				
				-- definition of functions used to expose flow channels
				ShowEvents(P,E) = P[[ entered.x____.y____ <- enteredV.y____ | entered.x____.y____ <- E]]
								   [[ enter.x____.y____ <- enterV.y____ | enter.x____.y____ <- E]]
								   [[ exit.x____.y____ <- exitV.y____ | exit.x____.y____ <- E]]
								   [[ exited.x____.y____ <- exitedV.y____ | exited.x____.y____ <- E ]]
									 
				ShowEnteredV(P) = P[[ entered.x____.y____ <- enteredV.y____ | x____ <- SIDS, y____ <- SIDS ]]
				ShowEnterV(P) = P[[ enter.x____.y____ <- enterV.y____ | x____ <- SIDS, y____ <- SIDS ]]
				ShowExitV(P) = P[[ exit.x____.y____ <- exitV.y____ | x____ <- SIDS, y____ <- SIDS ]]
				ShowExitedV(P) = P[[ exited.x____.y____ <- exitedV.y____ | x____ <- SIDS, y____ <- SIDS ]]
				ShowV(P) = P[[ entered.x____.y____ <- enteredV.y____ | x____ <- SIDS, y____ <- SIDS]]
							[[ enter.x____.y____ <- enterV.y____ | x____ <- SIDS, y____ <- SIDS ]]
							[[ exit.x____.y____ <- exitV.y____ | x____ <- SIDS, y____ <- SIDS]]
							[[ exited.x____.y____ <- exitedV.y____ | x____ <- SIDS, y____ <- SIDS ]]
				
				-- declaring identifiers of state and final states
				datatype SIDS = SID_SMovement
				              | SID_SMovement_Moving
				              | SID_SMovement_Turning
				
				-- declaring identifiers of transitions
				datatype TIDS = NULLTRANSITION__
				              | TID_SMovement_t1
				              | TID_SMovement_t2
				              | TID_SMovement_t3
				
				-- declaring identifiers of transitions that can interupt a state (excludes transitions from junctions)
				
				ITIDS = {
					TID_SMovement_t2,	TID_SMovement_t3
				}
				
				int_int = {|
					obstacle__.TID_SMovement_t2,
					internal__.TID_SMovement_t2,
					obstacle__.TID_SMovement_t3,
					internal__.TID_SMovement_t3
				|}
					
				
				internal_events = {|enter,entered,exit,exited|}
				shared_variable_events = {|
				|}
						
				
				-- declaring all states
				CS_SMovement_Moving_sync = {|
					enter.y____.x____, 
					entered.y____.x____, 
					exit.y____.x____, 
					exited.y____.x____,
					enter.x____.y____, 
					entered.x____.y____, 
					exit.x____.y____, 
					exited.x____.y____ |
					x____ <- {SID_SMovement_Moving,SID_SMovement_Turning},
					y____ <- {SID_SMovement_Moving}
				|}
				
				
				SMovement_Moving_triggers = {|
					internal__.TID_SMovement_t3,
					obstacle__.TID_SMovement_t2
				|}
				
				State_SMovement_Moving(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = let
					T_SMovement_t2(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = obstacle__!TID_SMovement_t2.in -> DoClockReset({clockReset.CLID_MBC}) ;  (exit.SID_SMovement_Moving.SID_SMovement_Moving -> SKIP;
										SKIP;exited.SID_SMovement_Moving.SID_SMovement_Moving -> SKIP;
										enter!SID_SMovement_Moving!SID_SMovement_Turning -> entered!SID_SMovement_Moving!SID_SMovement_Turning ->
										State_SMovement_Moving(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
					)
					State_SMovement_Moving_execute(id__,o____,const_SMovement_lv,const_SMovement_PI,const_SMovement_av) = true&move(id__, const_SMovement_lv, 0);WAIT(1); 
						entered!o____!SID_SMovement_Moving ->
						(SKIP; STOP /\ (
							T_SMovement_t2(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
							[]
							internal__?x____:diff(ITIDS,{NULLTRANSITION__,TID_SMovement_t3,TID_SMovement_t2}) -> exit?y____:diff(SIDS,{SID_SMovement_Moving})!SID_SMovement_Moving -> (
									SKIP;
									exited!y____!SID_SMovement_Moving -> SKIP);
									State_SMovement_Moving(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
							[] obstacle__?x____:diff(ITIDS,{NULLTRANSITION__,TID_SMovement_t3,TID_SMovement_t2})?d____ ->	exit?y____:diff(SIDS,{SID_SMovement_Moving})!SID_SMovement_Moving -> (
									SKIP;
									exited!y____!SID_SMovement_Moving -> SKIP);
									State_SMovement_Moving(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
						))
				within
					enter?x____:diff(SIDS,{SID_SMovement_Moving})!SID_SMovement_Moving -> (State_SMovement_Moving_execute(id__,x____,const_SMovement_lv,const_SMovement_PI,const_SMovement_av))
				
				CS_SMovement_Turning_sync = {|
					enter.y____.x____, 
					entered.y____.x____, 
					exit.y____.x____, 
					exited.y____.x____,
					enter.x____.y____, 
					entered.x____.y____, 
					exit.x____.y____, 
					exited.x____.y____ |
					x____ <- {SID_SMovement_Moving,SID_SMovement_Turning},
					y____ <- {SID_SMovement_Turning}
				|}
				
				
				SMovement_Turning_triggers = {|
					internal__.TID_SMovement_t3,
					obstacle__.TID_SMovement_t2
				|}
				
				State_SMovement_Turning(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = let
					T_SMovement_t3(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = internal__!TID_SMovement_t3 ->  exit.SID_SMovement_Turning.SID_SMovement_Turning -> SKIP;
										SKIP;exited.SID_SMovement_Turning.SID_SMovement_Turning -> SKIP;
										enter!SID_SMovement_Turning!SID_SMovement_Moving -> entered!SID_SMovement_Turning!SID_SMovement_Moving ->
										State_SMovement_Turning(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
					State_SMovement_Turning_execute(id__,o____,const_SMovement_lv,const_SMovement_PI,const_SMovement_av) = true&move(id__, 0, const_SMovement_av); 
						entered!o____!SID_SMovement_Turning ->
						(SKIP; STOP /\ (
							T_SMovement_t3(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
							[]
							internal__?x____:diff(ITIDS,{NULLTRANSITION__,TID_SMovement_t3,TID_SMovement_t2}) -> exit?y____:diff(SIDS,{SID_SMovement_Turning})!SID_SMovement_Turning -> (
									SKIP;
									exited!y____!SID_SMovement_Turning -> SKIP);
									State_SMovement_Turning(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
							[] obstacle__?x____:diff(ITIDS,{NULLTRANSITION__,TID_SMovement_t3,TID_SMovement_t2})?d____ ->	exit?y____:diff(SIDS,{SID_SMovement_Turning})!SID_SMovement_Turning -> (
									SKIP;
									exited!y____!SID_SMovement_Turning -> SKIP);
									State_SMovement_Turning(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
						))
				within
					enter?x____:diff(SIDS,{SID_SMovement_Turning})!SID_SMovement_Turning -> (State_SMovement_Turning_execute(id__,x____,const_SMovement_lv,const_SMovement_PI,const_SMovement_av))
				
				
				I_SMovement_i1(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = let
					T_SMovement_t1(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = internal__!TID_SMovement_t1 -> enter!SID_SMovement!SID_SMovement_Moving -> entered!SID_SMovement!SID_SMovement_Moving ->
					SKIP
				within
					T_SMovement_t1(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
				
				
				State_SMovement_Moving_R(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = 
					State_SMovement_Moving(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
						[|diff(int_int,SMovement_Moving_triggers)|]
					SKIP
						 		
				State_SMovement_Turning_R(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = 
					State_SMovement_Turning(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
						[|diff(int_int,SMovement_Turning_triggers)|]
					SKIP
						 		
					
				STM(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = (
					I_SMovement_i1(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
						[|
							{|enter.x____.y____, entered.x____.y____, exit.x____.y____, exited.x____.y____ |
								x____ <- diff(SIDS,{SID_SMovement_Moving,SID_SMovement_Turning}),
								y____ <- {SID_SMovement_Moving,SID_SMovement_Turning}
						|}|]
					(
						State_SMovement_Moving_R(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
							[|inter(CS_SMovement_Moving_sync,CS_SMovement_Turning_sync)|]
						State_SMovement_Turning_R(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
					)
				)
				
				-- optimized memory process
				channel getV_x: core_nat
				
				-- individual memory processes
				Memory_x(x) = (
					get_x!x -> Memory_x(x)
					[]
					getV_x!x -> Memory_x(x)
					[]
					set_x?x__ -> Memory_x(x__)
				)
				Memory_WC_TID_SMovement_t3_0(WC_TID_SMovement_t3_0) = (
					getWC.WC_TID_SMovement_t3_0_ID!WC_TID_SMovement_t3_0 -> Memory_WC_TID_SMovement_t3_0(WC_TID_SMovement_t3_0)
					[]
					setWC.WC_TID_SMovement_t3_0_ID?x__ -> Memory_WC_TID_SMovement_t3_0(x__)
				)
				
				-- processes that read variables and offer transitions
				
				MemoryTransitions(id__, x, WC_TID_SMovement_t3_0, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = (internal__!TID_SMovement_t1 -> SKIP
				[]
				obstacle__!TID_SMovement_t2.in -> SKIP
				[]
				(WC_TID_SMovement_t3_0)&(internal__!TID_SMovement_t3 -> SKIP)
				[]
				set_x?x__ -> SKIP
				[]
				setWC.WC_TID_SMovement_t3_0_ID?x__ -> SKIP)
				
				MemoryTransitions_SMovement(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = (getV_x?x ->
				getWC.WC_TID_SMovement_t3_0_ID?WC_TID_SMovement_t3_0 ->
				MemoryTransitions(id__, x, WC_TID_SMovement_t3_0, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)			
				); MemoryTransitions_SMovement(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
						
				
				-- synchronisation, hiding and process sets 
				MemoryVariablesProcesses_SMovement = Union(
					{
						{
							(Memory_x(0),{|getV_x,get_x,set_x|}),
							(Memory_WC_TID_SMovement_t3_0(false),{|getWC.WC_TID_SMovement_t3_0_ID,setWC.WC_TID_SMovement_t3_0_ID|})
						}
					}
				)
				
				MemoryVariablesSyncSet = Union({
					{|
						getV_x,
						getWC.WC_TID_SMovement_t3_0_ID,
						setWC,
						setWC.WC_TID_SMovement_t3_0_ID,
						set_x
					|}	
				})
				
				MemoryVariablesHideSet = Union({
					{|
						getV_x,
						getWC
					|}
				})
				
				-- combined individual memory processes
				MemoryVariables = ||| (P, alpha) : MemoryVariablesProcesses_SMovement @ P
				
				-- complete memory process	
				MemoryN(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = (wbisim(MemoryVariables) [| MemoryVariablesSyncSet |] wbisim(MemoryTransitions_SMovement(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av))) \ MemoryVariablesHideSet
				
				-- main process
				
				MachineMemorySyncSet = Union({
					union(
						union(
							{|get_x,set_x|},
							{||}
						)
							
						,
						{|internal__.TID_SMovement_t1,
						obstacle__.TID_SMovement_t2,
						internal__.TID_SMovement_t3|}
					),
					{|deadline|},
					WCresets
				})
				
				MachineMemoryHidingSet = Union({
					union(
						{|get_x,set_x|},
						{||}
					)
					,
					{|deadline|}
				})
				
				MachineInternalEvents = {|
					internal__
				|}
			
				-- main process
				AUX(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = prioritise(timed_priority(((
					wbisim(STM(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av))
						[|MachineMemorySyncSet|]
					(wbisim(MemoryN(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)) [| union(WCsets,WCsync) |] Clocks(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av))\WCsets
				)
				[[
					obstacle__.x____ <- obstacle
					| x____ <- TIDS
				]]
				\MachineMemoryHidingSet)
				[|{|terminate|}|>SKIP\MachineInternalEvents)
				,<Union({internal_events, ClockResets, {|terminate|}}),{tock}>)
				
				internal_(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = prioritise(timed_priority(((
					wbisim(STM(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av))
						[|MachineMemorySyncSet|]
					(wbisim(MemoryN(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)) [| union(WCsets,WCsync) |] Clocks(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av))\WCsets
				)
				\MachineMemoryHidingSet)
				[|{|terminate|}|>SKIP)
				,<Union({internal_events, ClockResets, {|internal__,terminate|}}),{tock}>)		
				-- declare clocks
				datatype ClockSet = dummyC | CLID_MBC
				channel clockReset : ClockSet
							
				
				-- declare trigger deadlines channel
				channel deadline : TIDS.Signal
				
				-- compile clocks process
				
				-- set of strings that uniquely identify the waiting conditions, each of which is 
				-- used to synchronise with the Memory process to set the correspoding variable in
				-- the memory process.
				datatype setWC_identifierSet = dummyWC
				                             | WC_TID_SMovement_t3_0_ID
				
				-- declaring getWC and setWC channel for updating memory variables related to clocks
				channel setWC : setWC_identifierSet.Bool
				channel getWC : setWC_identifierSet.Bool
				
				-- Set of pairs capturing waiting condition processes and their alphabet.
				-- It includes the corresponding set of the defined operations.
				WCset(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = Union({
					{
					({|clockReset.CLID_MBC,SMovement::internal__.SMovement::TID_SMovement_t3,setWC.WC_TID_SMovement_t3_0_ID | x <- SIDS|},P_WC_TID_SMovement_t3_0(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av))
					}
					})
				-- Set of transition events for which synchronisation is required between Clocks and the Memory process.
				-- It includes the corresponding set of the defined operations.
				WCsync = Union({
					{|SMovement::internal__.SMovement::TID_SMovement_t3|}
					})
				-- Set of all clock resets, including 'clockReset.C' events and 'entered.x.y' events where x is drawn
				-- from the set of all state machine state identifiers. It includes the corresponding set of the defined operations.
				WCresets = Union({
					{|clockReset.CLID_MBC | x <- SIDS |}
					})
				-- Set of all waiting condition set events. It includes the corresponding set of the defined operations.
				WCsets = Union({
					{|setWC|}
					})
				
				P_WC_TID_SMovement_t3_0_reset(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = clockReset.CLID_MBC -> setWC.WC_TID_SMovement_t3_0_ID.false -> P_WC_TID_SMovement_t3_0_monitor(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
				
				P_WC_TID_SMovement_t3_0_monitor(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = (TimedInterrupt(RUN({|tock,SMovement::internal__.SMovement::TID_SMovement_t3|}),Div(const_SMovement_PI, const_SMovement_av, core_real)) ; setWC.WC_TID_SMovement_t3_0_ID.true -> RUN({|tock,SMovement::internal__.SMovement::TID_SMovement_t3|})) /\ P_WC_TID_SMovement_t3_0_reset(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
				
				P_WC_TID_SMovement_t3_0(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = setWC.WC_TID_SMovement_t3_0_ID.false -> P_WC_TID_SMovement_t3_0_monitor(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
				
				-- Clocks process
				Clocks(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = || (alpha, P) : WCset(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) @ [alpha] wbisim(P)

				-- collects all clockResets including those of operations
				ClockResets = Union({
					{|clockReset|}
									})
				
				-- With no internal events visible
				D__(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = timed_priority(AUX(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) \ union(internal_events,ClockResets))
				
				O__(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = D__(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
				
				-- With enter/entered/exit/exited events visible
				FVS__(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = timed_priority(AUX(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) \ ClockResets)
				
				-- With enterV/enteredV/exitV/exitedV events visible
				VS__(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = ShowV(timed_priority(AUX(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) \ ClockResets))
				
				-- With clock resets visible
				FVS_C__(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av) = AUX(id__, const_SMovement_lv, const_SMovement_PI, const_SMovement_av)
			}
		endmodule

module move
exports
	Timed(OneStep) {
	D__(id__) = let
	AUX(N) = if (N == 0) then SKIP else
		  SKIP
	      	      	within AUX(move_BOUND)
	
	O__(id__) = D__(id__)
	}
endmodule

