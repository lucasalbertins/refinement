transparent normal
include "SMovement_coreassertions.csp"
ID_AD = {1..1}
datatype alphabet_AD = DecisionNode_MergeNode0_AD_t_alphabet | InitialNode0_AD_t_alphabet| moveCall_0_2__AD_t_alphabet| accept_obstacle_1_AD_t_alphabet
robochart_AD = "SMovement_coreassertions.csp"
robochart_alphabet_AD = {|SMovement::moveCall,SMovement::obstacle.in,SMovement::obstacle.out|}
countCe_AD = {1..4}
countUpdate_AD = {1..1}
countClear_AD = {1..0}
limiteUpdate_AD = {(1)..(1)}
channel startActivity_AD: ID_AD
channel endActivity_AD: ID_AD
channel ce_AD: ID_AD.countCe_AD
channel clear_AD: ID_AD.countClear_AD
channel update_AD: ID_AD.countUpdate_AD.limiteUpdate_AD
channel endDiagram_AD: ID_AD
channel dc
channel begin, end:  {1..2}

alphabet_Astah = {| startActivity_AD, endActivity_AD, ce_AD, clear_AD, update_AD, endDiagram_AD, dc |}

MAIN = normal(AD(1))
END_DIAGRAM_AD(id) = endDiagram_AD.id -> SKIP
AD(ID_AD) = (Internal_AD(ID_AD) [|{|update_AD,clear_AD,endDiagram_AD|}|] TokenManager_AD_t(ID_AD,0,0))
Internal_AD(id) = StartActivity_AD(id); Node_AD(id); EndActivity_AD(id)
StartActivity_AD(id) = startActivity_AD.id -> SKIP
EndActivity_AD(id) = endActivity_AD.id -> SKIP
AlphabetDiagram_AD(id,DecisionNode_MergeNode0_AD_t_alphabet) = {|ce_AD.id.1,ce_AD.id.2,ce_AD.id.3,endDiagram_AD.id|}
AlphabetDiagram_AD(id,InitialNode0_AD_t_alphabet) = {|ce_AD.id.1,endDiagram_AD.id|}
AlphabetDiagram_AD(id,moveCall_0_2__AD_t_alphabet) = {|ce_AD.id.4,ce_AD.id.2,endDiagram_AD.id|}
AlphabetDiagram_AD(id,accept_obstacle_1_AD_t_alphabet) = {|ce_AD.id.3,ce_AD.id.4,endDiagram_AD.id|}
AlphabetDiagram_AD_t(id) = union(union(union(AlphabetDiagram_AD(id,DecisionNode_MergeNode0_AD_t_alphabet),AlphabetDiagram_AD(id,InitialNode0_AD_t_alphabet)),AlphabetDiagram_AD(id,moveCall_0_2__AD_t_alphabet)),AlphabetDiagram_AD(id,accept_obstacle_1_AD_t_alphabet))

ProcessDiagram_AD(id,DecisionNode_MergeNode0_AD_t_alphabet) = normal(DecisionNode_MergeNode0_AD_t(id))
ProcessDiagram_AD(id,InitialNode0_AD_t_alphabet) = normal(InitialNode0_AD_t(id))
ProcessDiagram_AD(id,moveCall_0_2__AD_t_alphabet) = normal(moveCall_0_2__AD_t(id))
ProcessDiagram_AD(id,accept_obstacle_1_AD_t_alphabet) = normal(accept_obstacle_1_AD_t(id))
InitialNode0_AD(id) = update_AD.id.1!(1-0) -> ((ce_AD.id.1 -> SKIP))
InitialNode0_AD_t(id) = InitialNode0_AD(id) /\ END_DIAGRAM_AD(id)
DecisionNode_MergeNode0_AD(id) = ((ce_AD.id.1 -> SKIP) [] (ce_AD.id.2 -> SKIP)); ce_AD.id.3 -> DecisionNode_MergeNode0_AD(id)
DecisionNode_MergeNode0_AD_t(id) = DecisionNode_MergeNode0_AD(id) /\ END_DIAGRAM_AD(id)
moveCall_0_2__AD(id) = ((ce_AD.id.4 -> SKIP)); begin.1 -> end.1 -> SKIP; ((ce_AD.id.2 -> SKIP)); moveCall_0_2__AD(id)
moveCall_0_2__AD_t(id) = moveCall_0_2__AD(id) /\ END_DIAGRAM_AD(id)
accept_obstacle_1_AD(id) = ((ce_AD.id.3 -> SKIP)); begin.2 -> end.2 -> SKIP; ((ce_AD.id.4 -> SKIP)); accept_obstacle_1_AD(id)
accept_obstacle_1_AD_t(id) = accept_obstacle_1_AD(id) /\ END_DIAGRAM_AD(id)

TokenManager_AD(id,x,init) = update_AD.id?c?y:limiteUpdate_AD -> x+y < 10 & x+y > -10 & TokenManager_AD(id,x+y,1) [] clear_AD.id?c -> endDiagram_AD.id -> SKIP [] x == 0 & init == 1 & endDiagram_AD.id -> SKIP
TokenManager_AD_t(id,x,init) = TokenManager_AD(id,x,init)

assert MAIN :[deadlock free]
assert MAIN :[divergence free]
assert MAIN :[deterministic]

NRecurse(S, P) = |~| ev : S @ ev -> P

WAIT(alphabet,event) = 
	NRecurse(diff(alphabet, {event}), WAIT(alphabet,event))
	|~|
	event -> SKIP

WAIT_PROCCESSES(processes) = ( ||| CONTROL : processes @ CONTROL )  /\ endDiagram_AD?id -> SKIP

Prop = PROP(Wait_control_processes) \ alphabet_Astah 

alphabet_robochart_AD = {|SMovement::moveCall,SMovement::obstacle.in,SMovement::obstacle.out|}

PROP(processes) = (MAIN [|{|begin, end, endDiagram_AD|}|] WAIT_PROCCESSES(processes) ) \ {|begin, end|}

Wait_AD_1 = WAIT(alphabet_robochart_AD, SMovement::moveCall.0.2)

Wait_AD_control_1 = begin.1 -> Wait_AD_1; end.1 -> Wait_AD_control_1

Wait_AD_2 = WAIT(alphabet_robochart_AD, SMovement::obstacle.in)

Wait_AD_control_2 = begin.2 -> Wait_AD_2; end.2 -> Wait_AD_control_2

Wait_control_processes = {Wait_AD_control_1, Wait_AD_control_2}


Node_AD(id) = composeNodes(id)

composeNodes(id) = 
	let
	    alphabet_AD_s = seq(alphabet_AD)
		composeNodes_(id,<ev>,_) = ProcessDiagram_AD(id,ev)
		composeNodes_(id,<ev>^tail,past) = 
			ProcessDiagram_AD(id,ev) 
				[|union(diff(AlphabetDiagram_AD(id,ev),past),{endDiagram_AD.id})|] 
			( composeNodes_(id,tail,union(past,AlphabetDiagram_AD(id,ev))) )
	within 
		composeNodes_(id,alphabet_AD_s,{})