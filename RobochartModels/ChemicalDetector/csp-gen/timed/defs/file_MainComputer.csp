

	module MainComputer
		Timed(OneStep) {
			shared_variable_events = {|
			|}		
		}	
	exports
		transparent diamond
		transparent sbisim
		transparent wbisim
		transparent chase
		
				module stm_ref0
				exports
					-- definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					external prioritise
					transparent wbisim
					transparent dbisim
					transparent sbisim
				
					Timed(OneStep) {	
						-- flow channels
						channel internal__ : TIDS
						channel enteredV, enterV, exitV, exitedV : SIDS
						channel enter, entered: SIDS.SIDS
						channel exit,exited: SIDS.SIDS
						channel terminate
						
						-- variable channels
						channel get_c, set_c: Command
								
						-- shared variable channels
						
						-- local variable channels for defined operations that are required by the state machine
						
						-- declaring state machine events
						channel cd__: TIDS.InOut.Command
						channel cd: InOut.Command
						channel turn__: TIDS.InOut.core_real
						channel turn: InOut.core_real
						
						-- declaring call and ret events for undefined operations
						channel incrCall
						channel decrCall
					
						-- Only the undefined operations are declared here.
						-- If the state machine is in isolation, all required operations will be undefined.
						-- If it is in the context of a controller, the required operations not provided by the
						-- controller will be declared here, and the defined operations will be defined in the
						-- context of the Controller module, and therefore within scope of the state machien module.
						CALL__incr(id__) =  EDeadline(incrCall,0)		
						CALL__decr(id__) =  EDeadline(decrCall,0)		
						
						
						-- definition of functions used to expose flow channels
						ShowEvents(P,E) = P[[ entered.x____.y____ <- enteredV.y____ | entered.x____.y____ <- E]]
										   [[ enter.x____.y____ <- enterV.y____ | enter.x____.y____ <- E]]
										   [[ exit.x____.y____ <- exitV.y____ | exit.x____.y____ <- E]]
										   [[ exited.x____.y____ <- exitedV.y____ | exited.x____.y____ <- E ]]
											 
						ShowEnteredV(P) = P[[ entered.x____.y____ <- enteredV.y____ | x____ <- SIDS, y____ <- SIDS ]]
						ShowEnterV(P) = P[[ enter.x____.y____ <- enterV.y____ | x____ <- SIDS, y____ <- SIDS ]]
						ShowExitV(P) = P[[ exit.x____.y____ <- exitV.y____ | x____ <- SIDS, y____ <- SIDS ]]
						ShowExitedV(P) = P[[ exited.x____.y____ <- exitedV.y____ | x____ <- SIDS, y____ <- SIDS ]]
						ShowV(P) = P[[ entered.x____.y____ <- enteredV.y____ | x____ <- SIDS, y____ <- SIDS]]
									[[ enter.x____.y____ <- enterV.y____ | x____ <- SIDS, y____ <- SIDS ]]
									[[ exit.x____.y____ <- exitV.y____ | x____ <- SIDS, y____ <- SIDS]]
									[[ exited.x____.y____ <- exitedV.y____ | x____ <- SIDS, y____ <- SIDS ]]
						
						-- declaring identifiers of state and final states
						datatype SIDS = SID_Moving
						              | SID_Moving_Waiting
						
						-- declaring identifiers of transitions
						datatype TIDS = NULLTRANSITION__
						              | TID_Moving_t1
						              | TID_Moving_t2
						              | TID_Moving_t3
						              | TID_Moving_t4
						              | TID_Moving_t5
						              | TID_Moving_t6
						
						-- declaring identifiers of transitions that can interupt a state (excludes transitions from junctions)
						
						ITIDS = {
							TID_Moving_t2,	TID_Moving_t3,	TID_Moving_t4,	TID_Moving_t5,	TID_Moving_t6
						}
						
						int_int = {|
							cd__.TID_Moving_t2,
							turn__.TID_Moving_t2,
							internal__.TID_Moving_t2,
							cd__.TID_Moving_t3,
							turn__.TID_Moving_t3,
							internal__.TID_Moving_t3,
							cd__.TID_Moving_t4,
							turn__.TID_Moving_t4,
							internal__.TID_Moving_t4,
							cd__.TID_Moving_t5,
							turn__.TID_Moving_t5,
							internal__.TID_Moving_t5,
							cd__.TID_Moving_t6,
							turn__.TID_Moving_t6,
							internal__.TID_Moving_t6
						|}
							
						
						internal_events = {|enter,entered,exit,exited|}
						shared_variable_events = {|
						|}
								
						
						-- declaring all states
						CS_Moving_Waiting_sync = {|
							enter.y____.x____, 
							entered.y____.x____, 
							exit.y____.x____, 
							exited.y____.x____,
							enter.x____.y____, 
							entered.x____.y____, 
							exit.x____.y____, 
							exited.x____.y____ |
							x____ <- {SID_Moving_Waiting},
							y____ <- {SID_Moving_Waiting}
						|}
						
						
						Moving_Waiting_triggers = {|
							cd__.TID_Moving_t3,
							cd__.TID_Moving_t4,
							cd__.TID_Moving_t6,
							cd__.TID_Moving_t2,
							cd__.TID_Moving_t5
						|}
						
						State_Moving_Waiting(id__) = let
							T_Moving_t2(id__) = cd__!TID_Moving_t2.in?c -> set_c!c ->  (exit.SID_Moving_Waiting.SID_Moving_Waiting -> SKIP;
												SKIP;exited.SID_Moving_Waiting.SID_Moving_Waiting -> SKIP;
												true&(turn.out!(Neg(90, core_int)) -> SKIP);enter!SID_Moving_Waiting!SID_Moving_Waiting -> State_Moving_Waiting_execute(id__,SID_Moving_Waiting)
							)
							T_Moving_t3(id__) = cd__!TID_Moving_t3.in?c -> set_c!c ->  (exit.SID_Moving_Waiting.SID_Moving_Waiting -> SKIP;
												SKIP;exited.SID_Moving_Waiting.SID_Moving_Waiting -> SKIP;
												true&(turn.out.90 -> SKIP);enter!SID_Moving_Waiting!SID_Moving_Waiting -> State_Moving_Waiting_execute(id__,SID_Moving_Waiting)
							)
							T_Moving_t4(id__) = cd__!TID_Moving_t4.in?c -> set_c!c ->  (exit.SID_Moving_Waiting.SID_Moving_Waiting -> SKIP;
												SKIP;exited.SID_Moving_Waiting.SID_Moving_Waiting -> SKIP;
												true&(turn.out.180 -> SKIP);enter!SID_Moving_Waiting!SID_Moving_Waiting -> State_Moving_Waiting_execute(id__,SID_Moving_Waiting)
							)
							T_Moving_t5(id__) = cd__!TID_Moving_t5.in?c -> set_c!c ->  (exit.SID_Moving_Waiting.SID_Moving_Waiting -> SKIP;
												SKIP;exited.SID_Moving_Waiting.SID_Moving_Waiting -> SKIP;
												true&CALL__incr(
															id__
														);enter!SID_Moving_Waiting!SID_Moving_Waiting -> State_Moving_Waiting_execute(id__,SID_Moving_Waiting)
							)
							T_Moving_t6(id__) = cd__!TID_Moving_t6.in?c -> set_c!c ->  (exit.SID_Moving_Waiting.SID_Moving_Waiting -> SKIP;
												SKIP;exited.SID_Moving_Waiting.SID_Moving_Waiting -> SKIP;
												true&CALL__decr(
															id__
														);enter!SID_Moving_Waiting!SID_Moving_Waiting -> State_Moving_Waiting_execute(id__,SID_Moving_Waiting)
							)
							State_Moving_Waiting_execute(id__,o____) = SKIP; 
								entered!o____!SID_Moving_Waiting ->
								(SKIP; STOP /\ (
									T_Moving_t2(id__)[]
									T_Moving_t3(id__)[]
									T_Moving_t4(id__)[]
									T_Moving_t5(id__)[]
									T_Moving_t6(id__)
									[]
									internal__?x____:diff(ITIDS,{NULLTRANSITION__,TID_Moving_t3,TID_Moving_t4,TID_Moving_t6,TID_Moving_t2,TID_Moving_t5}) -> exit?y____:diff(SIDS,{SID_Moving_Waiting})!SID_Moving_Waiting -> (
											SKIP;
											exited!y____!SID_Moving_Waiting -> SKIP);
											State_Moving_Waiting(id__)
									[] cd__?x____:diff(ITIDS,{NULLTRANSITION__,TID_Moving_t3,TID_Moving_t4,TID_Moving_t6,TID_Moving_t2,TID_Moving_t5})?d____?aux____ ->	exit?y____:diff(SIDS,{SID_Moving_Waiting})!SID_Moving_Waiting -> (
											SKIP;
											exited!y____!SID_Moving_Waiting -> SKIP);
											State_Moving_Waiting(id__)
									[] turn__?x____:diff(ITIDS,{NULLTRANSITION__,TID_Moving_t3,TID_Moving_t4,TID_Moving_t6,TID_Moving_t2,TID_Moving_t5})?d____?aux____ ->	exit?y____:diff(SIDS,{SID_Moving_Waiting})!SID_Moving_Waiting -> (
											SKIP;
											exited!y____!SID_Moving_Waiting -> SKIP);
											State_Moving_Waiting(id__)
								))
						within
							enter?x____:diff(SIDS,{SID_Moving_Waiting})!SID_Moving_Waiting -> (State_Moving_Waiting_execute(id__,x____))
						
						
						I_Moving_i1(id__) = let
							T_Moving_t1(id__) = internal__!TID_Moving_t1 -> enter!SID_Moving!SID_Moving_Waiting -> entered!SID_Moving!SID_Moving_Waiting ->
							SKIP
						within
							T_Moving_t1(id__)
						
						
						State_Moving_Waiting_R(id__) = 
							State_Moving_Waiting(id__)
								[|diff(int_int,Moving_Waiting_triggers)|]
							SKIP
								 		
							
						STM(id__) = (
							I_Moving_i1(id__)
								[|
									{|enter.x____.y____, entered.x____.y____, exit.x____.y____, exited.x____.y____ |
										x____ <- diff(SIDS,{SID_Moving_Waiting}),
										y____ <- {SID_Moving_Waiting}
								|}|]
							State_Moving_Waiting_R(id__)
						)
						
						-- optimized memory process
						channel getV_c: Command
						
						-- individual memory processes
						Memory_c(x__) = ( 
							get_c!x__ -> Memory_c(x__)
							[]
							getV_c!x__ -> Memory_c(x__)
							[]
							set_c?x__ -> Memory_c(x__)
							[]
							cd__!TID_Moving_t2.in?c -> Memory_c(c)
							[]
							cd__!TID_Moving_t3.in?c -> Memory_c(c)
							[]
							cd__!TID_Moving_t4.in?c -> Memory_c(c)
							[]
							cd__!TID_Moving_t5.in?c -> Memory_c(c)
							[]
							cd__!TID_Moving_t6.in?c -> Memory_c(c)
						)
						
						-- processes that read variables and offer transitions
						MemoryTransitions(id__,
							 c) = (
							internal__!TID_Moving_t1 -> SKIP
							[]
							cd__!TID_Moving_t2.in?c:{c|c <- Command, (c==Command_left)} -> SKIP
							[]
							cd__!TID_Moving_t3.in?c:{c|c <- Command, (c==Command_right)} -> SKIP
							[]
							cd__!TID_Moving_t4.in?c:{c|c <- Command, (c==Command_back)} -> SKIP
							[]
							cd__!TID_Moving_t5.in?c:{c|c <- Command, (c==Command_faster)} -> SKIP
							[]
							cd__!TID_Moving_t6.in?c:{c|c <- Command, (c==Command_slower)} -> SKIP
						
							[]
								set_c?x__ -> SKIP
						 	)
						MemoryTransitions_Moving(id__) =
							(
							getV_c?c ->
							 MemoryTransitions(id__,
							 	 c);
							 MemoryTransitions_Moving(id__)
							)
						
						-- synchronisation, hiding and process sets 
						MemoryVariablesProcesses_Moving = Union(
							{
								{
									Memory_c(Command_faster)
								}
							}
						)
						
						MemoryVariablesSyncSet = Union({
							{|
								cd__.TID_Moving_t6,
								set_c,
								cd__.TID_Moving_t4,
								cd__.TID_Moving_t5,
								cd__.TID_Moving_t2,
								cd__.TID_Moving_t3,
								setWC,
								getV_c
							|}	
						})
						
						MemoryVariablesHideSet = Union({
							{|
								getWC,
								getV_c
							|}
						})
						
						-- combined individual memory processes
						MemoryVariables = ||| P : MemoryVariablesProcesses_Moving @ P
						
						-- complete memory process
						MemoryN(id__) = (MemoryVariables [| MemoryVariablesSyncSet |] MemoryTransitions_Moving(id__)) \ MemoryVariablesHideSet
						
						-- optimised memory
						-- Sets of named elements identified according to transition conditions:
						-- {}
						-- Summary of all identified named elements:
						-- {
						-- c
						-- }
						
						-- Allocation plan:
						-- 0:{}
						--	=> {
						--		TID_Moving_t4,
						--		TID_Moving_t5,
						--		TID_Moving_t3,
						--		TID_Moving_t1,
						--		TID_Moving_t6,
						--		TID_Moving_t2}
						
						-- Memory transition processes
						MemoryTransitions_opt_0(id__) =
						(
							let
								Update = Current(id__)
								Current(id__)
								 	   = 
								 	   cd__!TID_Moving_t4.in?c:{c|c <- Command, (c==Command_back)} -> Update
								 	   []
								 	   cd__!TID_Moving_t5.in?c:{c|c <- Command, (c==Command_faster)} -> Update
								 	   []
								 	   cd__!TID_Moving_t3.in?c:{c|c <- Command, (c==Command_right)} -> Update
								 	   []
								 	   internal__!TID_Moving_t1 -> Update
								 	   []
								 	   cd__!TID_Moving_t6.in?c:{c|c <- Command, (c==Command_slower)} -> Update
								 	   []
								 	   cd__!TID_Moving_t2.in?c:{c|c <- Command, (c==Command_left)} -> Update
							within
								Update
						)
						
						-- Memory cell processes
						Memory_opt_c(x__) = ( 
							get_c!x__ -> Memory_opt_c(x__)
							[]
							set_c?x__ -> Memory_opt_c(x__)
						)
						
						-- Composition of memory, StateMachine and Memory transition processes
						
						MemorySTM_opt(id__) =
							sbisim(	
							  dbisim(
							    sbisim(dbisim(sbisim(Memory_opt_c(Command_faster)
							          	[| {|get_c,set_c|} |] 
							          	STM_core(id__)
							          	)\ {|get_c,set_c|}
							          )
							      	  [| {|internal__.TID_Moving_t1,cd__.TID_Moving_t6,cd__.TID_Moving_t4,cd__.TID_Moving_t5,cd__.TID_Moving_t2,cd__.TID_Moving_t3|} |]
							      	  MemoryTransitions_opt_0(id__)
							      	  )\{|internal__.TID_Moving_t1|})
							      )
						
						-- main process
						
						MachineMemorySyncSet = Union({
							union(
								union(
									{|get_c,set_c|},
									{||}
								)
									
								,
								{|internal__.TID_Moving_t1,
								cd__.TID_Moving_t2,
								cd__.TID_Moving_t3,
								cd__.TID_Moving_t4,
								cd__.TID_Moving_t5,
								cd__.TID_Moving_t6|}
							),
							{|deadline|},
							WCresets
						})
						
						MachineMemoryHidingSet = Union({
							union(
								{|get_c,set_c|},
								{||}
							)
							,
							{|deadline|}
						})
						
						MachineInternalEvents = {|
							internal__
						|}
					
						-- main process
						AUX(id__) = prioritise((((
							wbisim(STM(id__))
								[|MachineMemorySyncSet|]
							(
								(MemoryN(id__))
									[| union(WCsets,WCsync) |]
								Clocks(id__)
							)\WCsets
						)
						[[
							cd__.x____ <- cd,
							turn__.x____ <- turn
							| x____ <- TIDS
						]]
						\MachineMemoryHidingSet)
						[|{|terminate|}|>SKIP\MachineInternalEvents)
						,<Union({internal_events, ClockResets, {|terminate|}}),{tock}>)
						
						STM_core(id__) = 
							dbisim(
								sbisim(
										(STM(id__)
										[| union(WCsync,WCresets) |]
										Clocks(id__))\WCresets
									  )
								  )
						
						AUX_opt(id__) = 
							prioritise(
								(MemorySTM_opt(id__)
								)[[
									cd__.x____ <- cd,
									turn__.x____ <- turn
									| x____ <- TIDS
								]]
							[|{|terminate|}|>SKIP\MachineInternalEvents
							,<Union({internal_events, ClockResets, {|terminate|}}),{tock}>)
						
						internal_(id__) = prioritise((((
							wbisim(STM(id__))
								[|MachineMemorySyncSet|]
							((MemoryN(id__)) [| union(WCsets,WCsync) |] Clocks(id__))\WCsets
						)
						\MachineMemoryHidingSet)
						[|{|terminate|}|>SKIP)
						,<Union({internal_events, ClockResets, {|internal__,terminate|}}),{tock}>)		
						-- declare clocks
						datatype ClockSet = dummyC
						channel clockReset 				-- no clocks declared
						
						-- declare trigger deadlines channel
						channel deadline : TIDS.Signal
						
						-- compile clocks process
						
						-- set of strings that uniquely identify the waiting conditions, each of which is 
						-- used to synchronise with the Memory process to set the correspoding variable in
						-- the memory process.
						datatype setWC_identifierSet = dummyWC
						
						-- declaring getWC and setWC channel for updating memory variables related to clocks
						channel setWC : setWC_identifierSet.Bool
						channel getWC : setWC_identifierSet.Bool
						
						-- Set of pairs capturing waiting condition processes and their alphabet.
						-- It includes the corresponding set of the defined operations.
						WCset(id__) = Union({
							{
							}
							})
						
						-- Auxiliary function to rename the channel set for required clocks.
						
						-- Set of transition events for which synchronisation is required between Clocks and the Memory process.
						-- It includes the corresponding set of the defined operations.
						WCsync = Union({
							{||}
							})
						-- Set of all clock resets, including 'clockReset.C' events and 'entered.x.y' events where x is drawn
						-- from the set of all state machine state identifiers. It includes the corresponding set of the defined operations.
						WCresets = Union({
							{| | x <- SIDS |}
							})
						-- Set of all waiting condition set events. It includes the corresponding set of the defined operations.
						WCsets = Union({
							{|setWC|}
							})
						
						
						
						-- Clocks process
						Clocks(id__) = || (alpha, P) : WCset(id__) @ [alpha] wbisim(P)
		
						-- collects all clockResets including those of operations
						ClockResets = Union({
							{|clockReset|}
											})
						
						-- With no internal events visible
						Dunopt__(id__) = timed_priority(AUX(id__) \ union(internal_events,ClockResets))
						
						D__(id__) = timed_priority(AUX_opt(id__) \ union(internal_events,ClockResets))
						
						O__(id__) = D__(id__)
						
						-- With enter/entered/exit/exited events visible
						FVS__(id__) = timed_priority(AUX(id__) \ ClockResets)
						
						-- With enterV/enteredV/exitV/exitedV events visible
						VS__(id__) = ShowV(timed_priority(AUX(id__) \ ClockResets))
						
						-- With clock resets visible
						FVS_C__(id__) = AUX(id__)
					}
				endmodule
				module stm_ref1
				exports
					-- definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					external prioritise
					transparent wbisim
					transparent dbisim
					transparent sbisim
				
					Timed(OneStep) {	
						-- flow channels
						channel internal__ : TIDS
						channel enteredV, enterV, exitV, exitedV : SIDS
						channel enter, entered: SIDS.SIDS
						channel exit,exited: SIDS.SIDS
						channel terminate
						
						-- variable channels
								
						-- shared variable channels
						
						-- local variable channels for defined operations that are required by the state machine
						
						-- declaring state machine events
						channel gas__: TIDS.InOut
						channel gas: InOut
						channel detect__: TIDS.InOut.Chemical
						channel detect: InOut.Chemical
						
						-- declaring call and ret events for undefined operations
					
						-- Only the undefined operations are declared here.
						-- If the state machine is in isolation, all required operations will be undefined.
						-- If it is in the context of a controller, the required operations not provided by the
						-- controller will be declared here, and the defined operations will be defined in the
						-- context of the Controller module, and therefore within scope of the state machien module.
						
						
						-- definition of functions used to expose flow channels
						ShowEvents(P,E) = P[[ entered.x____.y____ <- enteredV.y____ | entered.x____.y____ <- E]]
										   [[ enter.x____.y____ <- enterV.y____ | enter.x____.y____ <- E]]
										   [[ exit.x____.y____ <- exitV.y____ | exit.x____.y____ <- E]]
										   [[ exited.x____.y____ <- exitedV.y____ | exited.x____.y____ <- E ]]
											 
						ShowEnteredV(P) = P[[ entered.x____.y____ <- enteredV.y____ | x____ <- SIDS, y____ <- SIDS ]]
						ShowEnterV(P) = P[[ enter.x____.y____ <- enterV.y____ | x____ <- SIDS, y____ <- SIDS ]]
						ShowExitV(P) = P[[ exit.x____.y____ <- exitV.y____ | x____ <- SIDS, y____ <- SIDS ]]
						ShowExitedV(P) = P[[ exited.x____.y____ <- exitedV.y____ | x____ <- SIDS, y____ <- SIDS ]]
						ShowV(P) = P[[ entered.x____.y____ <- enteredV.y____ | x____ <- SIDS, y____ <- SIDS]]
									[[ enter.x____.y____ <- enterV.y____ | x____ <- SIDS, y____ <- SIDS ]]
									[[ exit.x____.y____ <- exitV.y____ | x____ <- SIDS, y____ <- SIDS]]
									[[ exited.x____.y____ <- exitedV.y____ | x____ <- SIDS, y____ <- SIDS ]]
						
						-- declaring identifiers of state and final states
						datatype SIDS = SID_Detecting
						              | SID_Detecting_CleanAir
						              | SID_Detecting_GasPresent
						
						-- declaring identifiers of transitions
						datatype TIDS = NULLTRANSITION__
						              | TID_Detecting_t1
						              | TID_Detecting_t2
						              | TID_Detecting_t3
						              | TID_Detecting_t4
						
						-- declaring identifiers of transitions that can interupt a state (excludes transitions from junctions)
						
						ITIDS = {
							TID_Detecting_t2,	TID_Detecting_t3,	TID_Detecting_t4
						}
						
						int_int = {|
							gas__.TID_Detecting_t2,
							detect__.TID_Detecting_t2,
							internal__.TID_Detecting_t2,
							gas__.TID_Detecting_t3,
							detect__.TID_Detecting_t3,
							internal__.TID_Detecting_t3,
							gas__.TID_Detecting_t4,
							detect__.TID_Detecting_t4,
							internal__.TID_Detecting_t4
						|}
							
						
						internal_events = {|enter,entered,exit,exited|}
						shared_variable_events = {|
						|}
								
						
						-- declaring all states
						CS_Detecting_CleanAir_sync = {|
							enter.y____.x____, 
							entered.y____.x____, 
							exit.y____.x____, 
							exited.y____.x____,
							enter.x____.y____, 
							entered.x____.y____, 
							exit.x____.y____, 
							exited.x____.y____ |
							x____ <- {SID_Detecting_CleanAir,SID_Detecting_GasPresent},
							y____ <- {SID_Detecting_CleanAir}
						|}
						
						
						Detecting_CleanAir_triggers = {|
							gas__.TID_Detecting_t2,
							detect__.TID_Detecting_t4,
							detect__.TID_Detecting_t3
						|}
						
						State_Detecting_CleanAir(id__) = let
							T_Detecting_t2(id__) = gas__!TID_Detecting_t2.in ->  (exit.SID_Detecting_CleanAir.SID_Detecting_CleanAir -> SKIP;
												SKIP;exited.SID_Detecting_CleanAir.SID_Detecting_CleanAir -> SKIP;
												enter!SID_Detecting_CleanAir!SID_Detecting_GasPresent -> entered!SID_Detecting_CleanAir!SID_Detecting_GasPresent ->
												State_Detecting_CleanAir(id__)
							)
							State_Detecting_CleanAir_execute(id__,o____) = SKIP; 
								entered!o____!SID_Detecting_CleanAir ->
								(SKIP; STOP /\ (
									T_Detecting_t2(id__)
									[]
									internal__?x____:diff(ITIDS,{NULLTRANSITION__,TID_Detecting_t2,TID_Detecting_t4,TID_Detecting_t3}) -> exit?y____:diff(SIDS,{SID_Detecting_CleanAir})!SID_Detecting_CleanAir -> (
											SKIP;
											exited!y____!SID_Detecting_CleanAir -> SKIP);
											State_Detecting_CleanAir(id__)
									[] gas__?x____:diff(ITIDS,{NULLTRANSITION__,TID_Detecting_t2,TID_Detecting_t4,TID_Detecting_t3})?d____ ->	exit?y____:diff(SIDS,{SID_Detecting_CleanAir})!SID_Detecting_CleanAir -> (
											SKIP;
											exited!y____!SID_Detecting_CleanAir -> SKIP);
											State_Detecting_CleanAir(id__)
									[] detect__?x____:diff(ITIDS,{NULLTRANSITION__,TID_Detecting_t2,TID_Detecting_t4,TID_Detecting_t3})?d____?aux____ ->	exit?y____:diff(SIDS,{SID_Detecting_CleanAir})!SID_Detecting_CleanAir -> (
											SKIP;
											exited!y____!SID_Detecting_CleanAir -> SKIP);
											State_Detecting_CleanAir(id__)
								))
						within
							enter?x____:diff(SIDS,{SID_Detecting_CleanAir})!SID_Detecting_CleanAir -> (State_Detecting_CleanAir_execute(id__,x____))
						
						CS_Detecting_GasPresent_sync = {|
							enter.y____.x____, 
							entered.y____.x____, 
							exit.y____.x____, 
							exited.y____.x____,
							enter.x____.y____, 
							entered.x____.y____, 
							exit.x____.y____, 
							exited.x____.y____ |
							x____ <- {SID_Detecting_CleanAir,SID_Detecting_GasPresent},
							y____ <- {SID_Detecting_GasPresent}
						|}
						
						
						Detecting_GasPresent_triggers = {|
							detect__.TID_Detecting_t4,
							gas__.TID_Detecting_t2,
							detect__.TID_Detecting_t3
						|}
						
						State_Detecting_GasPresent(id__) = let
							T_Detecting_t3(id__) = detect__!TID_Detecting_t3.in?aux____ ->  (exit.SID_Detecting_GasPresent.SID_Detecting_GasPresent -> SKIP;
												SKIP;exited.SID_Detecting_GasPresent.SID_Detecting_GasPresent -> SKIP;
												enter!SID_Detecting_GasPresent!SID_Detecting_CleanAir -> entered!SID_Detecting_GasPresent!SID_Detecting_CleanAir ->
												State_Detecting_GasPresent(id__)
							)
							T_Detecting_t4(id__) = detect__!TID_Detecting_t4.in?aux____ ->  (exit.SID_Detecting_GasPresent.SID_Detecting_GasPresent -> SKIP;
												SKIP;exited.SID_Detecting_GasPresent.SID_Detecting_GasPresent -> SKIP;
												enter!SID_Detecting_GasPresent!SID_Detecting_CleanAir -> entered!SID_Detecting_GasPresent!SID_Detecting_CleanAir ->
												State_Detecting_GasPresent(id__)
							)
							State_Detecting_GasPresent_execute(id__,o____) = SKIP; 
								entered!o____!SID_Detecting_GasPresent ->
								(SKIP; STOP /\ (
									T_Detecting_t3(id__)[]
									T_Detecting_t4(id__)
									[]
									internal__?x____:diff(ITIDS,{NULLTRANSITION__,TID_Detecting_t4,TID_Detecting_t2,TID_Detecting_t3}) -> exit?y____:diff(SIDS,{SID_Detecting_GasPresent})!SID_Detecting_GasPresent -> (
											SKIP;
											exited!y____!SID_Detecting_GasPresent -> SKIP);
											State_Detecting_GasPresent(id__)
									[] gas__?x____:diff(ITIDS,{NULLTRANSITION__,TID_Detecting_t4,TID_Detecting_t2,TID_Detecting_t3})?d____ ->	exit?y____:diff(SIDS,{SID_Detecting_GasPresent})!SID_Detecting_GasPresent -> (
											SKIP;
											exited!y____!SID_Detecting_GasPresent -> SKIP);
											State_Detecting_GasPresent(id__)
									[] detect__?x____:diff(ITIDS,{NULLTRANSITION__,TID_Detecting_t4,TID_Detecting_t2,TID_Detecting_t3})?d____?aux____ ->	exit?y____:diff(SIDS,{SID_Detecting_GasPresent})!SID_Detecting_GasPresent -> (
											SKIP;
											exited!y____!SID_Detecting_GasPresent -> SKIP);
											State_Detecting_GasPresent(id__)
								))
						within
							enter?x____:diff(SIDS,{SID_Detecting_GasPresent})!SID_Detecting_GasPresent -> (State_Detecting_GasPresent_execute(id__,x____))
						
						
						I_Detecting_i1(id__) = let
							T_Detecting_t1(id__) = internal__!TID_Detecting_t1 -> enter!SID_Detecting!SID_Detecting_CleanAir -> entered!SID_Detecting!SID_Detecting_CleanAir ->
							SKIP
						within
							T_Detecting_t1(id__)
						
						
						State_Detecting_CleanAir_R(id__) = 
							State_Detecting_CleanAir(id__)
								[|diff(int_int,Detecting_CleanAir_triggers)|]
							SKIP
								 		
						State_Detecting_GasPresent_R(id__) = 
							State_Detecting_GasPresent(id__)
								[|diff(int_int,Detecting_GasPresent_triggers)|]
							SKIP
								 		
							
						STM(id__) = (
							I_Detecting_i1(id__)
								[|
									{|enter.x____.y____, entered.x____.y____, exit.x____.y____, exited.x____.y____ |
										x____ <- diff(SIDS,{SID_Detecting_CleanAir,SID_Detecting_GasPresent}),
										y____ <- {SID_Detecting_CleanAir,SID_Detecting_GasPresent}
								|}|]
							(
								State_Detecting_CleanAir_R(id__)
									[|inter(CS_Detecting_CleanAir_sync,CS_Detecting_GasPresent_sync)|]
								State_Detecting_GasPresent_R(id__)
							)
						)
						
						-- optimized memory process
						
						-- individual memory processes
						
						-- processes that read variables and offer transitions
						MemoryTransitions(id__) = (
							internal__!TID_Detecting_t1 -> SKIP
							[]
							gas__!TID_Detecting_t2.in -> SKIP
							[]
							detect__!TID_Detecting_t3.in.Chemical_innocuous -> SKIP
							[]
							detect__!TID_Detecting_t4.in.Chemical_anomaly -> SKIP
						 	)
						MemoryTransitions_Detecting(id__) =
							(
							 MemoryTransitions(id__);
							 MemoryTransitions_Detecting(id__)
							)
						
						-- synchronisation, hiding and process sets 
						MemoryVariablesProcesses_Detecting = Union(
							{
								{
								}
							}
						)
						
						MemoryVariablesSyncSet = Union({
							{|
								setWC
							|}	
						})
						
						MemoryVariablesHideSet = Union({
							{|
								getWC
							|}
						})
						
						-- combined individual memory processes
						MemoryVariables = ||| P : MemoryVariablesProcesses_Detecting @ P
						
						-- complete memory process
						MemoryN(id__) = (MemoryVariables [| MemoryVariablesSyncSet |] MemoryTransitions_Detecting(id__)) \ MemoryVariablesHideSet
						
						-- optimised memory
						-- Sets of named elements identified according to transition conditions:
						-- {}
						-- Summary of all identified named elements:
						-- {-- }
						
						-- Allocation plan:
						-- 0:{}
						--	=> {
						--		TID_Detecting_t4,
						--		TID_Detecting_t3,
						--		TID_Detecting_t1,
						--		TID_Detecting_t2}
						
						-- Memory transition processes
						MemoryTransitions_opt_0(id__) =
						(
							let
								Update = Current(id__)
								Current(id__)
								 	   = 
								 	   detect__!TID_Detecting_t4.in?x__ -> Update
								 	   []
								 	   detect__!TID_Detecting_t3.in?x__ -> Update
								 	   []
								 	   internal__!TID_Detecting_t1 -> Update
								 	   []
								 	   gas__!TID_Detecting_t2.in -> Update
							within
								Update
						)
						
						-- Memory cell processes
						
						-- Composition of memory, StateMachine and Memory transition processes
						
						MemorySTM_opt(id__) =
							sbisim(	
							  dbisim(
							    sbisim(STM_core(id__)
							      	  [| {|gas__.TID_Detecting_t2,internal__.TID_Detecting_t1,detect__.TID_Detecting_t4,detect__.TID_Detecting_t3|} |]
							      	  MemoryTransitions_opt_0(id__)
							      	  )\{|internal__.TID_Detecting_t1|})
							      )
						
						-- main process
						
						MachineMemorySyncSet = Union({
							union(
								union(
									{||},
									{||}
								)
									
								,
								{|internal__.TID_Detecting_t1,
								gas__.TID_Detecting_t2,
								detect__.TID_Detecting_t3,
								detect__.TID_Detecting_t4|}
							),
							{|deadline|},
							WCresets
						})
						
						MachineMemoryHidingSet = Union({
							union(
								{||},
								{||}
							)
							,
							{|deadline|}
						})
						
						MachineInternalEvents = {|
							internal__
						|}
					
						-- main process
						AUX(id__) = prioritise((((
							wbisim(STM(id__))
								[|MachineMemorySyncSet|]
							(
								(MemoryN(id__))
									[| union(WCsets,WCsync) |]
								Clocks(id__)
							)\WCsets
						)
						[[
							gas__.x____ <- gas,
							detect__.x____ <- detect
							| x____ <- TIDS
						]]
						\MachineMemoryHidingSet)
						[|{|terminate|}|>SKIP\MachineInternalEvents)
						,<Union({internal_events, ClockResets, {|terminate|}}),{tock}>)
						
						STM_core(id__) = 
							dbisim(
								sbisim(
										(STM(id__)
										[| union(WCsync,WCresets) |]
										Clocks(id__))\WCresets
									  )
								  )
						
						AUX_opt(id__) = 
							prioritise(
								(MemorySTM_opt(id__)
								)[[
									gas__.x____ <- gas,
									detect__.x____ <- detect
									| x____ <- TIDS
								]]
							[|{|terminate|}|>SKIP\MachineInternalEvents
							,<Union({internal_events, ClockResets, {|terminate|}}),{tock}>)
						
						internal_(id__) = prioritise((((
							wbisim(STM(id__))
								[|MachineMemorySyncSet|]
							((MemoryN(id__)) [| union(WCsets,WCsync) |] Clocks(id__))\WCsets
						)
						\MachineMemoryHidingSet)
						[|{|terminate|}|>SKIP)
						,<Union({internal_events, ClockResets, {|internal__,terminate|}}),{tock}>)		
						-- declare clocks
						datatype ClockSet = dummyC
						channel clockReset 				-- no clocks declared
						
						-- declare trigger deadlines channel
						channel deadline : TIDS.Signal
						
						-- compile clocks process
						
						-- set of strings that uniquely identify the waiting conditions, each of which is 
						-- used to synchronise with the Memory process to set the correspoding variable in
						-- the memory process.
						datatype setWC_identifierSet = dummyWC
						
						-- declaring getWC and setWC channel for updating memory variables related to clocks
						channel setWC : setWC_identifierSet.Bool
						channel getWC : setWC_identifierSet.Bool
						
						-- Set of pairs capturing waiting condition processes and their alphabet.
						-- It includes the corresponding set of the defined operations.
						WCset(id__) = Union({
							{
							}
							})
						
						-- Auxiliary function to rename the channel set for required clocks.
						
						-- Set of transition events for which synchronisation is required between Clocks and the Memory process.
						-- It includes the corresponding set of the defined operations.
						WCsync = Union({
							{||}
							})
						-- Set of all clock resets, including 'clockReset.C' events and 'entered.x.y' events where x is drawn
						-- from the set of all state machine state identifiers. It includes the corresponding set of the defined operations.
						WCresets = Union({
							{| | x <- SIDS |}
							})
						-- Set of all waiting condition set events. It includes the corresponding set of the defined operations.
						WCsets = Union({
							{|setWC|}
							})
						
						
						
						-- Clocks process
						Clocks(id__) = || (alpha, P) : WCset(id__) @ [alpha] wbisim(P)
		
						-- collects all clockResets including those of operations
						ClockResets = Union({
							{|clockReset|}
											})
						
						-- With no internal events visible
						Dunopt__(id__) = timed_priority(AUX(id__) \ union(internal_events,ClockResets))
						
						D__(id__) = timed_priority(AUX_opt(id__) \ union(internal_events,ClockResets))
						
						O__(id__) = D__(id__)
						
						-- With enter/entered/exit/exited events visible
						FVS__(id__) = timed_priority(AUX(id__) \ ClockResets)
						
						-- With enterV/enteredV/exitV/exitedV events visible
						VS__(id__) = ShowV(timed_priority(AUX(id__) \ ClockResets))
						
						-- With clock resets visible
						FVS_C__(id__) = AUX(id__)
					}
				endmodule
	
	
		Timed(OneStep) {
			-- declaring call and ret events for undefined operations
			channel incrCall
			channel decrCall
	
			CALL__incr(id__) =  EDeadline(incrCall,0)		
			CALL__decr(id__) =  EDeadline(decrCall,0)		
						
			-- declaring controller events
			channel gas: InOut
			channel turn: InOut.core_real
			channel command: InOut.Command
			channel detect: InOut.Chemical
							

		
			-- declaring controller memory
			Memory(id__) = SKIP
			-- declaring controller termination channel
			channel terminate
			
			-- set of visible memory events
			visibleMemoryEvents = {||}
		
			D__(id__) = prioritise(wbisim(
				(
					(
						stm_ref0::D__(id__)[[
							stm_ref0::terminate <- terminate,
							stm_ref0::cd <- command,
							stm_ref0::turn <- turn,
							stm_ref0::incrCall <- incrCall,
							stm_ref0::decrCall <- decrCall
						]]
					)
						[|{|terminate|}|]
					(
						stm_ref1::D__(id__)[[
							stm_ref1::terminate <- terminate,
							stm_ref1::gas <- gas,
							stm_ref1::detect <- detect
						]]
					)
				)
				\diff(
					{|terminate|},
					{|terminate|}
				)
					[|
						union(
							{|
							|},
							{|
							|}
						)
					|]
				Memory(id__)
			)
			\ union(
				{|
				|},
				{|
				|}
			)
			[|{|terminate|}|>SKIP,
			<union(visibleMemoryEvents,{terminate}),{tock}>)
			
			O__(id__) = D__(id__)
			
			-- VS version
			VS__(id__) = prioritise(wbisim(
				(
					(
						stm_ref0::VS__(id__)[[
							stm_ref0::terminate <- terminate,
							stm_ref0::cd <- command,
							stm_ref0::turn <- turn,
							stm_ref0::incrCall <- incrCall,
							stm_ref0::decrCall <- decrCall
						]]
					)
						[|{|terminate|}|]
					(
						stm_ref1::VS__(id__)[[
							stm_ref1::terminate <- terminate,
							stm_ref1::gas <- gas,
							stm_ref1::detect <- detect
						]]
					)
				)
				\diff(
					{|terminate|},
					{|terminate|}
				)
					[|
						union(
							{|
							|},
							{|
							|}
						)
					|]
				Memory(id__)
			)
			\ union(
				{|
				|},
				{|
				|}
			)
			[|{|terminate|}|>SKIP,
			<union(visibleMemoryEvents,{terminate}),{tock}>)
		
			HEXT(id__) = D__(id__) [|shared_variable_events|] SKIP
		}
	endmodule



