include "SMovement_coreassertions.csp"
datatype alphabet_temp = accept_gas_1_temp_t_alphabet | moveCall_0_2__temp_t_alphabet| signal_light_Color_green__2_temp_t_alphabet| signal_light_Color_green__1_temp_t_alphabet| init_temp_t_alphabet| ActivityFinal0_temp_t_alphabet
robochart_temp = "SMovement_coreassertions.csp"
robochart_alphabet_temp = {|SMovement::moveCall,SMovement::obstacle.in,SMovement::obstacle.out|}
countCe_temp = {1..5}
countUpdate_temp = {1..1}
countClear_temp = {1..1}
limiteUpdate_temp = {(1)..(1)}
channel startActivity_temp: ID_temp
channel endActivity_temp: ID_temp
channel ce_temp: ID_temp.countCe_temp
channel clear_temp: ID_temp.countClear_temp
channel update_temp: ID_temp.countUpdate_temp.limiteUpdate_temp
channel endDiagram_temp: ID_temp

alphabet_Astah = {| startActivity_temp, endActivity_temp, ce_temp, clear_temp, update_temp, endDiagram_temp |}

END_DIAGRAM_temp(id) = endDiagram_temp.id -> SKIP
temp(ID_temp) = (Internal_temp(ID_temp) [|{|update_temp,clear_temp,endDiagram_temp|}|] TokenManager_temp_t(ID_temp,0,0))
Internal_temp(id) = StartActivity_temp(id); Node_temp(id); EndActivity_temp(id)
StartActivity_temp(id) = startActivity_temp.id -> SKIP
EndActivity_temp(id) = endActivity_temp.id -> SKIP
AlphabetDiagram_temp(id,accept_gas_1_temp_t_alphabet) = {|ce_temp.id.2,begin.1,end.1,ce_temp.id.3,endDiagram_temp.id|}
AlphabetDiagram_temp(id,moveCall_0_2__temp_t_alphabet) = {|ce_temp.id.1,SMovement::moveCall.0.2,ce_temp.id.2,endDiagram_temp.id|}
AlphabetDiagram_temp(id,signal_light_Color_green__2_temp_t_alphabet) = {|ce_temp.id.4,SMovement::light_Color_green_.out,ce_temp.id.5,endDiagram_temp.id|}
AlphabetDiagram_temp(id,signal_light_Color_green__1_temp_t_alphabet) = {|ce_temp.id.3,SMovement::light_Color_green_.out,ce_temp.id.4,endDiagram_temp.id|}
AlphabetDiagram_temp(id,init_temp_t_alphabet) = {|update_temp.id.1,ce_temp.id.1,endDiagram_temp.id|}
AlphabetDiagram_temp(id,ActivityFinal0_temp_t_alphabet) = {|ce_temp.id.5,clear_temp.id.1,endDiagram_temp.id|}
AlphabetDiagram_temp_t(id) = union(union(union(union(union(AlphabetDiagram_temp(id,accept_gas_1_temp_t_alphabet),AlphabetDiagram_temp(id,moveCall_0_2__temp_t_alphabet)),AlphabetDiagram_temp(id,signal_light_Color_green__2_temp_t_alphabet)),AlphabetDiagram_temp(id,signal_light_Color_green__1_temp_t_alphabet)),AlphabetDiagram_temp(id,init_temp_t_alphabet)),AlphabetDiagram_temp(id,ActivityFinal0_temp_t_alphabet))

ProcessDiagram_temp(id,accept_gas_1_temp_t_alphabet) = normal(accept_gas_1_temp_t(id))
ProcessDiagram_temp(id,moveCall_0_2__temp_t_alphabet) = normal(moveCall_0_2__temp_t(id))
ProcessDiagram_temp(id,signal_light_Color_green__2_temp_t_alphabet) = normal(signal_light_Color_green__2_temp_t(id))
ProcessDiagram_temp(id,signal_light_Color_green__1_temp_t_alphabet) = normal(signal_light_Color_green__1_temp_t(id))
ProcessDiagram_temp(id,init_temp_t_alphabet) = normal(init_temp_t(id))
ProcessDiagram_temp(id,ActivityFinal0_temp_t_alphabet) = normal(ActivityFinal0_temp_t(id))
Node_temp(id) = || x:alphabet_temp @ [AlphabetDiagram_temp(id,x)] ProcessDiagram_temp(id,x)
InitialNode0_temp_t(id) = update_temp.id.1!(1-0) -> ((ce_temp.id.1 -> SKIP))
moveCall_0_2__temp(id) = ((ce_temp.id.1 -> SKIP)); SMovement::moveCall.0.2 -> ((ce_temp.id.2 -> SKIP)); moveCall_0_2__temp(id)
moveCall_0_2__temp_t(id) = moveCall_0_2__temp(id) /\ END_DIAGRAM_temp(id)
accept_gas_1_temp(id) = ((ce_temp.id.2 -> SKIP)); begin.1 -> end.1 -> SKIP; ((ce_temp.id.3 -> SKIP)); accept_gas_1_temp(id)
accept_gas_1_temp_t(id) = accept_gas_1_temp(id) /\ END_DIAGRAM_temp(id)
signal_light_Color_green__1_temp(id) = ((ce_temp.id.3 -> SKIP)); SMovement::light_Color_green_.out -> ((ce_temp.id.4 -> SKIP)); signal_light_Color_green__1_temp(id)
signal_light_Color_green__1_temp_t(id) = signal_light_Color_green__1_temp(id) /\ END_DIAGRAM_temp(id)
signal_light_Color_green__2_temp(id) = ((ce_temp.id.4 -> SKIP)); SMovement::light_Color_green_.out -> ((ce_temp.id.5 -> SKIP)); signal_light_Color_green__2_temp(id)
signal_light_Color_green__2_temp_t(id) = signal_light_Color_green__2_temp(id) /\ END_DIAGRAM_temp(id)
ActivityFinal0_temp(id) = ((ce_temp.id.5 -> SKIP)); clear_temp.id.1 -> SKIP
ActivityFinal0_temp_t(id) = ActivityFinal0_temp(id) /\ END_DIAGRAM_temp(id)
init_temp_t(id) = (InitialNode0_temp_t(id)) /\ END_DIAGRAM_temp(id)

TokenManager_temp(id,x,init) = update_temp.id?c?y:limiteUpdate_temp -> x+y < 10 & x+y > -10 & TokenManager_temp(id,x+y,1) [] clear_temp.id?c -> endDiagram_temp.id -> SKIP [] x == 0 & init == 1 & endDiagram_temp.id -> SKIP
TokenManager_temp_t(id,x,init) = TokenManager_temp(id,x,init)


NRecurse(S, P) = |~| ev : S @ ev -> P

WAIT(alphabet,event) = 
	NRecurse(diff(alphabet, {event}), WAIT(alphabet,event))
	|~|
	event -> SKIP

WAIT_PROCCESSES(processes) = ||| CONTROL : processes @ CONTROL

Prop = PROP(Wait_control_processes) 

alphabet_robochart_temp = {|SMovement::moveCall,SMovement::obstacle.in,SMovement::obstacle.out|}

PROP(processes) = (MAIN [|{|begin, end|}|] WAIT_PROCCESSES(processes) ) \ {|begin, end|}

Wait_temp_1 = WAIT(alphabet_robochart_temp, SMovement::gas.in)

Wait_temp_control_1 = begin.1 -> Wait_temp_1; end.1 -> Wait_temp_control_1

Wait_control_processes = {Wait_temp_control_1}

assert Wait_temp_1 [FD= Prop \ alphabet_Astah
assert Prop \ alphabet_Astah [FD= Wait_temp_1
